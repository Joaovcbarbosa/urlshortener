The file basic.h contains:
/*
 * basic.h
 *
 *  Created on: 18 Apr 2020
 *      Author: Peng
 */

#ifndef BASIC_H_
#define BASIC_H_
#include<algorithm>
#include <vector>
#include<math.h>
#include <iostream>
#include <time.h>
#include <string.h>
#include <fstream>
using namespace std;
///////////////////////////////////////////////////////////////////////////////

#define Max 100000000

#define num_inital 20
#define num_near_nodes 10
#define length_s 7 // the length of each string, the actual value is length_s-1
#define tabu_l  20
#define threshold 50
#define alpha_num 10



#define num_prunning     100

#define control_para 300

#define Probability 400


#define cross_exchange_identify 2

// the parameters to select operators for intra-route and inter-route optimization in local search
#define intra_opt 3                // the number 1, 2 and 3    are 2-opt, tabu search and EAX, respectively
#define inter_opt 3          // the number 1, 2 and 3 are insert operators, solution based tabu search and cross-exchange
#define perturbation_method 2


#endif /* BASIC_H_ */

The file cross.cpp contains:
/*
 * cross.cpp
 *   created on: April 24, 2013
 * last updated: June 13, 2013
 *       author: liushujia
 */

#ifndef __Cross__
#include "cross.h"
#endif

TCross::TCross( int N ){
	fMaxNumOfABcycle = 2000;	// 设置适当的值(2000)
	total_fN = N;
//	tBestTmp.define( total_fN );
	nearData = new int* [ total_fN ];
	for ( int j = 0; j < total_fN; ++j ) nearData[j] = new int [ 5 ];

	fABcycle = new int* [ fMaxNumOfABcycle ];
	for ( int j = 0; j < fMaxNumOfABcycle; ++j ) fABcycle[j] = new int [ 2*total_fN + 4 ];

	koritsu = new int [ total_fN ];
	bunki = new int [ total_fN ];
	koriInv = new int [ total_fN ];
	bunInv = new int [ total_fN ];
	checkKoritsu = new int [ total_fN ];
	fRoute = new int [ 2*total_fN + 1 ];
	fPermu = new int [ fMaxNumOfABcycle ];

	fC = new int [ 2*total_fN+4 ];
	fJun = new int[ total_fN+ 1 ];
	fOrd1 = new int [ total_fN ];
	fOrd2 = new int [ total_fN ];

	// Speed Up Start
	fOrder = new int [ total_fN ];
	fInv = new int [ total_fN ];
	fSegment = new int* [ total_fN ];
	for ( int j = 0; j < total_fN; ++j ) fSegment[ j ] = new int [ 2 ];

	fSegUnit = new int [ total_fN ];
	fSegPosiList = new int[ total_fN ];
	LinkAPosi = new int [ total_fN ];
	LinkBPosi = new int* [ total_fN ];
	for ( int j = 0; j < total_fN; ++j ) LinkBPosi[ j ] = new int [ 2 ];

	fPosiSeg = new int [ total_fN ];
	fNumOfElementInUnit = new int [ total_fN ];
	fCenterUnit = new int [ total_fN ];
	for ( int j = 0; j < total_fN; ++j ) fCenterUnit[ j ] = 0;

	fListOfCenterUnit = new int [ total_fN+2 ];
	fSegForCenter = new int [ total_fN ];
	fGainAB = new double [ total_fN ];
	//fGainAB = new int [ fN ];
	fModiEdge = new int* [ total_fN ];
	for ( int j = 0; j < total_fN; ++j ) fModiEdge[ j ] = new int [ 4 ];

	fBestModiEdge = new int* [ total_fN ];
	for ( int j = 0; j < total_fN; ++j ) fBestModiEdge[ j ] = new int [ 4 ];

	fAppliedCylce = new int [ total_fN ];
	fBestAppliedCylce = new int [ total_fN ];
	// Speed Up End

	// Block2
	fNumOfElementINAB = new int [ fMaxNumOfABcycle ];
	fInEffectNode = new int* [ total_fN ];
	for( int i = 0; i < total_fN; ++i ) fInEffectNode[ i ] = new int [ 2 ];

	fWeightRR = new int* [ fMaxNumOfABcycle ];
	for( int i = 0; i < fMaxNumOfABcycle; ++i ) fWeightRR[ i ] = new int [ fMaxNumOfABcycle ];

	fWeightSR = new int [ fMaxNumOfABcycle ];
	fWeightC = new int [ fMaxNumOfABcycle ];
	fUsedAB = new int [ total_fN ];
	fMovedAB = new int [ total_fN ];
	fABcycleInEset = new int [ fMaxNumOfABcycle ];
}

TCross::~TCross()
{
	delete [] koritsu;
	delete [] bunki;
	delete [] koriInv;
	delete [] bunInv;
	delete [] checkKoritsu;
	delete [] fRoute;
	delete [] fPermu;
	for ( int j = 0; j < total_fN; ++j ) delete[] nearData[ j ];

	delete[] nearData;
	for ( int j = 0; j < fMaxNumOfABcycle; ++j ) delete[] fABcycle[ j ];

	delete[] fABcycle;
	delete [] fC;
	delete [] fJun;
	delete [] fOrd1;
	delete [] fOrd2;

	// Speed Up Start
	delete [] fOrder;
	delete [] fInv;

	for ( int j = 0; j < total_fN; ++j ) delete[] fSegment[ j ];

	delete[] fSegment;
	delete[] fSegUnit;
	delete [] fSegPosiList;
	delete [] LinkAPosi;
	for ( int j = 0; j < total_fN; ++j ) delete[] LinkBPosi[ j ];

	delete [] LinkBPosi;
	delete [] fPosiSeg;
	delete [] fNumOfElementInUnit;
	delete [] fCenterUnit;
	delete [] fListOfCenterUnit;
	delete [] fSegForCenter;
	delete [] fGainAB;

	for ( int j = 0; j < total_fN; ++j ) delete[] fModiEdge[ j ];
	delete [] fModiEdge;
	for ( int j = 0; j < total_fN; ++j ) delete[] fBestModiEdge[ j ];
	delete [] fBestModiEdge;

	delete [] fAppliedCylce;
	delete [] fBestAppliedCylce;
	// Speed Up End

	// Block2
	delete [] fNumOfElementINAB;
	for ( int j = 0; j < total_fN; ++j ) delete [] fInEffectNode[ j ];

	delete [] fInEffectNode;
	for( int i = 0; i < fMaxNumOfABcycle; ++i ) delete [] fWeightRR[ i ];
	delete [] fWeightRR;
	
	delete [] fWeightSR;
	delete [] fWeightC;
	delete [] fUsedAB;
	delete [] fMovedAB;
	delete [] fABcycleInEset;
//	delete eval;
}

void TCross::input_data(int N)
{
	fN=N;
}
void TCross::setParents( const TIndi& tPa1, const TIndi& tPa2, int flagC[ 10 ], int numOfKids ){
	this->setABcycle( tPa1, tPa2, flagC, numOfKids );
	fDisAB = 0;
	int curr, next, st, pre;
	st = 0;
	curr=-1;
	next = st;
	for( int i = 0; i < fN; ++i ){
		pre=curr;
		curr=next;
		if( tPa1.fLink[curr][0] != pre ) next = tPa1.fLink[ curr ][ 0 ];
		else next=tPa1.fLink[curr][1];

		if( tPa2.fLink[ curr ][ 0 ] != next && tPa2.fLink[ curr ][ 1 ] != next ) ++fDisAB;
		fOrder[ i ] = curr;
		fInv[ curr ] = i;
	}
	if( flagC[ 1 ] == 2 ){
		fTmax = 10;
		fMaxStag = 20;                 //1:Greedy LS, 20:Tabu Search
		this->setWeight( tPa1, tPa2 );
	}
}

void TCross::doIt( TIndi& tKid, TIndi& tPa2, int numOfKids, int flagP, int flagC[ 10 ], int **fEdgeFreq ){
	int Num;
	int jnum, centerAB;
	//int gain;
	double gain;
	//int BestGain;
	double BestGain;
	double pointMax, point;
	double DLoss;

	fEvalType = flagC[ 0 ];              //1:Greedy, 2:---, 3:Distance, 4:Entropy
	fEsetType = flagC[ 1 ];              //1:Single-AB, 2:Block2

	if ( numOfKids <= fNumOfABcycle ) Num = numOfKids;
	else Num = fNumOfABcycle;

	if( fEsetType == 1 )		// Single-AB
	tRand->permutation( fPermu, fNumOfABcycle, fNumOfABcycle );

	else if( fEsetType == 2 ){  // Block2
		for( int k =0; k< fNumOfABcycle; ++k ) fNumOfElementINAB[ k ] = fABcycle[ k ][ 0 ];
		tSort->indexB( fNumOfElementINAB, fNumOfABcycle, fPermu, fNumOfABcycle );
	}
	fNumOfGeneratedCh = 0;
	pointMax = 0.0;
	BestGain = 0.0;
	fFlagImp = 0;
	for( int j =0; j < Num; ++j ){
		fNumOfABcycleInEset = 0;
		if( fEsetType == 1 ){         //Single-AB
			jnum = fPermu[ j ];
			fABcycleInEset[ fNumOfABcycleInEset++ ] = jnum;
		}
		else if( fEsetType == 2 ){    //Block2
			jnum = fPermu[ j ];
			centerAB = jnum;
			for( int s = 0; s < fNumOfABcycle; ++s ){
				if( s == centerAB ) fABcycleInEset[ fNumOfABcycleInEset++ ] = s;
				else{
					if( fWeightRR[ centerAB ][ s ] > 0 && fABcycle[ s ][ 0 ] < fABcycle[ centerAB ][ 0 ] )
					if( rand() %2 == 0 ) fABcycleInEset[ fNumOfABcycleInEset++ ] = s;
				}
			}
		this->searchEset( centerAB );
		}
		fNumOfSPL = 0;
		gain = 0.0;
		fNumOfAppliedCycle = 0;
		fNumOfModiEdge = 0;

		fNumOfAppliedCycle = fNumOfABcycleInEset;
		for( int k = 0; k < fNumOfAppliedCycle; ++k ){
			fAppliedCylce[ k ] = fABcycleInEset[ k ];
			jnum = fAppliedCylce[ k ];
			this->changeSol( tKid, jnum, flagP );
			gain += fGainAB[ jnum ];
		}

		this->makeUnit();
		this->makeCompleteSol( tKid );
		gain += fGainModi;

		++fNumOfGeneratedCh;

		if( fEvalType == 1 ) DLoss = 1.0;									//Greedy
		else if( fEvalType == 3 ) DLoss = this->calAdpLoss( fEdgeFreq );	// Distance preservation
		else if( fEvalType == 4 ) DLoss = this->calEntLoss( fEdgeFreq );	// Entropy preservation

		if( DLoss <= 0.0 ) DLoss = 0.00000001;

		point = (double)gain / DLoss;
		tKid.fEvaluationValue = tKid.fEvaluationValue - gain;

		if( pointMax < point && (2 * fBestNumE < fDisAB || tKid.fEvaluationValue != tPa2.fEvaluationValue ) ){
			pointMax = point;
			BestGain = gain;
			fFlagImp = 1;

			fNumOfBestAppliedCycle = fNumOfAppliedCycle;
			for( int s = 0; s < fNumOfBestAppliedCycle; ++s ) fBestAppliedCylce[ s ] = fAppliedCylce[ s ];

			fNumOfBestModiEdge = fNumOfModiEdge;
			for( int s = 0; s < fNumOfBestModiEdge; ++s ){
				fBestModiEdge[ s ][ 0 ] = fModiEdge[ s ][ 0 ];
				fBestModiEdge[ s ][ 1 ] = fModiEdge[ s ][ 1 ];
				fBestModiEdge[ s ][ 2 ] = fModiEdge[ s ][ 2 ];
				fBestModiEdge[ s ][ 3 ] = fModiEdge[ s ][ 3 ];
			}

		}
		this->backToPa1( tKid );
		tKid.fEvaluationValue = tKid.fEvaluationValue + gain;
	}
	if( fFlagImp == 1 ){
		this->goToBest( tKid );
		tKid.fEvaluationValue = tKid.fEvaluationValue - BestGain;
		this->incrementEdgeFreq( fEdgeFreq );
	}
}

void TCross::setABcycle( const TIndi& tPa1, const TIndi& tPa2, int flagC[ 10 ], int numOfKids ){
	bunkiMany=0; koritsuMany=0;
	for( int j = 0; j < fN ; ++j ){
		nearData[j][1]=tPa1.fLink[j][0];
		nearData[j][3]=tPa1.fLink[j][1];
		nearData[j][0] = 2;

		koritsu[koritsuMany]=j;
		koritsuMany++;

		nearData[j][2]=tPa2.fLink[j][0];
		nearData[j][4]=tPa2.fLink[j][1];
	}
	for(int j = 0; j < fN; ++j ){
		checkKoritsu[j]=-1;
		koriInv[koritsu[j]]=j;
	}
	fNumOfABcycle=0;
	flagSt=1;
	while(koritsuMany!=0){
		if(flagSt==1){
			fPosiCurr=0;
			r=rand()%koritsuMany;
			st=koritsu[r];
			checkKoritsu[st]=fPosiCurr;
			fRoute[fPosiCurr]=st;
			ci=st;
			prType=2;
		}
		else if(flagSt==0) ci=fRoute[fPosiCurr];

		flagCycle=0;
		while(flagCycle==0){
			fPosiCurr++;
			pr=ci;
			switch(prType){
			case 1:
				ci=nearData[pr][fPosiCurr%2+1];
			break;
			case 2:
				r=rand()%2;
				ci=nearData[pr][fPosiCurr%2+1+2*r];
				if(r==0) this->swap(nearData[pr][fPosiCurr%2+1],nearData[pr][fPosiCurr%2+3]);
			break;
			case 3:
				ci=nearData[pr][fPosiCurr%2+3];
			}
			fRoute[fPosiCurr]=ci;
			if(nearData[ci][0]==2){
				if(ci==st){
					if(checkKoritsu[st]==0){
					if((fPosiCurr-checkKoritsu[st])%2==0){
						if(nearData[st][fPosiCurr%2+1]==pr) this->swap(nearData[ci][fPosiCurr%2+1],nearData[ci][fPosiCurr%2+3]);

						stAppear = 1;
						this->formABcycle();
						if( flagC[ 1 ] == 1 && fNumOfABcycle == numOfKids ) goto RETURN;
						if( fNumOfABcycle == fMaxNumOfABcycle ) goto RETURN;

						flagSt=0;
						flagCycle=1;
						prType=1;
					}
					else{
						this->swap(nearData[ci][fPosiCurr%2+1],nearData[ci][fPosiCurr%2+3]);
						prType=2;
					}
					checkKoritsu[st]=fPosiCurr;
					}
					else{
					stAppear = 2;
					this->formABcycle();
					if( flagC[ 1 ] == 1 && fNumOfABcycle == numOfKids ) goto RETURN;
					if( fNumOfABcycle == fMaxNumOfABcycle ) goto RETURN;

					flagSt=1;
					flagCycle=1;
					}
				}
				else if(checkKoritsu[ci]==-1) {
					checkKoritsu[ci]=fPosiCurr;
					if(nearData[ci][fPosiCurr%2+1]==pr) this->swap(nearData[ci][fPosiCurr%2+1],nearData[ci][fPosiCurr%2+3]);
					prType=2;
				}
				else if(checkKoritsu[ci]>0){
					this->swap(nearData[ci][fPosiCurr%2+1],nearData[ci][fPosiCurr%2+3]);
					if((fPosiCurr-checkKoritsu[ci])%2==0){
						stAppear = 1;
						this->formABcycle();
						if( flagC[ 1 ] == 1 && fNumOfABcycle == numOfKids ) goto RETURN;
						if( fNumOfABcycle == fMaxNumOfABcycle ) goto RETURN;

						flagSt=0;
						flagCycle=1;
						prType=1;
					}
					else{
						this->swap(nearData[ci][(fPosiCurr+1)%2+1],nearData[ci][(fPosiCurr+1)%2+3]);
						prType=3;
					}
				}
			}
			else if(nearData[ci][0]==1){
				if(ci==st){
					stAppear = 1;
					this->formABcycle();
					if( flagC[ 1 ] == 1 && fNumOfABcycle == numOfKids ) goto RETURN;
					if( fNumOfABcycle == fMaxNumOfABcycle ) goto RETURN;
					flagSt=1;
					flagCycle=1;
				}
				else prType=1;
			}
		}
	}
	while(bunkiMany!=0){
		fPosiCurr=0;
		r=rand()%bunkiMany;
		st=bunki[r];
		fRoute[fPosiCurr]=st;
		ci=st;

		flagCycle=0;
		while(flagCycle==0){
			pr=ci;
			fPosiCurr++;
			ci=nearData[pr][fPosiCurr%2+1];
			fRoute[fPosiCurr]=ci;
			if(ci==st){
				stAppear = 1;
				this->formABcycle();
				if( flagC[ 1 ] == 1 && fNumOfABcycle == numOfKids ) goto RETURN;
				if( fNumOfABcycle == fMaxNumOfABcycle ) goto RETURN;

				flagCycle=1;
			}
		}
	}
RETURN:
	if( fNumOfABcycle == fMaxNumOfABcycle ){
		printf( "fMaxNumOfABcycle(%d) must be increased\n", fMaxNumOfABcycle );
		exit( 1 );
	}
}

void TCross::formABcycle(){
	int j;
	int st_count;
	int edge_type;
	int st,ci, stock;
	int cem;
	double diff;
	//int diff;

	if(fPosiCurr%2==0) edge_type=1;
	else edge_type=2;
	st=fRoute[fPosiCurr];
	cem=0;
	fC[cem]=st;

	st_count=0;
	while(1){
		cem++;
		fPosiCurr--;
		ci=fRoute[fPosiCurr];
		if(nearData[ci][0]==2){
			koritsu[koriInv[ci]]=koritsu[koritsuMany-1];
			koriInv[koritsu[koritsuMany-1]]=koriInv[ci];
			koritsuMany--;
			bunki[bunkiMany]=ci;
			bunInv[ci]=bunkiMany;
			bunkiMany++;
		}
		else if(nearData[ci][0]==1){
			bunki[bunInv[ci]]=bunki[bunkiMany-1];
			bunInv[bunki[bunkiMany-1]]=bunInv[ci];
			bunkiMany--;
		}

		nearData[ci][0]--;
		if(ci==st) st_count++;
		if(st_count==stAppear) break;
		fC[cem]=ci;
	}

	if(cem==2) return;

	fABcycle[fNumOfABcycle][0]=cem;

	if(edge_type==2){
		stock=fC[0];
		for( int j=0;j<cem-1;j++) fC[j]=fC[j+1];
		fC[cem-1]=stock;
	}

	for( int j=0;j<cem;j++) fABcycle[fNumOfABcycle][j+2]=fC[j];

	fABcycle[fNumOfABcycle][1]=fC[cem-1];
	fABcycle[fNumOfABcycle][cem+2]=fC[0];
	fABcycle[fNumOfABcycle][cem+3]=fC[1];

	fC[ cem ] = fC[ 0 ];
	fC[ cem+1 ] = fC[ 1 ];
	diff = 0.0;
	for( j = 0; j < cem/2; ++j ) diff = diff + eval->fEdgeDis[fC[2*j]][fC[1+2*j]] - eval->fEdgeDis[fC[1+2*j]][fC[2+2*j]];

	fGainAB[fNumOfABcycle] = diff;
	++fNumOfABcycle;
}

void TCross::swap(int &x, int &y){
	int s=x;
	x=y;
	y=s;
}

void TCross::changeSol( TIndi& tKid, int ABnum, int type ){
	int j;
	int cem, r1, r2, b1, b2;
	int po_r1, po_r2, po_b1, po_b2;

	cem=fABcycle[ABnum][0];
	fC[0]=fABcycle[ABnum][0];

	if(type==2) for(j=0;j<cem+3;j++) fC[cem+3-j]=fABcycle[ABnum][j+1];
	else for(j=1;j<=cem+3;j++) fC[j]=fABcycle[ABnum][j];

	for(j=0;j<cem/2;j++){
		r1=fC[2+2*j];r2=fC[3+2*j];
		b1=fC[1+2*j];b2=fC[4+2*j];

		if(tKid.fLink[r1][0]==r2) tKid.fLink[r1][0]=b1;
		else tKid.fLink[r1][1]=b1;
		if(tKid.fLink[r2][0]==r1) tKid.fLink[r2][0]=b2;
		else tKid.fLink[r2][1]=b2;

		po_r1 = fInv[ r1 ];
		po_r2 = fInv[ r2 ];
		po_b1 = fInv[ b1 ];
		po_b2 = fInv[ b2 ];

		if( po_r1 == 0 && po_r2 == fN-1 ) fSegPosiList[ fNumOfSPL++ ] = po_r1;
		else if( po_r1 == fN-1 && po_r2 == 0 ) fSegPosiList[ fNumOfSPL++ ] = po_r2;
		else if( po_r1 < po_r2 ) fSegPosiList[ fNumOfSPL++ ] = po_r2;
		else if( po_r2 < po_r1 ) fSegPosiList[ fNumOfSPL++ ] = po_r1;

		LinkBPosi[ po_r1 ][ 1 ] = LinkBPosi[ po_r1 ][ 0 ];
		LinkBPosi[ po_r2 ][ 1 ] = LinkBPosi[ po_r2 ][ 0 ];
		LinkBPosi[ po_r1 ][ 0 ] = po_b1;
		LinkBPosi[ po_r2 ][ 0 ] = po_b2;
	}
}

void TCross::makeCompleteSol( TIndi& tKid ){
	int j, j1, j2;
	int st ,pre, curr, next, a, b, c, d, aa, bb, a1, b1;
	int min_unit_city;
	int center_un, select_un;
	double diff, max_diff;
	//int diff, max_diff;
	int near_num, nearMax;

	fGainModi = 0;
	while( fNumOfUnit != 1 ){
		min_unit_city = fN + 12345;
		for( int u = 0; u < fNumOfUnit; ++u )
			if( fNumOfElementInUnit[ u ] < min_unit_city ){
				center_un = u;
				min_unit_city = fNumOfElementInUnit[ u ];
			}


		st = -1;
		fNumOfSegForCenter = 0;
		for( int s = 0; s < fNumOfSeg; ++s )
			if( fSegUnit[ s ] == center_un ){
				int posi = fSegment[ s ][ 0 ];
				st = fOrder[ posi ];
				fSegForCenter[  fNumOfSegForCenter++ ] = s;
			}
		curr = -1;
		next = st;
		fNumOfElementInCU = 0;
		while(1){
			pre = curr;
			curr = next;
			fCenterUnit[ curr ] = 1;
			fListOfCenterUnit[ fNumOfElementInCU ] = curr;
			++fNumOfElementInCU;
			if( tKid.fLink[ curr ][ 0 ] != pre ) next = tKid.fLink[ curr ][ 0 ];
			else next = tKid.fLink[ curr ][ 1 ];
			if( next == st ) break;
		}
		fListOfCenterUnit[ fNumOfElementInCU ] = fListOfCenterUnit[ 0 ];
		fListOfCenterUnit[ fNumOfElementInCU+1 ] = fListOfCenterUnit[ 1 ];

		max_diff = -999999999;
		a1 = -1; b1 = -1;
		nearMax = 10;	// N_near
						// nearMax <= eva->fNearNumMax (kopt.cpp)

	RESTART:
		for( int s = 1; s <= fNumOfElementInCU; ++s ){
			a = fListOfCenterUnit[ s ];

			for( near_num = 1; near_num <= nearMax; ++near_num ){
				c = eval->fNearCity[ a ][ near_num ];
				if( fCenterUnit[ c ] == 0 ){
					for( j1 = 0; j1 < 2; ++j1 ){
						b = fListOfCenterUnit[ s-1+2*j1 ];
						for( j2 = 0; j2 < 2; ++j2 ){
							d = tKid.fLink[ c ][ j2 ];
							diff = eval->fEdgeDis[a][b] + eval->fEdgeDis[c][d] - eval->fEdgeDis[a][c] - eval->fEdgeDis[b][d];
							if( diff > max_diff ){
								aa = a; bb = b; a1 = c; b1 = d;
								max_diff = diff;
							}
							diff = eval->fEdgeDis[a][b] + eval->fEdgeDis[d][c] -
								eval->fEdgeDis[a][d] - eval->fEdgeDis[b][c];
							if( diff > max_diff ){
								aa = a; bb = b; a1 = d; b1 = c;
								max_diff = diff;
							}
						}
					}
				}
			}
		}

		if( a1 == -1 && nearMax == 10 ){
			nearMax = 50;
			goto RESTART;
		}
		else if( a1 == -1 && nearMax == 50  ){
			int r = rand() % ( fNumOfElementInCU - 1 );
			a = fListOfCenterUnit[ r ];
			b = fListOfCenterUnit[ r+1 ];
			for( j = 0; j < fN; ++j ){
				if( fCenterUnit[ j ] == 0 ){
					aa = a; bb = b;
					a1 = j;
					b1 = tKid.fLink[ j ][ 0 ];
					break;
				}
			}
			max_diff = eval->fEdgeDis[aa][bb] + eval->fEdgeDis[a1][b1] - eval->fEdgeDis[a][a1] - eval->fEdgeDis[b][b1];
		}

		if( tKid.fLink[aa][0] == bb ) tKid.fLink[aa][0]=a1;
		else tKid.fLink[aa][1] = a1;
		if( tKid.fLink[bb][0] == aa ) tKid.fLink[bb][0] = b1;
		else tKid.fLink[bb][1] = b1;
		if( tKid.fLink[a1][0] == b1 ) tKid.fLink[a1][0] = aa;
		else tKid.fLink[a1][1] = aa;
		if( tKid.fLink[b1][0] == a1 ) tKid.fLink[b1][0] = bb;
		else tKid.fLink[b1][1] = bb;

		fModiEdge[ fNumOfModiEdge ][ 0 ] = aa;
		fModiEdge[ fNumOfModiEdge ][ 1 ] = bb;
		fModiEdge[ fNumOfModiEdge ][ 2 ] = a1;
		fModiEdge[ fNumOfModiEdge ][ 3 ] = b1;
		++fNumOfModiEdge;

		fGainModi += max_diff;

		int posi_a1 = fInv[ a1 ];
		select_un = -1;
		for( int s = 0; s < fNumOfSeg; ++s )
			if( fSegment[ s ][ 0 ] <= posi_a1 && posi_a1 <=  fSegment[ s ][ 1 ] ){
				select_un = fSegUnit[ s ];
				break;
			}


		for( int s = 0; s < fNumOfSeg; ++s )
			if( fSegUnit[ s ] == select_un ) fSegUnit[ s ] = center_un;

		fNumOfElementInUnit[ center_un ] += fNumOfElementInUnit[ select_un ];

		for( int s = 0; s < fNumOfSeg; ++s )
			if( fSegUnit[ s ] == fNumOfUnit - 1 ) fSegUnit[ s ] = select_un;

		fNumOfElementInUnit[ select_un ] = fNumOfElementInUnit[ fNumOfUnit - 1 ];
		--fNumOfUnit;

		for( int s = 0; s < fNumOfElementInCU; ++s ){
			c = fListOfCenterUnit[ s ];
			fCenterUnit[ c ] = 0;
		}
	}
}

void TCross::makeUnit(){
	int flag = 1;
	for( int s = 0; s < fNumOfSPL; ++s ){
		if( fSegPosiList[ s ] == 0 ){
			flag = 0;
			break;
		}
	}
	if( flag == 1 ){
		fSegPosiList[ fNumOfSPL++ ] = 0;
		LinkBPosi[ fN-1 ][ 1 ]  = LinkBPosi[ fN-1 ][ 0 ];
		LinkBPosi[ 0 ][ 1 ] = LinkBPosi[ 0 ][ 0 ];
		LinkBPosi[ fN-1 ][ 0 ] = 0;
		LinkBPosi[ 0 ][ 0 ] = fN-1;
	}

	tSort->sort( fSegPosiList, fNumOfSPL );
	fNumOfSeg = fNumOfSPL;
	for( int s = 0; s < fNumOfSeg-1; ++s ){
		fSegment[ s ][ 0 ] = fSegPosiList[ s ];
		fSegment[ s ][ 1 ] = fSegPosiList[ s+1 ]-1;
	}

	fSegment[ fNumOfSeg-1 ][ 0 ] = fSegPosiList[ fNumOfSeg-1 ];
	fSegment[ fNumOfSeg-1 ][ 1 ] = fN - 1;

	for( int s = 0; s < fNumOfSeg; ++s ){
		LinkAPosi[ fSegment[ s ][ 0 ] ] = fSegment[ s ][ 1 ];
		LinkAPosi[ fSegment[ s ][ 1 ] ] = fSegment[ s ][ 0 ];
		fPosiSeg[ fSegment[ s ][ 0 ] ] = s;
		fPosiSeg[ fSegment[ s ][ 1 ] ] = s;
	}

	for( int s = 0; s < fNumOfSeg; ++s ) fSegUnit[ s ] = -1;
	fNumOfUnit = 0;

	int p_st, p1, p2, p_next, p_pre;
	int segNum;
	while(1){
		flag = 0;
		for( int s = 0; s < fNumOfSeg; ++s ){
			if( fSegUnit[ s ] == -1 ){
				p_st = fSegment[ s ][ 0 ];
				p_pre = -1;
				p1 = p_st;
				flag = 1;
				break;
			}
		}
		if( flag == 0 ) break;

		while(1){
			segNum = fPosiSeg[ p1 ];
			fSegUnit[ segNum ] = fNumOfUnit;

			p2 = LinkAPosi[ p1 ];
			p_next = LinkBPosi[ p2 ][ 0 ];
			if( p1 == p2 )
				if( p_next == p_pre ) p_next = LinkBPosi[ p2 ][ 1 ];

			if( p_next == p_st ){
				++fNumOfUnit;
				break;
			}

			p_pre = p2;
			p1 = p_next;
		}
	}

	for( int s = 0; s < fNumOfUnit; ++s ) fNumOfElementInUnit[ s ] = 0;

	int unitNum = -1;
	int tmpNumOfSeg = -1;
	for( int s = 0; s < fNumOfSeg; ++s ){
		if( fSegUnit[ s ] != unitNum ){
			++tmpNumOfSeg;
			fSegment[ tmpNumOfSeg ][ 0 ] = fSegment[ s ][ 0 ];
			fSegment[ tmpNumOfSeg ][ 1 ] = fSegment[ s ][ 1 ];
			unitNum = fSegUnit[ s ];
			fSegUnit[ tmpNumOfSeg ] = unitNum;
			fNumOfElementInUnit[ unitNum ] +=
			fSegment[ s ][ 1 ] - fSegment[ s ][ 0 ] + 1;
		}
		else{
			fSegment[ tmpNumOfSeg ][ 1 ] = fSegment[ s ][ 1 ];
			fNumOfElementInUnit[ unitNum ] +=
			fSegment[ s ][ 1 ] - fSegment[ s ][ 0 ] + 1;
		}
	}
	fNumOfSeg = tmpNumOfSeg + 1;
}

void TCross::backToPa1( TIndi& tKid ){
	int aa, bb, a1, b1;
	int jnum;

	for( int s = fNumOfModiEdge -1; s >= 0; --s ){
		aa = fModiEdge[ s ][ 0 ];
		a1 = fModiEdge[ s ][ 1 ];
		bb = fModiEdge[ s ][ 2 ];
		b1 = fModiEdge[ s ][ 3 ];

		if( tKid.fLink[aa][0] == bb ) tKid.fLink[aa][0] = a1;
		else tKid.fLink[aa][1] = a1;
		if( tKid.fLink[b1][0] == a1 ) tKid.fLink[b1][0] = bb;
		else tKid.fLink[b1][1] = bb;
		if( tKid.fLink[bb][0] == aa ) tKid.fLink[bb][0] = b1;
		else tKid.fLink[bb][1] = b1;
		if( tKid.fLink[a1][0] == b1 ) tKid.fLink[a1][0] = aa;
		else tKid.fLink[a1][1] = aa;
	}

	for( int s = 0; s < fNumOfAppliedCycle; ++s ){
		jnum = fAppliedCylce[ s ];
		this->changeSol( tKid, jnum, 2 );
	}
}

void TCross::goToBest( TIndi& tKid ){
	int aa, bb, a1, b1;
	int jnum;

	for( int s = 0; s < fNumOfBestAppliedCycle; ++s ){
		jnum = fBestAppliedCylce[ s ];
		this->changeSol( tKid, jnum, 1 );
	}

	 for( int s = 0; s < fNumOfBestModiEdge; ++s ){
		aa = fBestModiEdge[ s ][ 0 ];
		bb = fBestModiEdge[ s ][ 1 ];
		a1 = fBestModiEdge[ s ][ 2 ];
		b1 = fBestModiEdge[ s ][ 3 ];

		if( tKid.fLink[aa][0] == bb ) tKid.fLink[aa][0]=a1;
		else tKid.fLink[aa][1] = a1;
		if( tKid.fLink[bb][0] == aa ) tKid.fLink[bb][0] = b1;
		else tKid.fLink[bb][1] = b1;
		if( tKid.fLink[a1][0] == b1 ) tKid.fLink[a1][0] = aa;
		else tKid.fLink[a1][1] = aa;
		if( tKid.fLink[b1][0] == a1 ) tKid.fLink[b1][0] = bb;
		else tKid.fLink[b1][1] = bb;
	}
}

void TCross::incrementEdgeFreq( int **fEdgeFreq ){
	int j, jnum, cem;
	int r1, r2, b1, b2;
	int aa, bb, a1;

	for( int s = 0; s < fNumOfBestAppliedCycle; ++s ){
		jnum = fBestAppliedCylce[ s ];

		cem = fABcycle[ jnum ][ 0 ];
		fC[ 0 ] = fABcycle[ jnum ][ 0 ];

		for( j = 1; j <= cem+3; ++j )
			fC[ j ] = fABcycle[ jnum ][ j ];

		for( j = 0; j <cem/2; ++j ){
			r1 = fC[2+2*j]; r2 = fC[3+2*j];
			b1 = fC[1+2*j]; b2 = fC[4+2*j];

			++fEdgeFreq[ r1 ][ b1 ];
			--fEdgeFreq[ r1 ][ r2 ];
			--fEdgeFreq[ r2 ][ r1 ];
			++fEdgeFreq[ r2 ][ b2 ];
		}
	}
	for( int s = 0; s < fNumOfBestModiEdge; ++s ){
		aa = fBestModiEdge[ s ][ 0 ];
		bb = fBestModiEdge[ s ][ 1 ];
		a1 = fBestModiEdge[ s ][ 2 ];
		b1 = fBestModiEdge[ s ][ 3 ];

		--fEdgeFreq[ aa ][ bb ];
		--fEdgeFreq[ a1 ][ b1 ];
		++fEdgeFreq[ aa ][ a1 ];
		++fEdgeFreq[ bb ][ b1 ];
		--fEdgeFreq[ bb ][ aa ];
		--fEdgeFreq[ b1 ][ a1 ];
		++fEdgeFreq[ a1 ][ aa ];
		++fEdgeFreq[ b1 ][ bb ];
	}
}

int TCross::calAdpLoss( int **fEdgeFreq ){
	int j, jnum, cem;
	int r1, r2, b1, b2;
	int aa, bb, a1;
	double DLoss;

	DLoss = 0;
	for( int s = 0; s < fNumOfAppliedCycle; ++s ){
		jnum = fAppliedCylce[ s ];

		cem = fABcycle[ jnum ][ 0 ];
		fC[ 0 ] = fABcycle[ jnum ][ 0 ];

		for( j = 1; j <= cem+3; ++j ) fC[ j ] = fABcycle[ jnum ][ j ];

		for( j = 0; j <cem/2; ++j ){
			r1 = fC[2+2*j]; r2 = fC[3+2*j];
			b1 = fC[1+2*j]; b2 = fC[4+2*j];


			DLoss -= (fEdgeFreq[ r1 ][ r2 ]-1);
			DLoss -= (fEdgeFreq[ r2 ][ r1 ]-1);
			DLoss += fEdgeFreq[ r2 ][ b2 ];
			DLoss += fEdgeFreq[ b2 ][ r2 ];


			--fEdgeFreq[ r1 ][ r2 ];
			--fEdgeFreq[ r2 ][ r1 ];
			++fEdgeFreq[ r2 ][ b2 ];
			++fEdgeFreq[ b2 ][ r2 ];
		}
	}
	for( int s = 0; s < fNumOfModiEdge; ++s ){
		aa = fModiEdge[ s ][ 0 ];
		bb = fModiEdge[ s ][ 1 ];
		a1 = fModiEdge[ s ][ 2 ];
		b1 = fModiEdge[ s ][ 3 ];

		DLoss -= (fEdgeFreq[ aa ][ bb ]-1);
		DLoss -= (fEdgeFreq[ bb ][ aa ]-1);
		DLoss -= (fEdgeFreq[ a1 ][ b1 ]-1);
		DLoss -= (fEdgeFreq[ b1 ][ a1 ]-1);

		DLoss += fEdgeFreq[ aa ][ a1 ];
		DLoss += fEdgeFreq[ a1 ][ aa ];
		DLoss += fEdgeFreq[ bb ][ b1 ];
		DLoss += fEdgeFreq[ b1 ][ bb ];

		--fEdgeFreq[ aa ][ bb ];
		--fEdgeFreq[ bb ][ aa ];
		--fEdgeFreq[ a1 ][ b1 ];
		--fEdgeFreq[ b1 ][ a1 ];

		++fEdgeFreq[ aa ][ a1 ];
		++fEdgeFreq[ a1 ][ aa ];
		++fEdgeFreq[ bb ][ b1 ];
		++fEdgeFreq[ b1 ][ bb ];
	}
	for( int s = 0; s < fNumOfAppliedCycle; ++s ){
		jnum = fAppliedCylce[ s ];
		cem = fABcycle[ jnum ][ 0 ];
		fC[ 0 ] = fABcycle[ jnum ][ 0 ];
		for( j = 1; j <= cem+3; ++j ) fC[ j ] = fABcycle[ jnum ][ j ];

		for( j = 0; j <cem/2; ++j ){
			r1 = fC[2+2*j]; r2 = fC[3+2*j];
			b1 = fC[1+2*j]; b2 = fC[4+2*j];

			++fEdgeFreq[ r1 ][ r2 ];
			++fEdgeFreq[ r2 ][ r1 ];
			--fEdgeFreq[ r2 ][ b2 ];
			--fEdgeFreq[ b2 ][ r2 ];
		}
	}
	for( int s = 0; s < fNumOfModiEdge; ++s ){
		aa = fModiEdge[ s ][ 0 ];
		bb = fModiEdge[ s ][ 1 ];
		a1 = fModiEdge[ s ][ 2 ];
		b1 = fModiEdge[ s ][ 3 ];

		++fEdgeFreq[ aa ][ bb ];
		++fEdgeFreq[ bb ][ aa ];
		++fEdgeFreq[ a1 ][ b1 ];
		++fEdgeFreq[ b1 ][ a1 ];

		--fEdgeFreq[ aa ][ a1 ];
		--fEdgeFreq[ a1 ][ aa ];
		--fEdgeFreq[ bb ][ b1 ];
		--fEdgeFreq[ b1 ][ bb ];
	}
	return int(DLoss / 2);
}

double TCross::calEntLoss( int **fEdgeFreq ){
	int j, jnum, cem;
	int r1, r2, b1, b2;
	int aa, bb, a1;
	double DLoss;
	double h1, h2;

	DLoss = 0;	// AB-cycle
	for( int s = 0; s < fNumOfAppliedCycle; ++s ){
		jnum = fAppliedCylce[ s ];
		cem = fABcycle[ jnum ][ 0 ];
		fC[ 0 ] = fABcycle[ jnum ][ 0 ];

		for( j = 1; j <= cem+3; ++j ) fC[ j ] = fABcycle[ jnum ][ j ];

		for( j = 0; j <cem/2; ++j ){
			r1 = fC[2+2*j]; r2 = fC[3+2*j];
			b1 = fC[1+2*j]; b2 = fC[4+2*j];

		  h1 = (double)( fEdgeFreq[ r1 ][ r2 ] - 1 )/(double)Npop;
		  h2 = (double)( fEdgeFreq[ r1 ][ r2 ] )/(double)Npop;
		  if( fEdgeFreq[ r1 ][ r2 ] - 1 != 0 ) DLoss -= h1 * log( h1 );
		  DLoss += h2 * log( h2 );
		  --fEdgeFreq[ r1 ][ r2 ];
		  --fEdgeFreq[ r2 ][ r1 ];

		  h1 = (double)( fEdgeFreq[ r2 ][ b2 ] + 1 )/(double)Npop;
		  h2 = (double)( fEdgeFreq[ r2 ][ b2 ])/(double)Npop;
		  DLoss -= h1 * log( h1 );
		  if( fEdgeFreq[ r2 ][ b2 ] != 0 ) DLoss += h2 * log( h2 );
		  ++fEdgeFreq[ r2 ][ b2 ];
		  ++fEdgeFreq[ b2 ][ r2 ];
		}
	}

	for( int s = 0; s < fNumOfModiEdge; ++s ){
		aa = fModiEdge[ s ][ 0 ];
		bb = fModiEdge[ s ][ 1 ];
		a1 = fModiEdge[ s ][ 2 ];
		b1 = fModiEdge[ s ][ 3 ];

		h1 = (double)( fEdgeFreq[ aa ][ bb ] - 1 )/(double)Npop;
		h2 = (double)( fEdgeFreq[ aa ][ bb ] )/(double)Npop;
		if( fEdgeFreq[ aa ][ bb ] - 1 != 0 )
		  DLoss -= h1 * log( h1 );
		DLoss += h2 * log( h2 );
		--fEdgeFreq[ aa ][ bb ];
		--fEdgeFreq[ bb ][ aa ];

		h1 = (double)( fEdgeFreq[ a1 ][ b1 ] - 1 )/(double)Npop;
		h2 = (double)( fEdgeFreq[ a1 ][ b1 ] )/(double)Npop;
		if( fEdgeFreq[ a1 ][ b1 ] - 1 != 0 )
		  DLoss -= h1 * log( h1 );
		DLoss += h2 * log( h2 );
		--fEdgeFreq[ a1 ][ b1 ];
		--fEdgeFreq[ b1 ][ a1 ];

		h1 = (double)( fEdgeFreq[ aa ][ a1 ] + 1 )/(double)Npop;
		h2 = (double)( fEdgeFreq[ aa ][ a1 ])/(double)Npop;
		DLoss -= h1 * log( h1 );
		if( fEdgeFreq[ aa ][ a1 ] != 0 )
		  DLoss += h2 * log( h2 );
		++fEdgeFreq[ aa ][ a1 ];
		++fEdgeFreq[ a1 ][ aa ];

		h1 = (double)( fEdgeFreq[ bb ][ b1 ] + 1 )/(double)Npop;
		h2 = (double)( fEdgeFreq[ bb ][ b1 ])/(double)Npop;
		DLoss -= h1 * log( h1 );
		if( fEdgeFreq[ bb ][ b1 ] != 0 )
		  DLoss += h2 * log( h2 );
		++fEdgeFreq[ bb ][ b1 ];
		++fEdgeFreq[ b1 ][ bb ];
	}
	DLoss = -DLoss;

	// 更新 EdgeFreq
	for( int s = 0; s < fNumOfAppliedCycle; ++s ){
		jnum = fAppliedCylce[ s ];

		cem = fABcycle[ jnum ][ 0 ];
		fC[ 0 ] = fABcycle[ jnum ][ 0 ];

		for( j = 1; j <= cem+3; ++j ) fC[ j ] = fABcycle[ jnum ][ j ];

		for( j = 0; j <cem/2; ++j ){
		  r1 = fC[2+2*j]; r2 = fC[3+2*j];
		  b1 = fC[1+2*j]; b2 = fC[4+2*j];

		  ++fEdgeFreq[ r1 ][ r2 ];
		  ++fEdgeFreq[ r2 ][ r1 ];
		  --fEdgeFreq[ r2 ][ b2 ];
		  --fEdgeFreq[ b2 ][ r2 ];
		}
	}
	for( int s = 0; s < fNumOfModiEdge; ++s ){
		aa = fModiEdge[ s ][ 0 ];
		bb = fModiEdge[ s ][ 1 ];
		a1 = fModiEdge[ s ][ 2 ];
		b1 = fModiEdge[ s ][ 3 ];

		++fEdgeFreq[ aa ][ bb ];
		++fEdgeFreq[ bb ][ aa ];
		++fEdgeFreq[ a1 ][ b1 ];
		++fEdgeFreq[ b1 ][ a1 ];

		--fEdgeFreq[ aa ][ a1 ];
		--fEdgeFreq[ a1 ][ aa ];
		--fEdgeFreq[ bb ][ b1 ];
		--fEdgeFreq[ b1 ][ bb ];
	}
  return DLoss;
}

void TCross::setWeight( const TIndi& tPa1, const TIndi& tPa2 ){
	int cem;
	int r1, r2, v1, v2, v_p;
	int AB_num;

	for( int i = 0; i < fN; ++i ){
		fInEffectNode[ i ][ 0 ] = -1;
		fInEffectNode[ i ][ 1 ] = -1;
	}

	// Step 1:
	for( int s = 0; s < fNumOfABcycle; ++s ){
		cem = fABcycle[ s ][ 0 ];
		for( int j = 0; j < cem/2; ++j ){
			r1 = fABcycle[ s ][ 2*j+2 ];  // red edge
			r2 = fABcycle[ s ][ 2*j+3 ];

			if( fInEffectNode[ r1 ][ 0 ] == -1 ) fInEffectNode[ r1 ][ 0 ] = s;
			else if ( fInEffectNode[ r1 ][ 1 ] == -1 ) fInEffectNode[ r1 ][ 1 ] = s;


			if( fInEffectNode[ r2 ][ 0 ] == -1 ) fInEffectNode[ r2 ][ 0 ] = s;
			else if ( fInEffectNode[ r2 ][ 1 ] == -1 ) fInEffectNode[ r2 ][ 1 ] = s;

		}
	}

	// Step 2:
	for( int i = 0; i < fN; ++i ){
		if( fInEffectNode[ i ][ 0 ] != -1 && fInEffectNode[ i ][ 1 ] == -1 ){
			AB_num = fInEffectNode[ i ][ 0 ];
			v1 = i;

			if( tPa1.fLink[ v1 ][ 0 ] != tPa2.fLink[ v1 ][ 0 ] && tPa1.fLink[ v1 ][ 0 ] != tPa2.fLink[ v1 ][ 1 ] )
				v_p = tPa1.fLink[ v1 ][ 0 ];
			else if( tPa1.fLink[ v1 ][ 1 ] != tPa2.fLink[ v1 ][ 0 ] && tPa1.fLink[ v1 ][ 1 ] != tPa2.fLink[ v1 ][ 1 ] )
				v_p = tPa1.fLink[ v1 ][ 1 ];


			while( 1 ){
				fInEffectNode[ v1 ][ 1 ] = AB_num;

				if( tPa1.fLink[ v1 ][ 0 ] != v_p ) v2 = tPa1.fLink[ v1 ][ 0 ];
				else if( tPa1.fLink[ v1 ][ 1 ] != v_p ) v2 = tPa1.fLink[ v1 ][ 1 ];


				if( fInEffectNode[ v2 ][ 0 ] == -1 ) fInEffectNode[ v2 ][ 0 ] = AB_num;
				else if( fInEffectNode[ v2 ][ 1 ] == -1 ) fInEffectNode[ v2 ][ 1 ] = AB_num;


				if( fInEffectNode[ v2 ][ 1 ] != -1 ) break;
				v_p = v1;
				v1 = v2;
			}
		}
	}

	// Step 3:

	for( int s1 = 0; s1 < fNumOfABcycle; ++s1 ){
		fWeightC[ s1 ] = 0;
		for( int s2 = 0; s2 < fNumOfABcycle; ++s2 ) fWeightRR[ s1 ][ s2 ] = 0;
	}

	for( int i = 0; i < fN; ++i ){

		if( fInEffectNode[ i ][ 0 ] != -1 && fInEffectNode[ i ][ 1 ] != -1 ){
			++fWeightRR[ fInEffectNode[ i ][ 0 ] ][ fInEffectNode[ i ][ 1 ] ];
			++fWeightRR[ fInEffectNode[ i ][ 1 ] ][ fInEffectNode[ i ][ 0 ] ];
		}
		if( fInEffectNode[ i ][ 0 ] != fInEffectNode[ i ][ 1 ] ){
			++fWeightC[ fInEffectNode[ i ][ 0 ] ];
			++fWeightC[ fInEffectNode[ i ][ 1 ] ];
		}
	}
	for( int s1 = 0; s1 < fNumOfABcycle; ++s1 ) fWeightRR[ s1 ][ s1 ] = 0;
}

int TCross::calCNaive(){
	int count_C;
	int tt;

	count_C = 0;

	for( int i = 0; i < fN; ++i ){
		if( fInEffectNode[ i ][ 0 ] != -1 && fInEffectNode[ i ][ 1 ] != -1 ){
			tt = 0;
			if( fUsedAB[ fInEffectNode[ i ][ 0 ] ] == 1 ) ++tt;
			if( fUsedAB[ fInEffectNode[ i ][ 1 ] ] == 1 ) ++tt;
			if( tt == 1 ) ++count_C;
		}
	}
	return count_C;
}

void TCross::searchEset( int centerAB ){
	int nIter, stagImp;
	int delta_weight, min_delta_weight_nt;
	int flag_AddDelete, flag_AddDelete_nt;
	int selected_AB, selected_AB_nt;
	int jnum;

	fNumC = 0;  // Number of C nodes in E-set
	fNumE = 0;  // Number of Edges in E-set

	fNumOfUsedAB = 0;
	for( int s1 = 0; s1 < fNumOfABcycle; ++s1 ){
		fUsedAB[ s1 ] = 0;
		fWeightSR[ s1 ] = 0;
		fMovedAB[ s1 ] = 0;
	}

	for( int s = 0; s < fNumOfABcycleInEset; ++s ){
		jnum = fABcycleInEset[ s ];
		this->addAB( jnum );
	}
	fBestNumC = fNumC;
	fBestNumE = fNumE;

	stagImp = 0;
	nIter = 0;
	while( 1 ){
		++nIter;
		min_delta_weight_nt = 99999999;
		flag_AddDelete = 0;
		flag_AddDelete_nt = 0;
		for( int s1 = 0; s1 < fNumOfABcycle; ++s1 ){
			if( fUsedAB[ s1 ] == 0 && fWeightSR[ s1 ] > 0 ){
				delta_weight = fWeightC[ s1 ] - 2 * fWeightSR[ s1 ];
				if( fNumC + delta_weight < fBestNumC ){
					selected_AB = s1;
					flag_AddDelete = 1;
					fBestNumC = fNumC + delta_weight;
				}
				if( delta_weight < min_delta_weight_nt && nIter > fMovedAB[ s1 ] ){
					selected_AB_nt = s1;
					flag_AddDelete_nt = 1;
					min_delta_weight_nt = delta_weight;
				}
			}
			else if( fUsedAB[ s1 ] == 1 && s1 != centerAB ){
				delta_weight = - fWeightC[ s1 ] + 2 * fWeightSR[ s1 ];
				if( fNumC + delta_weight < fBestNumC ){
					selected_AB = s1;
					flag_AddDelete = -1;
					fBestNumC = fNumC + delta_weight;
				}
				if( delta_weight < min_delta_weight_nt && nIter > fMovedAB[ s1 ] ){
					selected_AB_nt = s1;
					flag_AddDelete_nt = -1;
					min_delta_weight_nt = delta_weight;
				}
			}
		}

		if( flag_AddDelete != 0 ){
			if( flag_AddDelete == 1 ) this->addAB( selected_AB );
			else if( flag_AddDelete == -1 ) this->deleteAB( selected_AB );

			fMovedAB[ selected_AB ] = nIter + tRand->Integer( 1, fTmax );

			fBestNumE = fNumE;

			fNumOfABcycleInEset = 0;
			for( int s1 = 0; s1 < fNumOfABcycle; ++s1 )
				if( fUsedAB[ s1 ] == 1 ) fABcycleInEset[ fNumOfABcycleInEset++ ] = s1;

			stagImp = 0;
		}
		else if( flag_AddDelete_nt != 0 ) {
			if( flag_AddDelete_nt == 1 ) this->addAB( selected_AB_nt );
			else if( flag_AddDelete_nt == -1 )

			this->deleteAB( selected_AB_nt );
			fMovedAB[ selected_AB_nt ] = nIter + tRand->Integer( 1, fTmax );
		}
		if( flag_AddDelete == 0 ) ++stagImp;
		if( stagImp == fMaxStag ) break;
	}
}

void TCross::addAB( int num ){
	fNumC += fWeightC[ num ] - 2 * fWeightSR[ num ];
	fNumE += fABcycle[ num ][ 0 ] / 2;

	fUsedAB[ num ] = 1;
	++fNumOfUsedAB;
	for( int s1 = 0; s1 < fNumOfABcycle; ++s1 ) fWeightSR[ s1 ] += fWeightRR[ s1 ][ num ];
}

void TCross::deleteAB( int num ){
	fNumC -= fWeightC[ num ] - 2 * fWeightSR[ num ];
	fNumE -= fABcycle[ num ][ 0 ] / 2;

	fUsedAB[ num ] = 0;
	--fNumOfUsedAB;
	for( int s1 = 0; s1 < fNumOfABcycle; ++s1 ) fWeightSR[ s1 ] -= fWeightRR[ s1 ][ num ];
}

The file cross.h contains:
/*
 * cross.h
 *   created on: April 24, 2013
 * last updated: June 13, 2013
 *       author: liushujia
 */

#ifndef __Cross__
#define __Cross__

#ifndef __RAND__
#include "randomize.h"
#endif

#ifndef __Sort__
#include "sort.h"
#endif

#ifndef __INDI__
#include "indi.h"
#endif

#ifndef __EVALUATOR__
#include "evaluator.h"
#endif

#include <stdio.h>
#include <stdlib.h>
#include <assert.h>

class TCross{
public:
	TCross( int N );
	~TCross();
	void input_data(int N);
	void doIt( TIndi& tKid, TIndi& tPa2, int numOfKids, int flagP, int flagC[ 10 ], int** fEdgeFreq );	// EAXÃ¤Â¸Â»Ã§Â¨â€¹Ã¥Âºï¿½
	void setParents( const TIndi& tPa1, const TIndi& tPa2, int flagC[ 10 ], int numOfKids );			// Ã¨Â®Â¾Ã§Â½Â®Ã§Ë†Â¶Ã¦Å“Â¬Ã¤Â¸Å½Ã¦Â¯ï¿½Ã¦Å“Â¬
	void setABcycle( const TIndi& parent1, const TIndi& parent2, int flagC[ 10 ], int numOfKids );		// Ã¨Â®Â¾Ã§Â½Â®ABcycle

	void swap(int &x, int &y);
	void formABcycle();																// Ã¤Â¿ï¿½Ã¥Â­ËœABcycle
	void changeSol( TIndi& tKid, int ABnum, int type );								// Ã§â€�Â¨ABcycleÃ¤ÂºÂ§Ã§â€�Å¸Ã¤Â¸Â­Ã©â€”Â´Ã¨Â§Â£

	void makeCompleteSol( TIndi& tKid );					// EAXÃ§Â¬Â¬5Ã¦Â­Â¥
	void makeUnit();										// EAXÃ§Â¬Â¬5-1Ã¦Â­Â¥
	void backToPa1( TIndi& tKid );							// Ã¥â€ºÅ¾Ã¦Â»Å¡p_A
	void goToBest( TIndi& tKid );							// Ã¤Â¿Â®Ã¦â€�Â¹tKidÃ¤Â¸ÂºÃ¥Â­ï¿½Ã¤Â»Â£Ã¦Å“â‚¬Ã¤Â¼ËœÃ¨Â§Â£

	void incrementEdgeFreq( int **fEdgeFreq );				// Ã¥Â¢Å¾Ã¥Å Â fEdgeFreq[][]
	int calAdpLoss( int **fEdgeFreq );						// Ã¨Â®Â¡Ã§Â®â€”Ã¥Â¹Â³Ã¥ï¿½â€¡Ã¨Â·Â¯Ã§Â¨â€¹Ã§Å¡â€žÃ¥Â·Â®
	double calEntLoss( int **fEdgeFreq );					// Ã¨Â®Â¡Ã§Â®â€”Ã¨Â¾Â¹Ã§â€ ÂµÃ§Å¡â€žÃ¥Â·Â®

	void setWeight( const TIndi& parent1, const TIndi& parent2 );	// Block2
	int	calCNaive();
	void searchEset( int num );
	void addAB( int num );
	void deleteAB( int num );

	int fNumOfGeneratedCh;
	TEvaluator* eval;
	int Npop;

private:
//	TIndi tBestTmp;
	int fFlagImp;
	int fN;
	int total_fN;////////////////////////////////
	int r;
	int exam;
	int examFlag;
	int flagSt;
	int flagCycle;
	int prType;
	int chDis;
	int koritsuMany;
	int bunkiMany;
	int st;
	int ci;
	int pr;
	int stock;
	int stAppear;
	int fEvalType;
	int fEsetType;
	int fNumOfABcycleInESet;
	int fNumOfABcycle;
	int fPosiCurr;
	int fMaxNumOfABcycle;

	int *koritsu;
	int *bunki;
	int *koriInv;
	int *bunInv;
	int *checkKoritsu;
	int *fRoute;
	int *fPermu;
	int *fC;
	int *fJun;
	int *fOrd1;
	int *fOrd2;

	int **nearData;
	int **fABcycle;

	// Speed Up Start
	int fNumOfUnit;
	int fNumOfSeg;
	int fNumOfSPL;
	int fNumOfElementInCU;
	int fNumOfSegForCenter;
	double fGainModi;
	//int fGainModi;
	int fNumOfModiEdge;
	int fNumOfBestModiEdge;
	int fNumOfAppliedCycle;
	int fNumOfBestAppliedCycle;

	int *fOrder;
	int *fInv;
	int *fSegUnit;
	int *fSegPosiList;
	int *LinkAPosi;
	int *fPosiSeg;
	int *fNumOfElementInUnit;
	int *fCenterUnit;
	int *fListOfCenterUnit;
	int *fSegForCenter;
	//int *fGainAB;
	double *fGainAB;
	int *fAppliedCylce;
	int *fBestAppliedCylce;

	int **fSegment;
	int **LinkBPosi;
	int **fModiEdge;
	int **fBestModiEdge;
	// Speed Up End

	// Block2
	int fNumOfUsedAB;
	int fNumC;
	int fNumE;
	int fTmax;
	int fMaxStag;
	int fNumOfABcycleInEset;
	int fDisAB;
	int fBestNumC;
	int fBestNumE;

	int *fNumOfElementINAB;
	int *fWeightSR;
	int *fWeightC;
	int *fUsedAB;
	int *fMovedAB;
	int *fABcycleInEset;

	int **fInEffectNode;
	int **fWeightRR;
};

#endif

The file EAX.cpp contains:
/*
 *
 *
 *
 *
 */

#ifndef __ENVIRONMENT__
#include "environment.h"
#endif
#include<iostream>
#include <time.h>
#include <stdio.h>
#include <stdlib.h>
using namespace std;

void EAX(TEnvironment* gEnv, int * given_sol,int count, double *x_coor,double *y_coor){// given a initial tour and coordiantion
//	InitURandom(); //
	int maxNumOfTrial;
	maxNumOfTrial=1;					// repeated times
//	gEnv->Npop=100;						// number of items
//	gEnv->Nch=30;						// number of offsprings

	int opt_tour[count];
	int cc[count];
	for (int i=0;i<=count-1;i++)
		cc[i]=given_sol[i];
//	cout<<"Initializing ..."<<endl;
//	clock_t start = clock();
	gEnv->input_data(given_sol,count,x_coor,y_coor);
//	cout<<"Building solution ..."<<endl;
	for ( int n = 0; n < maxNumOfTrial; ++n ){
		gEnv->doIt();
		gEnv->writeBest(opt_tour);
	}
	int best_sol[count];
	for (int i=0;i<count;i++)
	{
		best_sol[i]=given_sol[opt_tour[i]-1];
	}
	for (int i=0;i<=count;i++)
		given_sol[i]=best_sol[i];
}

The file EAX.h contains:
/*
 * EAX.h
 *
 *  Created on: 13 Apr 2020
 *      Author: Peng
 */

#ifndef EAX_H_
#define EAX_H_

#ifndef __ENVIRONMENT__
#include "environment.h"
#endif




int EAX(TEnvironment* gEnv, int * given_sol,int count, double *x_coor,double *y_coor);





#endif /* EAX_H_ */

The file environment.cpp contains:
/*
 * environment.cpp
 *   created on: April 24, 2013
 * last updated: June 13, 2013
 *       author: liushujia
 */

#ifndef __ENVIRONMENT__
#include "environment.h"
#endif
#include "basic.h"
#include <math.h>
#include<iostream>
using namespace std;

void MakeRandSol(TEvaluator* eval, TIndi& indi);
void Make2optSol(TEvaluator* eval, TIndi& indi);

TEnvironment::TEnvironment(){
	fEvaluator = new TEvaluator();
}

TEnvironment::~TEnvironment(){
	delete [] fIndexForMating;
	delete [] tCurPop;
	int N = fEvaluator->totalCity;
	delete fEvaluator;
	delete tCross;
	delete tKopt;
	for( int i = 0; i < N; ++i ) delete [] fEdgeFreq[ i ];
	delete [] fEdgeFreq;
}
void TEnvironment::input_data(int * given_sol,int count,double *x_coor,double *y_coor)
{
	fEvaluator->setInstance1(given_sol, count,x_coor,y_coor);
	for ( int i = 0; i < Npop; ++i ) tCurPop[i].define1(count);
	tBest.define1(count);// define the best solution
	tCross->input_data(count);
	tKopt->input_data(count);
	tKopt->setInvNearList();
	tCross->Npop = Npop;
	num_nodes=count;
}

void TEnvironment::define(int count,int graph_type){
	fEvaluator->setInstance(count,graph_type);
	int N_c = fEvaluator->totalCity;//æ€»å…±ç‚¹çš„æ•°é‡�
	fIndexForMating = new int [ Npop + 1 ];
	tCurPop = new TIndi [ Npop ];// define the number of population
	for ( int i = 0; i < Npop; ++i ) tCurPop[i].define( N_c );
	tBest.define( N_c );// define the best solution
	tCross = new TCross( N_c );// define a crossover objective by using parameter N which is the number cities
	tCross->eval = fEvaluator;// probe directs it
	tKopt = new TKopt(N_c );
	tKopt->eval = fEvaluator;
	fEdgeFreq = new int* [ N_c ];
	for( int i = 0; i < N_c; ++i ) fEdgeFreq[ i ] = new int [ N_c ];
}

void TEnvironment::doIt(){
	this->fTimeStart = clock();// to calculate the initial time
	this->initPop();				// åˆ�å§‹åŒ–ç§�ç¾¤
	if (num_nodes<10){// in this place, if the number of cities is too small, the k-optis used
		this->setAverageBest();
		return;
	}
	this->fTimeInit = clock();    // initial time
	this->init();
	this->getEdgeFreq();
	no_improve=0;
	change=Max;
	while( 1 ){
		this->setAverageBest();
		if ((change-1.0e-7)>tBest.fEvaluationValue){// indicate the improvement
			change=tBest.fEvaluationValue;
			no_improve=0;
		}
		else
			no_improve++;
//		printf( "%d:\t%f\t%lf\n", fCurNumOfGen, fBestValue, fAverageValue );
		if( this->terminationCondition() || no_improve>100) break;

		this->selectForMating();
		for( int s =0; s < Npop; ++s ) this->generateKids( s );

		++fCurNumOfGen;
	}
	this->fTimeEnd = clock();
}

void TEnvironment::init(){
	fAccumurateNumCh = 0;
	fCurNumOfGen = 0;
	fStagBest = 0;
	fMaxStagBest = 0;
	fStage = 1;				// é˜¶æ®µ1
	fFlagC[ 0 ] = 4;		// ç»´æŒ�ç§�ç¾¤å¤šæ ·æ€§	1:Greedy, 2:---, 3:Distance, 4:Entropy
	fFlagC[ 1 ] = 1;		// Esetç±»åž‹			1:Single-AB, 2:Block2
}

bool TEnvironment::terminationCondition(){
	if ( fAverageValue - fBestValue < 0.00001 )  return true;
	if( fStage == 1 ){
		if( fStagBest == int(1500/Nch) && fMaxStagBest == 0 )			// 1500/Nch
			fMaxStagBest =int( fCurNumOfGen / 10 );						// fMaxStagBest = G/10
		else if( fMaxStagBest != 0 && fMaxStagBest <= fStagBest ){
			fStagBest = 0;
			fMaxStagBest = 0;
			fCurNumOfGen1 = fCurNumOfGen;
			fFlagC[ 1 ] = 2;
			fStage = 2;
		}
		return false;
	}
	if( fStage == 2 ){
		if( fStagBest == int(1500/Nch) && fMaxStagBest == 0 )			// 1500/Nch
			fMaxStagBest = int( (fCurNumOfGen - fCurNumOfGen1) / 10 );	// fMaxStagBest = G/10
		else if( fMaxStagBest != 0 && fMaxStagBest <= fStagBest ) return true;
		return false;
	}

	return true;
}

void TEnvironment::setAverageBest(){
	double stockBest = tBest.fEvaluationValue;
	//int stockBest = tBest.fEvaluationValue;
	fAverageValue = 0.0;
	fBestIndex = 0;
	fBestValue = tCurPop[0].fEvaluationValue;
	for(int i = 0; i < Npop; ++i ){
		fAverageValue += tCurPop[i].fEvaluationValue;
		if( tCurPop[i].fEvaluationValue < fBestValue ){
			fBestIndex = i;
			fBestValue = tCurPop[i].fEvaluationValue;
		}
	}
	tBest = tCurPop[ fBestIndex ];
	fAverageValue /= (double)Npop;
	if( tBest.fEvaluationValue < stockBest ){
		fStagBest = 0;
		fBestNumOfGen = fCurNumOfGen;
		fBestAccumeratedNumCh = fAccumurateNumCh;
	}
	else ++fStagBest;
}

void TEnvironment::initPop(){
	for ( int i = 0; i < Npop; ++i ){
		tKopt->makeRandSol( tCurPop[ i ] );		// è®¾ç½®ä¸€ä¸ªéš�æœºè·¯ç¨‹
		tKopt->doIt( tCurPop[ i ] );			// å±€éƒ¨æ�œç´¢(2-opt neighborhood)
	}
}

void TEnvironment::selectForMating(){
	tRand->permutation( fIndexForMating, Npop, Npop );
	fIndexForMating[ Npop ] = fIndexForMating[ 0 ];
}

void TEnvironment::generateKids( int s ){
	// tCurPop[fIndexForMating[s]] è¢«æ›¿æ�¢ä¸ºtCross->DoIt()ä¸­å­�ä»£çš„ä¸€ä¸ªæœ€ä¼˜è§£
	// fEdgeFreq[][] å�Œæ—¶è¢«æ›´æ–°
	tCross->setParents( tCurPop[fIndexForMating[s]], tCurPop[fIndexForMating[s+1]], fFlagC, Nch );
	tCross->doIt( tCurPop[fIndexForMating[s]], tCurPop[fIndexForMating[s+1]], Nch, 1, fFlagC, fEdgeFreq );
	fAccumurateNumCh += tCross->fNumOfGeneratedCh;
}

void TEnvironment::getEdgeFreq(){
	int  k0, k1, N = fEvaluator->Ncity;
	for( int j1 = 0; j1 < N; ++j1 )
		for( int j2 = 0; j2 < N; ++j2 )
			fEdgeFreq[ j1 ][ j2 ] = 0;

	for( int i = 0; i < Npop; ++i )
		for(int j = 0; j < N; ++j ){
			k0 = tCurPop[ i ].fLink[ j ][ 0 ];
			k1 = tCurPop[ i ].fLink[ j ][ 1 ];
			++fEdgeFreq[ j ][ k0 ];
			++fEdgeFreq[ j ][ k1 ];
		}
}

void TEnvironment::printOn( int n ){
	printf( "n = %d val = %f Gen = %d Time = %d %d\n" , n, tBest.fEvaluationValue, fCurNumOfGen,
		(int)((double)(this->fTimeInit - this->fTimeStart)/(double)CLOCKS_PER_SEC),
		(int)((double)(this->fTimeEnd - this->fTimeStart)/(double)CLOCKS_PER_SEC) );
//	fflush(stdout);

}

void TEnvironment::writeBest(int *given_sol){
//	FILE *fp;
//	char filename[ 80 ];

//	sprintf( filename, "bestSolution.txt" );
//	fp = fopen( filename, "a");
	fEvaluator->writeTo(given_sol, tBest );
//	fclose( fp );
}

The file environment.h contains:

/*
 * environment.h
 *   created on: April 24, 2013
 * last updated: June 13, 2013
 *       author: liushujia
 */

#ifndef __ENVIRONMENT__
#define __ENVIRONMENT__

#ifndef __INDI__
#include "indi.h"
#endif

#ifndef __RAND__
#include "randomize.h"
#endif

#ifndef __EVALUATOR__
#include "evaluator.h"
#endif

#ifndef __Cross__
#include "cross.h"
#endif

#ifndef __KOPT__
#include "kopt.h"
#endif

#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <string.h>
#include <time.h>

class TEnvironment{
public:
	TEnvironment();
	~TEnvironment();
	void input_data(int * given_sol,int count,double *x_coor,double *y_coor);
	void define(int count,int graph_type);						// ÃƒÂ¥Ã‹â€ Ã¯Â¿Â½ÃƒÂ¥Ã‚Â§Ã¢â‚¬Â¹ÃƒÂ¥Ã…â€™Ã¢â‚¬â€œ
	//void define();						// ÃƒÂ¥Ã‹â€ Ã¯Â¿Â½ÃƒÂ¥Ã‚Â§Ã¢â‚¬Â¹ÃƒÂ¥Ã…â€™Ã¢â‚¬â€œ
	void doIt();						// GAÃƒÂ¤Ã‚Â¸Ã‚Â»ÃƒÂ§Ã‚Â¨Ã¢â‚¬Â¹ÃƒÂ¥Ã‚ÂºÃ¯Â¿Â½
	void init();						// GAÃƒÂ¥Ã‹â€ Ã¯Â¿Â½ÃƒÂ¥Ã‚Â§Ã¢â‚¬Â¹ÃƒÂ¥Ã…â€™Ã¢â‚¬â€œ
	bool terminationCondition();		// ÃƒÂ©Ã¢â€šÂ¬Ã¢â€šÂ¬ÃƒÂ¥Ã¢â‚¬Â¡Ã‚ÂºÃƒÂ¦Ã¯Â¿Â½Ã‚Â¡ÃƒÂ¤Ã‚Â»Ã‚Â¶
	void setAverageBest();				// ÃƒÂ¨Ã‚Â®Ã‚Â¡ÃƒÂ§Ã‚Â®Ã¢â‚¬â€�ÃƒÂ§Ã‚Â§Ã¯Â¿Â½ÃƒÂ§Ã‚Â¾Ã‚Â¤ÃƒÂ¥Ã‚Â¹Ã‚Â³ÃƒÂ¥Ã¯Â¿Â½Ã¢â‚¬Â¡TSPÃƒÂ©Ã¢â‚¬Â¢Ã‚Â¿ÃƒÂ¥Ã‚ÂºÃ‚Â¦ÃƒÂ¤Ã‚Â¸Ã…Â½ÃƒÂ§Ã‚Â§Ã¯Â¿Â½ÃƒÂ§Ã‚Â¾Ã‚Â¤ÃƒÂ¦Ã…â€œÃ¢â€šÂ¬ÃƒÂ¤Ã‚Â¼Ã‹Å“TSPÃƒÂ©Ã¢â‚¬Â¢Ã‚Â¿ÃƒÂ¥Ã‚ÂºÃ‚Â¦

	void initPop();						// ÃƒÂ¥Ã‹â€ Ã¯Â¿Â½ÃƒÂ¥Ã‚Â§Ã¢â‚¬Â¹ÃƒÂ¥Ã…â€™Ã¢â‚¬â€œÃƒÂ§Ã‚Â§Ã¯Â¿Â½ÃƒÂ§Ã‚Â¾Ã‚Â¤
	void selectForMating();				// ÃƒÂ©Ã¢â€šÂ¬Ã¢â‚¬Â°ÃƒÂ¦Ã¢â‚¬Â¹Ã‚Â©ÃƒÂ§Ã‹â€ Ã‚Â¶ÃƒÂ¦Ã…â€œÃ‚Â¬ÃƒÂ¤Ã‚Â¸Ã…Â½ÃƒÂ¦Ã‚Â¯Ã¯Â¿Â½ÃƒÂ¦Ã…â€œÃ‚Â¬
	void generateKids( int s );			// ÃƒÂ¤Ã‚ÂºÃ‚Â§ÃƒÂ§Ã¢â‚¬ï¿½Ã…Â¸ÃƒÂ¥Ã‚Â¹Ã‚Â¶ÃƒÂ©Ã¢â€šÂ¬Ã¢â‚¬Â°ÃƒÂ¦Ã¢â‚¬Â¹Ã‚Â©ÃƒÂ¥Ã‚Â­Ã¯Â¿Â½ÃƒÂ¤Ã‚Â»Ã‚Â£
	void getEdgeFreq();					// ÃƒÂ¨Ã‚Â®Ã‚Â¡ÃƒÂ§Ã‚Â®Ã¢â‚¬â€�ÃƒÂ§Ã‚Â§Ã¯Â¿Â½ÃƒÂ§Ã‚Â¾Ã‚Â¤ÃƒÂ¤Ã‚Â¸Ã‚Â­ÃƒÂ¦Ã‚Â¯Ã¯Â¿Â½ÃƒÂ¦Ã¯Â¿Â½Ã‚Â¡ÃƒÂ¨Ã‚Â¾Ã‚Â¹ÃƒÂ§Ã…Â¡Ã¢â‚¬Å¾ÃƒÂ©Ã‚Â¢Ã¢â‚¬ËœÃƒÂ§Ã…Â½Ã¢â‚¬Â¡

	void printOn( int n );				// ÃƒÂ¨Ã‚Â¾Ã¢â‚¬Å“ÃƒÂ¥Ã¢â‚¬Â¡Ã‚ÂºÃƒÂ§Ã‚Â»Ã¢â‚¬Å“ÃƒÂ¦Ã…Â¾Ã…â€œ
	void writeBest(int *given_sol);					// ÃƒÂ¨Ã‚Â¾Ã¢â‚¬Å“ÃƒÂ¥Ã¢â‚¬Â¡Ã‚ÂºÃƒÂ¦Ã…â€œÃ¢â€šÂ¬ÃƒÂ¤Ã‚Â¼Ã‹Å“TSPÃƒÂ¨Ã‚Â·Ã‚Â¯ÃƒÂ¥Ã‚Â¾Ã¢â‚¬Å¾
	//void writeBest();					// ÃƒÂ¨Ã‚Â¾Ã¢â‚¬Å“ÃƒÂ¥Ã¢â‚¬Â¡Ã‚ÂºÃƒÂ¦Ã…â€œÃ¢â€šÂ¬ÃƒÂ¤Ã‚Â¼Ã‹Å“TSPÃƒÂ¨Ã‚Â·Ã‚Â¯ÃƒÂ¥Ã‚Â¾Ã¢â‚¬Å¾

	TEvaluator* fEvaluator;				// ÃƒÂ¨Ã‚Â¾Ã‚Â¹ÃƒÂ¨Ã‚Â·Ã¯Â¿Â½ÃƒÂ§Ã‚Â¦Ã‚Â»
	TCross* tCross;						// ÃƒÂ¨Ã‚Â¾Ã‚Â¹ÃƒÂ©Ã¢â‚¬ÂºÃ¢â‚¬Â ÃƒÂ¥Ã¯Â¿Â½Ã‹â€ ÃƒÂ¤Ã‚ÂºÃ‚Â¤ÃƒÂ¥Ã¯Â¿Â½Ã¢â‚¬Â°
	TKopt* tKopt;						// ÃƒÂ¥Ã‚Â±Ã¢â€šÂ¬ÃƒÂ©Ã†â€™Ã‚Â¨ÃƒÂ¦Ã¯Â¿Â½Ã…â€œÃƒÂ§Ã‚Â´Ã‚Â¢(2-opt neighborhood)
//	char *fFileNameTSP;					// TSPÃƒÂ¦Ã¢â‚¬â€œÃ¢â‚¬Â¡ÃƒÂ¤Ã‚Â»Ã‚Â¶ÃƒÂ¥Ã¯Â¿Â½Ã¯Â¿Â½

	int Npop;							// ÃƒÂ§Ã‚Â§Ã¯Â¿Â½ÃƒÂ§Ã‚Â¾Ã‚Â¤ÃƒÂ¦Ã¢â‚¬Â¢Ã‚Â°ÃƒÂ©Ã¢â‚¬Â¡Ã¯Â¿Â½
	int Nch;							// ÃƒÂ¦Ã‚Â¯Ã¯Â¿Â½ÃƒÂ¤Ã‚Â¸Ã‚ÂªÃƒÂ§Ã‹â€ Ã‚Â¶ÃƒÂ¦Ã…â€œÃ‚Â¬(ÃƒÂ¦Ã‚Â¯Ã¯Â¿Â½ÃƒÂ¦Ã…â€œÃ‚Â¬)ÃƒÂ¤Ã‚ÂºÃ‚Â§ÃƒÂ§Ã¢â‚¬ï¿½Ã…Â¸ÃƒÂ§Ã…Â¡Ã¢â‚¬Å¾ÃƒÂ¥Ã‚Â­Ã¯Â¿Â½ÃƒÂ¤Ã‚Â»Ã‚Â£ÃƒÂ¦Ã¢â‚¬Â¢Ã‚Â°ÃƒÂ©Ã¢â‚¬Â¡Ã¯Â¿Â½
	TIndi* tCurPop;						// ÃƒÂ¥Ã‚Â½Ã¢â‚¬Å“ÃƒÂ¥Ã¢â‚¬Â°Ã¯Â¿Â½ÃƒÂ§Ã‚Â§Ã¯Â¿Â½ÃƒÂ§Ã‚Â¾Ã‚Â¤ÃƒÂ¦Ã‹â€ Ã¯Â¿Â½ÃƒÂ¥Ã¢â‚¬ËœÃ‹Å“
	TIndi tBest;						// ÃƒÂ¥Ã‚Â½Ã¢â‚¬Å“ÃƒÂ¥Ã¢â‚¬Â°Ã¯Â¿Â½ÃƒÂ§Ã‚Â§Ã¯Â¿Â½ÃƒÂ§Ã‚Â¾Ã‚Â¤ÃƒÂ¦Ã…â€œÃ¢â€šÂ¬ÃƒÂ¤Ã‚Â¼Ã‹Å“ÃƒÂ¨Ã‚Â§Ã‚Â£
	int fCurNumOfGen;					// ÃƒÂ¥Ã‚Â½Ã¢â‚¬Å“ÃƒÂ¥Ã¢â‚¬Â°Ã¯Â¿Â½ÃƒÂ§Ã‚Â§Ã¯Â¿Â½ÃƒÂ§Ã‚Â¾Ã‚Â¤ÃƒÂ¤Ã‚Â»Ã‚Â£ÃƒÂ¦Ã¢â‚¬Â¢Ã‚Â°
	long int fAccumurateNumCh;			// ÃƒÂ¥Ã‚Â­Ã¯Â¿Â½ÃƒÂ¤Ã‚Â»Ã‚Â£ÃƒÂ§Ã‚Â´Ã‚Â¯ÃƒÂ¨Ã‚Â®Ã‚Â¡ÃƒÂ¦Ã¢â‚¬Â¢Ã‚Â°ÃƒÂ§Ã¢â‚¬ÂºÃ‚Â®

	int fBestNumOfGen;					// ÃƒÂ¥Ã‚Â½Ã¢â‚¬Å“ÃƒÂ¥Ã¢â‚¬Â°Ã¯Â¿Â½ÃƒÂ¦Ã…â€œÃ¢â€šÂ¬ÃƒÂ¤Ã‚Â¼Ã‹Å“ÃƒÂ¨Ã‚Â§Ã‚Â£ÃƒÂ¦Ã¢â‚¬Â°Ã¢â€šÂ¬ÃƒÂ¥Ã…â€œÃ‚Â¨ÃƒÂ§Ã…Â¡Ã¢â‚¬Å¾ÃƒÂ¤Ã‚Â»Ã‚Â£ÃƒÂ¦Ã¢â‚¬Â¢Ã‚Â°
	long int fBestAccumeratedNumCh;		// ÃƒÂ¥Ã‚Â½Ã¢â‚¬Å“ÃƒÂ¥Ã¢â‚¬Â°Ã¯Â¿Â½ÃƒÂ¦Ã…â€œÃ¢â€šÂ¬ÃƒÂ¤Ã‚Â¼Ã‹Å“ÃƒÂ¨Ã‚Â§Ã‚Â£ÃƒÂ§Ã…Â¡Ã¢â‚¬Å¾ÃƒÂ¥Ã‚Â­Ã¯Â¿Â½ÃƒÂ¤Ã‚Â»Ã‚Â£ÃƒÂ§Ã‚Â´Ã‚Â¯ÃƒÂ¨Ã‚Â®Ã‚Â¡ÃƒÂ¦Ã¢â‚¬Â¢Ã‚Â°ÃƒÂ§Ã¢â‚¬ÂºÃ‚Â®
	int **fEdgeFreq;					// ÃƒÂ§Ã‚Â§Ã¯Â¿Â½ÃƒÂ§Ã‚Â¾Ã‚Â¤ÃƒÂ§Ã…Â¡Ã¢â‚¬Å¾ÃƒÂ¨Ã‚Â¾Ã‚Â¹ÃƒÂ©Ã‚Â¢Ã¢â‚¬ËœÃƒÂ§Ã…Â½Ã¢â‚¬Â¡
	double fAverageValue;				// ÃƒÂ§Ã‚Â§Ã¯Â¿Â½ÃƒÂ§Ã‚Â¾Ã‚Â¤TSPÃƒÂ¨Ã‚Â·Ã‚Â¯ÃƒÂ¥Ã‚Â¾Ã¢â‚¬Å¾ÃƒÂ§Ã…Â¡Ã¢â‚¬Å¾ÃƒÂ¥Ã‚Â¹Ã‚Â³ÃƒÂ¥Ã¯Â¿Â½Ã¢â‚¬Â¡ÃƒÂ©Ã¢â‚¬Â¢Ã‚Â¿ÃƒÂ¥Ã‚ÂºÃ‚Â¦
	double fBestValue;						// ÃƒÂ§Ã‚Â§Ã¯Â¿Â½ÃƒÂ§Ã‚Â¾Ã‚Â¤ÃƒÂ¦Ã…â€œÃ¢â€šÂ¬ÃƒÂ¤Ã‚Â¼Ã‹Å“ÃƒÂ¨Ã‚Â§Ã‚Â£ÃƒÂ§Ã…Â¡Ã¢â‚¬Å¾ÃƒÂ¨Ã‚Â·Ã‚Â¯ÃƒÂ¥Ã‚Â¾Ã¢â‚¬Å¾ÃƒÂ©Ã¢â‚¬Â¢Ã‚Â¿ÃƒÂ¥Ã‚ÂºÃ‚Â¦  //int fBestValue;						// ÃƒÂ§Ã‚Â§Ã¯Â¿Â½ÃƒÂ§Ã‚Â¾Ã‚Â¤ÃƒÂ¦Ã…â€œÃ¢â€šÂ¬ÃƒÂ¤Ã‚Â¼Ã‹Å“ÃƒÂ¨Ã‚Â§Ã‚Â£ÃƒÂ§Ã…Â¡Ã¢â‚¬Å¾ÃƒÂ¨Ã‚Â·Ã‚Â¯ÃƒÂ¥Ã‚Â¾Ã¢â‚¬Å¾ÃƒÂ©Ã¢â‚¬Â¢Ã‚Â¿ÃƒÂ¥Ã‚ÂºÃ‚Â¦
	int fBestIndex;						// ÃƒÂ¦Ã…â€œÃ¢â€šÂ¬ÃƒÂ¤Ã‚Â¼Ã‹Å“ÃƒÂ§Ã‚Â§Ã¯Â¿Â½ÃƒÂ§Ã‚Â¾Ã‚Â¤ÃƒÂ§Ã…Â¡Ã¢â‚¬Å¾ÃƒÂ¤Ã‚Â¸Ã¢â‚¬Â¹ÃƒÂ¦Ã‚Â Ã¢â‚¬Â¡

	int* fIndexForMating;				// ÃƒÂ¤Ã‚ÂºÃ‚Â¤ÃƒÂ¥Ã¯Â¿Â½Ã¢â‚¬Â°ÃƒÂ¥Ã‹â€ Ã¢â‚¬â€�ÃƒÂ¨Ã‚Â¡Ã‚Â¨(r[])
	int fStagBest;						// ÃƒÂ¥Ã‚Â­Ã¯Â¿Â½ÃƒÂ¤Ã‚Â»Ã‚Â£ÃƒÂ¦Ã…â€œÃ¢â€šÂ¬ÃƒÂ¤Ã‚Â¼Ã‹Å“ÃƒÂ¨Ã‚Â§Ã‚Â£ÃƒÂ¦Ã‚Â²Ã‚Â¡ÃƒÂ¦Ã…â€œÃ¢â‚¬Â°ÃƒÂ¦Ã¯Â¿Â½Ã¯Â¿Â½ÃƒÂ¥Ã¯Â¿Â½Ã¢â‚¬Â¡ÃƒÂ§Ã…Â¡Ã¢â‚¬Å¾ÃƒÂ§Ã‚Â´Ã‚Â¯ÃƒÂ¨Ã‚Â®Ã‚Â¡ÃƒÂ¤Ã‚Â»Ã‚Â£ÃƒÂ¦Ã¢â‚¬Â¢Ã‚Â°
	int fFlagC[ 10 ];					// EAXÃƒÂ¦Ã¢â‚¬â€œÃ‚Â¹ÃƒÂ¥Ã‚Â¼Ã¯Â¿Â½ÃƒÂ¤Ã‚Â¸Ã…Â½ÃƒÂ©Ã¢â€šÂ¬Ã¢â‚¬Â°ÃƒÂ¦Ã¢â‚¬Â¹Ã‚Â©ÃƒÂ§Ã‚Â­Ã¢â‚¬â€œÃƒÂ§Ã¢â‚¬Â¢Ã‚Â¥
	int fStage;							// ÃƒÂ¥Ã‚Â½Ã¢â‚¬Å“ÃƒÂ¥Ã¢â‚¬Â°Ã¯Â¿Â½ÃƒÂ©Ã‹Å“Ã‚Â¶ÃƒÂ¦Ã‚Â®Ã‚Âµ
	int fMaxStagBest;					// fStagBest==fMaxStagBestÃƒÂ¦Ã¢â‚¬â€�Ã‚Â¶ÃƒÂ¦Ã¢â‚¬Â°Ã‚Â§ÃƒÂ¨Ã‚Â¡Ã…â€™ÃƒÂ¤Ã‚Â¸Ã¢â‚¬Â¹ÃƒÂ¤Ã‚Â¸Ã¢â€šÂ¬ÃƒÂ©Ã‹Å“Ã‚Â¶ÃƒÂ¦Ã‚Â®Ã‚Âµ
	int fCurNumOfGen1;					// Stage IÃƒÂ§Ã‚Â»Ã¢â‚¬Å“ÃƒÂ¦Ã¯Â¿Â½Ã…Â¸ÃƒÂ¦Ã¢â‚¬â€�Ã‚Â¶ÃƒÂ§Ã…Â¡Ã¢â‚¬Å¾ÃƒÂ§Ã‚Â§Ã¯Â¿Â½ÃƒÂ§Ã‚Â¾Ã‚Â¤ÃƒÂ¤Ã‚Â»Ã‚Â£ÃƒÂ¦Ã¢â‚¬Â¢Ã‚Â°

	clock_t fTimeStart, fTimeInit, fTimeEnd;	// ÃƒÂ¤Ã‚Â¿Ã¯Â¿Â½ÃƒÂ¥Ã‚Â­Ã‹Å“ÃƒÂ¨Ã‚Â®Ã‚Â¡ÃƒÂ§Ã‚Â®Ã¢â‚¬â€�ÃƒÂ¦Ã¢â‚¬â€�Ã‚Â¶ÃƒÂ©Ã¢â‚¬â€�Ã‚Â´
private:
	int no_improve;
	double change;
	int num_nodes;
};

#endif

The file evaluator.cpp contains:
/*
 * evaluator.cpp
 *   created on: April 24, 2013
 * last updated: June 13, 2013
 *       author: liushujia
 */

#ifndef __EVALUATOR__
#include "evaluator.h"
#endif
TEvaluator::TEvaluator(){
	fEdgeDis = NULL;
	fNearCity = NULL;
	Ncity = 0;
	fNearNumMax = 50;
}

TEvaluator::~TEvaluator(){
	for ( int i = 0; i < totalCity; ++i ) delete[] fEdgeDis[ i ];
	delete[] fEdgeDis;

	for ( int i = 0; i < totalCity; ++i ) delete[] fNearCity[ i ];
	delete[] fNearCity;

	delete [] x;
	delete [] y;
}
void TEvaluator::setInstance(int count ,int graph_type){
	totalCity=count;
	graph_t=graph_type;
	x = new double [ totalCity ];
	y = new double [ totalCity ];
	fEdgeDis = new double * [totalCity];
	for( int i = 0; i < totalCity; ++i ) fEdgeDis[ i ] = new double [ totalCity ];//fEdgeDis[ i ] = new int [ Ncity ];
	fNearCity = new int* [ totalCity ];
	for( int i = 0; i < totalCity; ++i ) fNearCity[ i ] = new int [ fNearNumMax+1 ];
}
void TEvaluator::setInstance1( int * given_sol,int count,double *x_coor,double *y_coor){
	Ncity=count;
	int *checkedN = new int[Ncity];// dynamic array with a probe
	for (int i=0;i<Ncity;++i)
	{
		x[i]=x_coor[given_sol[i]];
		y[i]=y_coor[given_sol[i]];
	}
	// calculate the distance matrix
	if (graph_t==1){
		for( int i = 0; i < Ncity ; ++i )
			for( int j = 0; j < Ncity ; ++j )
				fEdgeDis[ i ][ j ]=(sqrt((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j])));
	}
	if (graph_t==2){
		for( int i = 0; i < Ncity ; ++i )
			for( int j = 0; j < Ncity ; ++j ){
				double r = (sqrt(((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j]))/10.0));
				int t = (int)r;
				if( (double)t < r ) {
					fEdgeDis[ i ][ j ] = t+1;
				}
				else {
					fEdgeDis[ i ][ j ] = t;
				}
				//fEdgeDis[ i ][ j ]=ceil(sqrt((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j])));
			}
	}
	if (graph_t==3){
		for( int i = 0; i < Ncity ; ++i )
			for( int j = 0; j < Ncity ; ++j )
				fEdgeDis[ i ][ j ]=ceil(sqrt((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j])));
	}

	if (graph_t==4){
		double q1,q2,q3;
		double RRR = 6378.388;
		double latitude[Ncity];
		double longitude[Ncity];
		double min;
		double deg;
		double PI=3.141592;
		for (int i=0;i<Ncity;i++){
			deg=int(x[i]);
			min=x[i]-deg;
			latitude[i]=PI * (deg + 5.0 * min / 3.0 ) / 180.0;
			deg=int(y[i]);
			min=y[i]-deg;
			longitude[i]=PI * (deg + 5.0 * min / 3.0 ) / 180.0;
		}
		for (int i=0;i<Ncity;i++)
			for (int j=0;j<Ncity;j++){
				q1 = cos( longitude[i] - longitude[j] );
				q2 = cos( latitude[i] - latitude[j] );
				q3 = cos( latitude[i] + latitude[j] );
				fEdgeDis[i][j] = (int) ( RRR * acos( 0.5*((1.0+q1)*q2 - (1.0-q1)*q3) ) + 1.0);
			}
	}


	int ci, j1, j2, j3;
	int cityNum = 0;
	double minDis;
	//int minDis;
	for( ci = 0; ci < Ncity; ++ci ){      // find the neareat nodes for all nodes
		for( j3 = 0; j3 < Ncity; ++j3 ) checkedN[ j3 ] = 0;
		checkedN[ ci ] = 1;
		fNearCity[ ci ][ 0 ] = ci;
		for( j1 = 1; j1 <= fNearNumMax; ++j1 ) {
			minDis = 100000000;
			for( j2 = 0; j2 < Ncity; ++j2 ){
				if( fEdgeDis[ ci ][ j2 ] <= minDis && checkedN[ j2 ] == 0 ){
					cityNum = j2;
					minDis = fEdgeDis[ ci ][ j2 ];
				}
			}
			fNearCity[ ci ][ j1 ] = cityNum;
			checkedN[ cityNum ] = 1;
		}
	}
	delete [] checkedN;
}

void TEvaluator::doIt( TIndi& indi ){
	double d = 0;
	//int d = 0;
	for( int i = 0; i < Ncity; ++i ) d += fEdgeDis[ i ][ indi.fLink[i][0] ] + fEdgeDis[ i ][ indi.fLink[i][1] ];
	indi.fEvaluationValue = d/2;
}

void TEvaluator::writeTo( int * given_sol, TIndi& indi ){
	int *Array=new int[Ncity];
	int curr=0, st=0, count=0, pre=-1, next;
	while( 1 ){
		Array[ count++ ] = curr + 1;
		if( count > Ncity ){
			printf( "Invalid\n" );
			return;
		}
		if( indi.fLink[ curr ][ 0 ] == pre ) next = indi.fLink[ curr ][ 1 ];
		else next = indi.fLink[ curr ][ 0 ];

		pre = curr;
		curr = next;
		if( curr == st ) break;
	}
	if( this->checkValid( Array, indi.fEvaluationValue ) == false )
		printf( "Individual is invalid \n" );
	for( int i = 0; i < indi.fN; ++i )
		given_sol[i]=Array[i];
	delete [] Array;
}

bool TEvaluator::checkValid( int* array, double value ){
	int *check=new int[Ncity];
	for( int i = 0; i < Ncity; ++i ) check[ i ] = 0;
	for( int i = 0; i < Ncity; ++i ) ++check[ array[ i ]-1 ];
	for( int i = 0; i < Ncity; ++i )
		if( check[ i ] != 1 ) return false;
	double distance = 0;
	for( int i = 0; i < Ncity-1; ++i )
		distance += fEdgeDis[ array[ i ]-1 ][ array[ i+1 ]-1 ];

	distance += fEdgeDis[ array[ Ncity-1 ]-1 ][ array[ 0 ]-1 ];

	delete [] check;
	if( abs(distance - value)>1.0e-7 ) return false;
	//if( distance != value ) return false;
	return true;
}


The file evaluator.h contains:
/*
 * evaluator.h
 *   created on: April 24, 2013
 * last updated: June 13, 2013
 *       author: liushujia
 */

#ifndef __EVALUATOR__
#define __EVALUATOR__

#ifndef __INDI__
#include "indi.h"
#endif

#include <string.h>
#include <assert.h>

class TEvaluator{
public:
	TEvaluator();
	~TEvaluator();
	void setInstance(int count,int graph_type);		// è®¾ç½®å�˜é‡�
	void setInstance1( int * given_sol,int count,double *x_coor,double *y_coor);		// è®¾ç½®å�˜é‡�
	//void setInstance( char filename[] );		// è®¾ç½®å�˜é‡�
	void doIt( TIndi& indi );					// è®¾ç½®indi.fEvaluationValue
	void writeTo( int * given_sol, TIndi& indi );		// è¾“å‡ºTSPè·¯å¾„
	bool checkValid( int* array, double value );	// æ£€æŸ¥TSPè·¯å¾„å�ˆæ³•æ€§

	int fNearNumMax;	// è¿‘é‚»ç‚¹æ•°ç›®çš„æœ€å¤§å€¼
	int **fNearCity;	// NearCity[i][k]è¡¨ç¤ºè·�ç¦»iæœ€è¿‘çš„ç¬¬kä¸ªåŸŽå¸‚
	double **fEdgeDis;		// EdgeDis[i][j]è¡¨ç¤ºåŸŽå¸‚iåˆ°jçš„è·�ç¦»
	int Ncity;			// åŸŽå¸‚æ•°ç›®
	int totalCity;
	double *x;			// x[i]è¡¨ç¤ºç¬¬iä¸ªåŸŽå¸‚çš„xå��æ ‡
	double *y;			// y[i]è¡¨ç¤ºç¬¬iä¸ªåŸŽå¸‚çš„yå��æ ‡

	int graph_t;
//	int *Array;			// æœ€ä¼˜è§£çš„èŠ‚ç‚¹æ ‡å�·
};

#endif

The file HSNR.rar contains:
Rar! ϐs         _t . $  ^  ֒DXQ3     Individual.cppՁt8=i3PF{M5#yaӘ٠Aݍd<N83~YRVvfy<EғRI }IC?bzfLh%͸Si c),x+@`=_[{af-V*u Ws/kyޚiXV`x	yui7|[
΅8fqG\sY%S{znrFXMA|/P+QGU?eW7exa}SKd[ƵX@DCt ,      3'DXQ3     Individual.h	|Bqe+
Ro]hJ	&vn()Rtźg/XS_

4sRoznԄ<.b--iie.RzЎ3S{9R\kbϡy9li[n0@뉎`zv
Htr5wSY7  ԑ/]v<,d?>ua,]73ÜB(QDwzt .     ܸDXQ3     initialsol.cpp['͔}QIJ(F6mImڈFgDDA'syfsH8= bP=aܹH7 @8FXA΄3Hq@=ڒu07D'lcMP(>-.ƝR	Q
#4>aAusl70l{y~Ni*J2JrJm!zZDpvKؚ6ejCpGH3uLv1- [`LJƎ]mE둪bI0x+-bt`x6TRT#SY:q/	fc43"5}VN:ihbK{P5ć.SjZΤIvd_M/vJtX,Ԭ]>Nvh2]02wpxW^1iYO67QQnvB~qIo DRݹg9N0u-q~|¨yW>&J"QZ3
i79zU4SQF\bwHһ(6}H#@9HN}[`bґFƏy9+DBu[8[XKh5ag`⢄W8m[V@Eq=g;:M31/SR/,5̑!:?^_ŝ|lǾf,]emԱ@oj*_c+"D8/dYhn&[~)Bn?gȕHO<ڒ>Lv'S/IL"-+>ͧg.~[t</9aFu70;{AI/Yz4nuѧm@͸t ,      >DXQ3     initialsol.h	PՁu|Wl]Lj[BQ@ĠT-B~NP_Z9ӽάΜfmG8F	RZSRh @bٌ%׹䦺W7B٭go6M
:(x)%bL#|'`')߁'uA
U|(CSKRpא 4_P-W"~U@Hx=4Wa--;-$5ߤs]t (   xJ  ejMDXQ3     kopt.cpp<ٽ@߃^ym$W\ۺ/ltY;}/aԑoco]}n'6W1wz4J+y|(JXP(Q')f="ɖo%O
L~Xsan{zYϗɏ ɘŇ<p0=͏ w._kwgqxxd-csrON-i*OJl^wmj%՝EO0yXÈwز_2~V_ȖJ	%$Hr	lf( DJfD,siKF.%#Юض
(jH仕%=HX{7ҿŅyP|ٯCpڲ)
W	B1OөNb۸XnPS@)d'p / `eT!a-!@FmW;ӓ-T[\C9is [-$;^L8"KǗ<K%k{T{&ajcKs0;ዬu>+Z:_Ѱk@&:aooeTDo&wXW>?U,͈&;< Vԏnͷ^/}0!k)<e2`K(3"5nJ"yn5ƛ͠^&2)`2%`	*-vWK(чQP(n9F41{UN
&#4xX8xЊFr-]o]
>e!ҚY,tac棨PK֞f	/1q+W9>TψFHՋr~ں75nlp,tُmlwTh
2rιCZ<FL}ħq~,(YKDl1Q@4DM\&IC&|B7Bg,ޛLzqoZ.K4	Lr/62!2IjQح&%wJH	/t3aVM*ҴZԄU #dm.e0w<Oz[V쨫g&(X#a6;Kz=?d,[tJZu+cɀGۋwjEH俤b3mTEEA U>IE_3-b[(~.>A0-ѝzGJ?b U^/J߆|	P_P9:ᾤ"Vr_KT *$7փi`KjicJpqK^ʛUf5'C#+*C{r7B2ք.&Eu#lt2a)w8CO??}$	i1zr<d&C;cx\?*(]?!Wzy0pHXfÅ2XqTҌl]R\;5A+*G3S#@6yG <YNQ7tH.¢L>ԟZ#%1hc^RmLxRa:贂yo> +>aD2ȕUS.f܇أM ZB#vC؊M/E6`#h#S)E1e9FK.b>
z.wD7#/#:g*vM`!E-Lqr\Hͅӓͩ(iFN0+#{\Ts+wOh4C&yOm#dnx3QN*&1m/"Ar8J^0զ2xpA\%ZR\z_Y-MYY_C$X(DթPхT;قC'oD.J
3I+A+rh(IL`KڻYhDLJ]wm
w02D!Vr6IV<*[+YZ5+뫿@w{:e9`R3l"`EJSW@+R\"vꢼC4Iۯm=JAAH%4^	TxW"b
D_ƊPڡ+BSp	-;|$4%@\нhjjU6>1Ey\֣3bA(.KL1JB\MhxqLO۪RvQ.4Aa`K]Cr4oAsmrR2YxEak5b>jjDl3HtC4N $ 1@% (@
AT2~
iH=Ċ#ťA=vEb̻~6BłQ!A[C(4OƙK+YjB朅Ǌ<F|b~5g'P\0We)jmA\⤩9Ã|-j<=[keQ70=@{]/aICbH|eCZgDÝx" of~
poFo}΍BIv	C@%ރkL.[Cڂb[xLpUhzY.-$)cGҪs7ԧfs+@8l9!PƜ!$yx~(&a3B-y.n/p2ocmU,ƈg,o0>e1.d u&QC(^1  &.1Q%CL`D>G@w~(>iW],!eXAS[xg,(s cf1F${}k9`*ĉŠ<4+ܚQt;pThvbzjG 늲ygvc{^d}Z#MtHX@z7lΠ6q|"LXPXS=MM-f?J5{{@;W/#0|4jRbCD(,f /HQ.yh2Nw`5kE8bද3&ʛSõl|'ݡݧ6=4G{Exrh 
n/^q=6|`O1L*R4}Zr5C9R7EpiCF*ǐz>f_h0eG0NR  Ȳn z˱k {ق]16QXs+(=(
eY* c[FSQ6)ŁG1L&mZq֝w6<Ir~ni©^;t|F+!5V^eKDN;ص2rTh"XiۀyՏCb]_KasLݡp q
K0~]aD_@vfu:gƂ^&UQq͖ӠvZVo^&LO)+N:F#n8wIQj͵~`m=W_
5Л-fF&jȢnOȓ=TMˈ	d85Uh;`d$0dR`=1ԩt &     ]DXQ3     kopt.h!̣<بC	BH|8.|h B<	!%A'<B	ֶ呹Qsnfno7w7{Y7x*=OTEpב^MXEA
㕁j0"FcAm
	|1LoQ],FUT
͟m TVH^[.bQ1hpQH,C0z
	:i֯>/4CGJ/m@F{[Yt:*~ Wczύ	: IO]x܋!G"*3}"Jd	3tPCY#Hha)Rk.oO㓗ϛ-^p2B^юlwB>\ENr~Qѹ޴6ve%VV!SПWA
oKafn*v	o|UbvmEȥ͘Xtl>L:;Ń1縜9<}7&OkSr&x>MlenlYZeIy>r#S$,Hʹ/e"dEjꙜ v
bdLWucvVH|s9%5[2*%Vbcs<6p'zy߽tt +   w  &mQ3     LS.cpp {S][@3fiDnstD	7fhBi[M%g'CƚYu}Uvl)ǒsn9>%_
躻D	={~yQft/ٞg'֟fM}k{xKM=2=)?;Z%՟ۛ6yڶjt}ͼ~_ߗ]ӧC\nOL}? 1-巿=k.M׀ї[l]iie˼Vo]z}'7$kc||aoqm}Gwc6FCn<.DDѶlcǋ|Qg}_dOC0V@Xo _|v %LzԔ)֞JޤH) q7L8߿}ҝD
~YcdέN6Itw<\w1=eѰݧ	W}'@F7a`L
>%ŜHP?rG)5cʽ!=dayA|
$ا6Swj<?=<zda,^pi7%5+@F. RW\8;:y8>
|qtW( -Fݚ^/Iٲi2/v.+'˷4=Dk0{$S2@>3 q0]F!UH_Bq5*#iϟ'9:}!LLy|K/n?ׁ;>a23p{P{}إ1ύHzC=M2<	T>\ ˫rhʂk-v{9SKGϧ>QbؐfpOExLO1(3gVlPa]B"Dh}o'{OGgFNs>+6oleDnrW`\{<z >s#$8;It$^9YN.euRՊGP8*dBvC9j\Y& Nh!+1ҮӌK2!qfq,$p(o Wɰ>(BYpB9H#mL0й=̿C Rjan1zB7 :KRKq\!2BLg@+!}+b)*",xcӐ4,&"B<TtRzòSY	+=F $ca"ǀ "Y5-2lnU?=p'@oR?PӦF7ڰHXau)}	4xQMN%Hղ@jg\M^aIVv\Od( ASE&	FB"G B/
HfE&5:qq(mt8?A!2R`qO	h[Ie,&_;A6 ]^bħn9NSho;@H4_D-]%퉭6Ko2e2bR pq-wuîU-BlQww@	K3FȻs6RswH%*]/ $*d;;Rx_Q˿40G"9q`΍y~/QBcoܙ4IP[,V+PF6	BJb4ʈY@xjW\G3LA[@@;
>=Y947C1a	߆u)鮞\
ۙuFAi=_.uĵhk#?(~ᛚO&=),~0O)X fM"s705I]ʤ6>EE;k`%j** &1s=~Q\~?/O?ncRRvuJ).ڇaA[NX~bPb.ooTK칷U5<M㑛߫ qf2p"
,BXщԎW8Kf(_d(VOA|(fj P(13[ia;vȫK@Z06(+$B VkAv}y+qC+[=Ajqg^#b./M˓#ȫŗ܋N4߂owo&&E\D1ѣT!JښR4TR'E)K;0к 5MGt!U537q}̝21H|ݚveNE{Alsx<?)Ogͧ+ODtSqK&R=	$~na|o)'tp.22l]x/`k^n[Oxث]Ĥ2iݼI\pVİK>/gݗ1+܃:4oF*׍B]yR9pWcg*9
`:hʊ29T~(r^WG5jX%rS.<;i!2>1b oh/;U'`?
-L-%y2()vt6x0mK6~txZ0|gYx?1,1gBTK:n%تs	DUKIE	Y!D5c4|EQObEON=5L{SWE0:01]zB몑cw"<0KsBOaH[#i`2)%[E!l5s{p?iPz$H-Q[Yˡ&qЦvKy;E.~JV9Rt#NNVd⓹Tjrco}?nCjY`9xe	uB.il1vy3844<Pd[aiIɗ^ع#P+橌uTo63F<fxye_SDV4?W&=NxYʤj\P`P&Δ747-	Rf1B{}~"4<m!NzIjt#q)!	jdtӳO!}& 9E))#]2asҵe!t:lSsHbt(TW;jFm~.TT:KK۝<̺^f-$N^>v|+ں  f1|  ,@G W*L;.!(k K^V3CeZfk%_3]U4ք>yWŁP<(`tI޹D
Q`Үg꿞N=q0#Ȑ4oRIi̹m&݅>I@@GAXU=aae Z%@ s{8ּ&ͼTOQbR+?wYk6|M%ېnR;S-mJ vM]%>PWahI@
[m^SƤ?w0o8)#q?d.ENMLV|::VPykjkRb?$|g
nC#=K.w1H`pʣh~PWb&,L$xyN硜[JcHRفki"R]sk;XkvZmao7WjWOW?xq:%ΓS
.8cjkK!NÞ0̆VBKbqcn31&!Gʨrdkmt^58{בNj5μ*|d~-Q왊Q?-7CL_VPR{lt<2y;D7ѓYfkEQ2Z4v."07er[U_ǋI]e&$ZnˌG1N/Q?wnJ]!
4i)Z+~%`D M͕׼V/WAfٴui۟œmxE,
]JfE^C3:K>9~x 5d6T=(dKWq! S鞟!2MxI>^%yz;cӈ{?j1h%KBPױ&sƨ҂C2		p#9,I]TU2dLsqW||,J2j~<NUr1uݣ)4ՅUEֵն/W6S>;TGSφJKZ=3uKs`!q0~:kH.0O3B2hFŇ	1+v<VhRyYcj8HȀjάtí]  K!ř*q443?.]ECQ	N	)9eW!|JqL%<))/vC7
p-ׁnk[7jyb}<'P.*쑜s0T)\ej|佲""'@_tunϦ'a@y_cY6MK&wGɯYs	Ml@z^YĈHs<JxW3|J\IM-0kyPC`4m1 ydL~PI\.x/Yz2wD]½I?t|JO6Te/m`4F9n`;Pɩr)v8^.~f]P[Fv-JM	PL-VBZUE;05WrLr$,hVxSd
5
[JsqTH0%n]FQmP
HhUW|Հ4E%\|AɢI{it[kUeXBTɕSklS|lɃ'mFJL~L/!<wRQw|δŅ> ۸k U&ޣ=6s	}bFN	?5S",Z UuUɗ:,ⷿ:j;<pD`ۊ:Is%X6~zM>p}׽<#
n,SWhv+	s<^vt $   #  8DXQ3     LS.h [`7I98m`6]\]l3XۄMݭcHʗ %)"aU?clc5;0ǯL_J3ZѢg<f+no>dc쐯u'3˟1 Yyr]4i@4,E'rA\o<dXunXCf:g Fc4Mdm$ Аn͡oKc=
>PK8 APM@ ~a݌R<??37gns>LH'd913ʃҌ1{ݳyL(& pi˔ Ymky'vDʹË5;Ͳmg 8Sxs$l$}Z$d8amvN xjsD⏇4 G38&g|Ӹuj(R),я#Ws)w;py5䙿G@ Dِ:7b7ܻrxr1n҆Nx5Oh^^_v3dQ2~.Zml_&u!f'F0/AEzYs~H7Kd`j8eOn([yXDdfK#4:g0wҔDAClC3D
9(I8-|nsN@IPh5(Luz6n
{3xg ġMȕ{LӰe{W*!<h)AIGq>HIi9Ifo^bL8M=O%DvAӳ* N~:#L{Dj՞БΒNML'RYQN#Y
F^
pqՃ~{*ڼ`1,MI⬬;ٌd T0|q҉oGnrOpҠl)6M\d:c5G6= T%ނçHrXNKT:VR:czq|7s^b5x`YZY6ْV޶t^ˎ""@FL#Oz*@Ĩ/x`R1ߌyxV&!'uUv>yIao|\(1!s[=/
T@TWV$js[H7E
j`RB1	)!M\r"umCd(
؉@;d-UEYĢǵr]F~Iiqsq;6}ת=FW!f`xXlqZV=!2H^ܹ_M'\Sꍉ_ҡޮ
m/cfh6&V	3] 6?yLi<Oظ
=Wy=J-+A%*ńtKb {˄eq3Y.vPutIhz%)nє;l(ow3q:QO_;p	H>KҬ:W
sKu]z(/="Rމ^TURҙ}udkj8O?gm2[+&
nA֚MqnV#iĘiϘ^ע+x'وX~$5Z3k7>Qs|i;umZMQ)m )Q.%G4
1$b"KZ  4R4k8[M[YOʌ_}n_+r{-V]:E8Tv6ޛo=q"~8 0xK?ǃ'6}XKv,GP
&[{Cߙbװq55t (     . DXQ3     main.cppͽ>px%k5ށQ+K0r8'Ѷ%mu7k
E2KKKMSI?`	`l$v}1vYkA,эǚGj+tR"t7L]B4ADdt	"٫D,NxI6
LOQHG\RG]qRr6Lk;[WC-W+u#);1LwYiIdoamoM?Ǉ˃1 Cb\{z){e?H=0Ж%~_V$ T 2ZPO[!Ib51'*fNqL&T9ŐL)
"f&.<&LtI)Wzk(籭tt (     {`_DXQ3     Makefile}7UP,7t{&+Siި$m܎-CD8</?#4|x>fLeh$:30YOd+.*PS)6èiE)${9.'A&R4IU
*U!'uS*&T]_p4UJH#YSazk2 8F(Q󶝺rzvӶr~/o{[o/8lC ٟe <><I.JXZmU@`kV8͜>U'eӤKoμ[/gC؄w!HL_{:ֺ/t +   0  DXQ3     perturb.cpp̑[5-;ҫL6%U;Rox$fIQ~UfIUR9|c_~&WOsXZd'c_s7EbiD6Nh"|FqBxqqPc[S;;}j#6a]eA_҂X61f'I/gs4Dϓ-h[eg<v	2NS݋@ ZLXQA\&!<c(Ѐ1k7o	PICăLxgybx؁e&8J;zo}|7&x&=T?o@孲h!}Yzfi\%KWgݐAx_/kLaYJv
0Y?WZCrvbP_hPyw%0&[h(͓%'7Luk@0ri+%H}՗ػ0CR6@XnS8a-GV߲&SYsJ6Jh!:LTBYΏ[E8@ToF5H9qKtU=%Iv~gEt;45i2h FZO4,()OlaxջTڝ:5(%' 3%<*jhxFkUXts@\q@W [AԩݞӪ)5@pzyK+o9V)s0^>(Vn:uptj}S*SU5 fbs8=zk%HLxiETs0ќ'b:8Jus/gZr .<ܱvTisV,N$1kwc~2P)$^·lwx欔' U0I蝪=zj8%Vnsg<|1%oBpQ7: &Vl$mk]S9( ^]sXKȋf5lꩦ_ۺc&-}2x Ɯ6m@hk/GhPu20Mk^m[t0[]~\4a1|IKh|eAJ>F!t ) H  A  cRDXQ3	     perturb.h$x>xDH!T7
unBvlbȏۻߏ7qzg-hBs-\9Ś68X?*:Sj>O2Ji'no,d @tT/uQ˜gϤlh|nu)".=cA{ \|rN$6<.Qe}A7-IZq,:դ[d58iPX*2#p~)~nR߀*8?LTۖxFq:\bV54<^7t -   _  "DXQ3     randomize.cppQJiPTd	EHI{	"ڡCn7QЭS79f5s߹G.%K@ہ}ñ6cY-A:Wh:QL͔qy<<C:)"&Q2Y{:XǘqBP_쓘5#kphav7#._.%'M_xMsCLQK&.2PXqck	fqʓQbJ"YYZҺ5'_P9jFmtA\VXl}I-Xhlls?z{56-g~10"duku^M[:UF>v|U.xh[yi#f1@ԙg}}F~8Bx3K {3Fpo_^r*;<l5T@Ş&8!G-˽fT4Leީ,)PKSLɤ!~FxFhh8~./YL*:^XiGa@iil#0:us]Q&><['H8kϗ	;Oka]}շ (>
$B#W@o#lBޫL>UfC7vF]1A+%%	K#O-Ϗp9/%V޻=f	Z*"s.Oӊiw _fo>+ml෯t +   p  v!DXQ3     randomize.h{h#0BQ-8%vcɌY1<lPG	D@(Hŧ瀞
"f,>/.Z뫪vn녫fqC b<(a8I7O|1+rͫNg,x?`aU'yvD5uttФ2
^6t+cc`Xفpf^@va=2ښkq
m90udB#ఆ\%ʥL+Fu}PiPuKgrgPUrf(Ä$ǭQXr*ŧLTM2?%r]UXz'ğƚ>~M;Hɷ>7x;L;X#nRT{U=G~ILNu!S|T<P|cԞ|>4%G.EQ~2SC.x%;o^u!t - 
  )  B MDXQ3     read_data.cpp{ 5Mbe7:4	 @@)	ZK\h4uU|쒋y33hU5ݕApUF=87}6w⿛0 ihfh,=(!Fͼ'WHӼ~w 8 ddG$q|zV,Ra qr9<6DNCs^7=6Az"_Pi/̶
a7j"`Ճ혖T|1CFcz=Q蓥PeѰȮ|XdWH((ẗdHnߊ9(-(0ib؜>C?`1_fy71+\-^1ȣŭi
uk:N24xέ޽M6wY:7NtLXJK8œ,N2hf&l"~CJK|R$/6)hN?>d0I_OS[M4mT`Ra{?2NWsx4'=
k7T)03"(} %ŎH)S<3m4+cQtՂem.A6ͼҖ94]7x[̯FWERA^\_x-M[wnd74DjL%[;<|lugT|?Oұ{㗮3`&ĬƔYqK@O&~`gұk))9v9t@/5pWiCDƀݳ?_$7j|D,%ۗ3(Sl~hJ[&Sګi
䳍foW%yi[2bN1P?7a[->=QsǤ3g 񂋍+.5v^c0's:M:1@5S6c|9KLVK%l=(zL-_K 9T/d/:rwery)$h?iZ==7?&pxf[m`O_"~PCRFv}6!ʤ[,qTN3սsIUmwK;"9D!g,8ʪ0^ufrNU}TjWI8^iʨaq\hjeU,&oJIuOkT1c`|M?oS{Mg B̈eee4Lϖa%yrdM_'rֹ-g"׎KH'-BvhKhB=EO2Hsa5{"xy8pOKڜQY#deiˁ="tL#-rro"H
cUe"{+f1=~yrEtz=%{
'\?m6j<lT6$BjȭM^THy{3Rdp
Ik%pKGk8:?eoҙfi2a=iuMܾ/ddўz&⼀wۓ؍b: >78lNM;h)ܫOdpB	86 cd1p]cb3%<0E-OZG?'[@Cr{pz7H'A73Z5wsy\xJц+>姬ѿ#03Y6Ѻ6EZ^Зۮ\o30<\gRBHյ31ݸ0s"~ %9OQW;Vc="i{h/'"Xm%	Ձ#	h=Y|Q ͔|u+,6*SmEbBϷTl㦙]Ngv[g1ԅT0[c8|9J1CiIULn&.!E EHyǖ&9gHwfNݿ9uW4tqsNyB[;͆r*N,x;@iij]/"+V,T/5*gTds\.1>}}Bx.b^E}	3ptTS]Aj +$B6ZI!>h:CcPu>9hv iFW+%
=|fgLDLDjߕ4AY6pKᰰx7Z0P+Ud/V^3b!^;kIj^:,%(D,1s~QK4\$_~_ڔ[dLU"`~JURxf'&X$YF4	s5ʁD03Pox]T,)8X<c\r9Ff-G3.LT>C,.KM=$A(&"Ehz` DISRH)[  մ~uo,BtHk(>ҔTo;CP:vfT*=b%H:Awe"_05g~s0,^O2aZ~hq08a7?=9!"#w {JE<LG
fyTߝ7p>+87'\ݽ^a 2&z{[X6Ep0A6f{hZgO@4t +   "  ¸DXQ3     read_data.hLwJt%#LLAciVө'`cFL<t]Ctqz(s?//G4Rz{c!OA=hDX4[&J>GPO2%COGIzt}t^"'Z$Ӹ>"^:LFjY%?;J=hw'.pI^H8=ĵV]s^fu[}MlolxmY"[Ի<Jy/ldw <M$gӰ/c(5p&ؾpbD.1Qin;	а(3u8Ǚ:Æl47,)>w˴L@cf}r?jh0k\,5*θ!Յ&J{RV1hW:c
2/z@]bZ*j;x߂4uZkd$s{L0FB-u4BG&"3~r? gY@bN=ں1D>wl2~F?!`/*s0kKj{r-4^CМZtov=M>}H˹numn:oiD(7PIFsԕ?$͏;5K-17.Z$iFCÇғ4]it * N   Q   HDXQ3
     readme.txt	XҒ QmMR6C|?;*b0I}Q\ѼT|4Cyt ,     N>
DXQ3     solution.cppM͝W;ܛ"mP }6[`P ښH/ɻ2s$z$8pa9<d?s9-&"}#q@d焬V+Nh!'g暙߇+م*GN[e%܌\YmaUAmVc!.C::<)$9;'"|o_'W7VWx	z˘VXsd[C)jtlB_O@.a/5"ـO-Q<*{d,@¢ο"voiS'&td"o5`֦[3N2=&4&T÷8yLcuiM;ehcEiF؟iZW{CSfF܈b1F܄5c/Lx:K4:YnI
' R皽M=uVMCwfYk/a-J$;>W%ᫎ/ǅKd)p_g[[P)NTb4<E2M# :pĕ6Vak<β r.mo뎮t3ʅhM)2S\@}AIxi(ma(P<y?KkɤpphX ZD.Z?{mUEc09EqH_	*f7auM&J2:1ՏUhFnd|p~,Q/*tXl$u	j6Qbٖ+%$Jw~w	^bBpKu? L%_ U 0rN
uJcjZZu.TnWJ@m.m/PJ:g(Ң\(EQf=$`yMLᕸA7\'-T4XY43FMw4qJ݌ֶ!) |%`tE׾gT_¸oOY%DU4ٜ.Kg
a'4,
8S*,!EAm(2<gRx4IL:Y}EQءܗ #ץS^JpzuEk,~mp9ح3_oո]h-hUNb܉)6CY(G֕؊]e3T%٭6kյ(%hjS<A"Hۑ	7D{ #~}cչ/ؚvDn@B%Xkjn绁(YoLJV[ّe3gy;*t9zP}#ɫ>cЛt * :    	DYDXQ3
     solution.h́:xυIxkQ@h( aԑXL$ݣEhKlm8Ri#d/0ߎ%$~`@gZ\G+BǑ<PFEs.g.K~4>i%u~nש&'!u~9, <=m<DGm:d}@#(itBN9T::+2J4
9XaxD?HBUx8%ѰCSE3y0Zei 3=%#&cfJT8M#2p]h 7o	g=Ӫj.VIގꦻ>])ÒF] Ch 	0b5]L߸'l>W{~ܽ*	$@Qm QE"lY8oQtc 37z7~zFYԷRmy\ݛBRv5۠d<0:5ZV/6{l-SpiPK))TmUs,1nMUl;]`bn`_Ǔ:rGdpA ^'x<z*)A>'ɪXY>;aFW/vX8hJ]R'̋<$[QkFoүs7V_=f6/0jkW%+eS&b& g!%2H.qzjǶBahĨ-qقaTd,^8Kjяu6y)2D$_x8CZKͬB)zWw~J֪ru%2u| t ( N    6DXQ3     sort.cppQAs)M!"AD(h&&ǘBqDI<&kP4MD$ڞ"xXlcx:?Jar.?uUB\V뤯LNLBVXj.Y*RTc(uY2bY7UP)mw`1Fڧks7Zk@W3MIKH:>F8+|Ʉ2M<$WxA'śP`¢Lk"LAY8+pXuݼytWOT8N-F%lrqd)fN	T\^$ҁUJJ 4<8rT%!=FH`'.lv	l²evy~*s:'c J$.Vd6TȬOQyOț{H06}ֵY߳v}85?{f0d(F{G6};MSg]հ<'Kd_7oy245)R @-$\8w^BN!L4c+)_B0OܷԺ$odkzYԠF|x˴e fX-`4Е4]>}Fy
*ІJgP`u$s>"w3(^ =3y}ɨedɋ>H9bs,vhXK-AHλعQ<=@؍pۓ@2	/hС	s=۪ A{WX/m _lɝXK?q1[t &     )cDXQ3     sort.h{:r9%98#Q"6R##	y	e; ;@a|q6%7n	g	zÃիW93NGἾ9oy@eZMT	2%pM60ma#uJF$1$J@
tQy2&C};#MbA N{+
V	ESAe8H+ebq@*iTĠ6G	i˕;"-p$Ĩc:F0\jd]s]ߧ:@Wzl+64`Hǖfu'Fub78Ӗ0[|t]sH㻋b#.\sg~spsV$>eg̗w6$Å`i[#3'ny@Qs>2VXe/ I`C)ߡE!3|Q(!J3%^P`t ,     DXQ3     Tstwoopt.cppM_HH(`Ao 05a~Idj"blԓdŉ&{hk{V`=$#ss~s?tkzā7c@k-ޟsiIx!=%z>}>3:o:Vu7pNl/$>ާbۓu2Үy(菋u>TђSj˱UB{5y=cȔi*{1k2wWyv8ZZ9{ѐ`fN1oKi>P=|d#bЌ{wz}rO6VyQb\ؾwýٶv;Nhwe_v:wV N5A;f,/A
pjĮ,Q)c݌8e=pFxCϼM]Th:Ѽ@s$	 $Bw;KjVf|+<1!Zޗv+)SXDlc J5m:ǔ37ğS^ZvJ'B(#ȥ/DWq#wZ&R%.TDDOvK0ZrЊ]ƅ-Jѵa AP	4,3zpγ~iOQ"sXVIi>|9 uKQ3ʝٓY!)6lBq.t3ȍyZ\V78~wr@YpoNƹמZen,jķXVmT0@,nB|B!,tƻ/ːXn3٪åF@`xF0A1YxKp=tao0RED'myQ#jrd}7ɡqb
# wN}GJDmq	<e& k33`)0v;QzDh%'[hF=&}Uc].,!wxB(x(Lv6E*o &<$+׏gq?h"VX`;+RLׂ[{H+MūQQ*_d~ZŷlS˭nB8kxe<ޟIbYb^BJB_nE̔D=eo+k	.$Ir<MbY8q}mUYv	u-_|n;buN&	vԸsov>x	Oڰwy+c46ٽaKa,jLV]U`R*FvT:_\-3ԞՓ%gy+'AN֭{Z^_o+7u9P#tcTiO@k"&'W8(	Us(\.-WA&n3b|}	K_KJb,獰223A/̽OAwħj.Zt * V    DXQ3
     Tstwoopt.hLɽw|$x;V.fk)Hj#4Qe-ȖU2L4=A-e2|}q4}m6.6r :iWDΙEzCP}6ԫcZBje)8~͜.v#~Lc`F-_RYd $g׬{J(O?ۋ;Y?SjdrN׭2]flDT`D*əcY/Qw+Z$ԷSD5ѰY}
j]Kgbͮ`.fRTԵmum vX+j<!~SnsNCg"?}lt '   L  !=DXQ3     basic.h	L_àt^ݍ6;$NGu]\KI>.$M3_ף>`ȃA덿w

D< {6wz8UnRc=<K7hw{bժHIhmXɈ-Dw5	-RM){
{"V	7!Q9 ].!ͯ|ϛ'=TjeJyIL%XT<&7֞daa-oz\U*!ҳSnzy(fўHCۈV<d|qb~ǚBx]rBޡ)~+i0`V*|ddl9-|DCZ:DзjGc~aH	$*:-<Rt㛎P5.ܸf-7j&46nE;Vp,?ΪslU^3Ä)mk]t )     &DXQ3	     cross.cppO][hrc1ڽYvG\7V<JX32gBAxI~	=''IyQw[IY4hi6nu h5_kKXcZÄ$l/Ê)#zl\y	-,_.\X1L\zQ]nppmq\1Ⱦ/,g.t`ur}|[^h@!}m_?Pn&] s_O6	"a/0	>{.!0?[J H`*L#*̖2=bRs
1'$7&dǕ9o^9vSZk鈛r\5"@7.fm`V%>V,2;n}}5bȌ/`jtwz5>9(}q_~M!{ ΂N
DW|!ӚSho̭pQ/m-Eݨ
`Aj)PF74`pRS3y<-[668B/ۖn|rP`*7F==Ϙ-|p޹ooj*N~w/L|-rG9]O濹vY7{ҡӡ}ݑdz,F/Iá* 8QG-F5!{zWߎCϥ@ri^i=	o"']COvpѝf훹<zij|FҒN4}ESpz}:',F9QϽ<r w]AnSU2N=Yps
rٔ|Ɯ<	J$Wɻ@P3~ojV0ie#BS}0/<b{l5$ag;9O!۝R>^痕1z̰쥨mg PC&\@[e¹N--םeHFye$U`*~>WQMge_LFa 5VOs?qlcȐA EABJ%*TӉ@nNVyc~w ͕0bJc-kI71͒+jttl<M j8Gǅb+0nCeM栗_PEX sW	]k^/@;Oxv<^l&Nr'q&X@eQLW=i=R<F_96 
+FabohOQ#[`, HzX:$]}OOYF5gC=ψ$sCذa^	gDQuT=13Ofy(,Ms7,\@#cGa{]FdSmR.< mnM uV|gH]G|MCz'㧘M84}yĘ5Yf]SQSMdMl&CɌoh.Io*-g4oocqM*kf:K2;Zy)8Ї &B(YT1boQ2V-	ţ8Q:N~xĶEDs;QZqS( UKGf5Vkiy]V0 C~'`juҋ9ɩfYC`{9j"XAT^t3Э`4	|Y/%QRv6satRDNM1(?N4Oc`qlsgF'nBe4h79F<A/D8h8:OprS%탇HzSe6E\)9$:_ޤdL0+l3Yu ׽!!qU-ĎUD2=M(
!%M,X]"-S;ݰ-'@$$jڏWLFFufg88\eed*
G:̶=8v}:/)OAZ-2Zp05-ICUϬ(۫lf|(rnXnc#u(kSά,3怸t6]h 9<f#.͎Ow}i7*+BBeGCc?+6;|ҚqlvDqHF8/s\jt[y!dϬ%g_ *4RYӮjð>j@}@oK/<尲3Y]xʊJqGJ_c*%RעٱUG+娔jy\Т/T@7BH$CugWbo%Ţ9tHȁy5󑘯Lnz~FbwpNŧT]Jc?S:gNq,_L)ir)RJG1$ibќ1h(&u~~NWF{ͫŏ,HpEU}vmRshz:ƨ̹j4zS<
-AF
w`vM7)hL&J5M`_EW"Go48OXCO6 
F)"ԤUOiÍ=pZD跆@l%kڼ=ϰMv-uu}t"K%Wfi8B0os#JFvi0OzvD%#}V@+i$yBؑB	 G5@)ndbnFYB3|lF@^+"/4&KD9W,)i=S+g>LSOZdv>)m,gvnǴ9bP?|"))'")sdgا3C)Vg^\;Jq'96ոh"U7Fce0[p~,>3mh@o萼EكeMA)T5-FmǿTV7C<wLo,vc-G&͏-Ip/ 1e;'0
"lWذ#\8TlM"\ Ѕ>6"FqZv#6+\\51ol.,%TA`S74xh'uj^\0\{k1'MwF̴ǆ;\eaJ%`L #! /v3x"qkt(uSW4DP:{r˓qazib_ghJr8ݚbLAvb	AT>w*5llzQE^oq;ü6ͅTs{Y-*D=s'Ԝݸڍ!XYP/ L.4>-{>e<ri@ʫ)s<tRSfIF;g`ؖ>	0.x#̳<4w;ZQy6n4ىr<I\U-K{(ޣavc*y/lxWD9{䟜Xk 	'}侵~qAH188b3Z	nIP)Of&X07(8-;dAHԃQhTY`&F;qr'Ts{z|S"ҿ608];R*4UpIWhaJ+ALvf(XEq6cКu2ⅱ#.c+uԢ]:
ܯR\b~Y @k6fDF|j#%^j	gݙ!NW&U't|l	koomQo"?UOb/dUVQ.3<RH^cC*<)C{Ij4D5A.)ڊ*ىIjBwYQYTZ5Gh."~,O+r=>IXЬVK7lm,rnIA o+]+.b+3EYJ5%+N5z
PBSF3Y(8l&6`+Fk~E*oJUV%!۪n2r}_Z(/nhF$y8.ƫ		

k,WzQ@ZD"m)+C̠Wm3iZhEO2Hnjui:dWÍ.l	AIm>ɝgv'M/6=>(@Ywbb(Yz䑄NQ $=]TEɘPz\j3sCTx}؟XDYhctNX3ui^yu>QŎ e?ŋO](wxzuĐٺ14XlnG[0-~Uf6AJ
XkYG#@tmU	 WgF*C1(ŋؽǑI..~,B5NN7|0-L;Pw?'6"UL7zEdB9Dsm,pzִXh`=6hfEz8V>poDroɓKttWC*(u3}340%!*?*͚?I-πܚ?HkKf}%|O@V7aGJe䝻Ɣ;t'4# g?ܴ>,N4Y`ɿ)qc(hMz@5W'jwB}$lOPxَ(n2x]7</2Y@</a	*%%d}QHjѳ2ҐahSvMzi:'a3k3FYJ8r͎o//*e/ǞKݯ?='~~k~*Ú>}Xb_?'|f4K&#K|W5 MЀIte|ZY5k~GonS	Ȅ6ayڣ<1YTv)O숧pKC89tfC	~(\?mJZ@z%PRgJZP[$uST%ؤrB"zΉ@MK(gQ$w5э؛ir%Pr?T1n({:4YP$tNx^BDP-FN^HQ>1o0SuJ"T^.o
&NU劍8jSz&~.	ر<ݝBhh?'fd({MR]d%.A=#"4G'Y,`*4G'r[`^ 1&^H0/<{`]vs~BBbyQ\>d᱖E9t'W@qkYwD\teጻ,2DO3y,ӱ;yJqnx*.<1ϸN%{yHґzH^xLN
-\WƲ5]*]Bڝ	RPє9tHQDW%kD='0t?y٨ĈD4i_Hm
ѕ#(k?1SѩJi.@%B2D,_SDZ+=B<t`%;[<]+c7]osgO*[ Q|Zb̊UR&-Fɪa-2.!>te|F+O`t}S[ܹ2́5YWmpݿ~R~lo6yu`	|t`f3CS6z&̗c,kd%<t";T|m[E3kdA40}cuUx??-̔{Mç0bJ1~A(7^=xgm]cU:۸9ӊkY-/H;4c&6i.k0[g=nN~T ӭOjHhުQ-{HiѭBzmѪԮ( +"%+LkЯoq\a#Y\?(/ #oèJ?%]gb;p_Y[Mzur$&<LH8,d0Ox b>GZ=04=槡
^7;ݼ}/ԁ5LVk>4~ֈ,MIO<Zx/!o	yݐ7B]Lt ' {    `DXQ3     cross.hAW'(JC1@)4v8'm,)$u:ݢNEN
	1\`$'C%E<<:JN[{=?%g{>pnpXz"4sk@"e"4Uqv>Gg&tZmQt|2D.i{_:<YKʤY=:#]?RgkQJ'MY_%:@&*A_Ӡ}͂:ȖvUsf	(LQtINV&pG#HU197kRHUtнbMo)X K.Rfwf*怟4h'/ڳ2vUm	uQ졑Cet+X ^&>:};~p|w<%Kgv¼ۄr <%ueҜUJ7V'=1wv⹰$[33cÔ){mN­=zb$})jӋ-pNYJ<tߒgCsGĩ]6kLN1Pa]vѬbnSl[hW;'DKᔅQjp.\$`.w~A'ZLYvwdawDԱU0dKޚQjtˇCz#]|8nV#{I_lZK!yq$FfN<M!zQ6Ucv(ac7u15'B)l _Yu?I#C_?֮_,a,dub<Ѧ;Ѽ^z$Еj+H=t*jcnQ;jnTOinTCם& QU[-`e4ǦZ|n?~9&vO099&OF)_-wcB4]׍Vl.zdT^^DBJMJr4XLBYufBE:NK~i1F)r7M,5_)\pkhhⶁz2Pq\/"Ya#3ddMpBVC9R`"溎3* ̎eKaW04Ǫ#գYk^b󶓚aM#$@٦rʳ3a![+qro)	G5XgL4_s%'PvM6fbGe
N8vʦ(U=
OU[)pnwpő&A"QHm?<4g;e!+TOJgRK紩0# ot ' 	    ͚DXQ3     EAX.cpp	Q{	;қ{P,+iBF9Ij쵓ZFO7RMd97ǳs?}c/gt`@']˟ÿ?ΏF#zBHSG~7גe4ǔ9SI*nohpRĞd.F?TXҲ]+3/,# 8DA.*OB~T4m_n<uaKptJ^M  QfB@XU!g.4J0ig%-)}hsi|b1P悥*{ϏuSzm+juZg	
W)XqUzs44f/Q׸Cb@rи%OEbi%"򏫎ln\wNX_UNzU_n
D\B_ڭ!f=xŀ~Rstͮ||pjU!dZ]R٦z\09~t %    (  
DXQ3     EAX.h	PՁ|	;D2nQ+!5֓mQ'qEtdӜa3{:txDːC·[EIH?iuخЊS,iBG6@*8d+Zke!a&5	tD^m汆?RTVEt𸍁\L' nhUt / 	  b  %	6DXQ3     environment.cpp!{>WDiCm@$z67,Z-a|KF,l{-n%ݻ% (=<-G\a%a)'&/\&s3?Lgs 90gNu~?Nq-mQK)mTVtYS%m6K>#ܴNvY^V.lѼr?uWUbViv}{ޭ:q&Q轌Ѿ+Suuypa;zCP)a&-_jj>עp/{J=F,C1ήy\?Q;cM[wό|XU9i R1x֪E W.ҵйocM09a?/zvِ4~GTXb,g7>}Itk+Ӷi}+t }M5sY,j1rB	=$źͧ5V+J*D"-KI1VXf5&٬\G.W7>%`|ȭ_N`U;}ed!p1MPgZZBcQ0aض6+7ʨ$zdfOozn5s4'>^3=p%|R&]bĞD1:K9՘恏l,@չe8Ix#wiypb"k쪣 ̧l*0]K]%}lt9951^?:FFp~(H(\+8%,iET.BګlTU,j~ÂLx)M|)ߟ$oNX}Gw~3cb!$IQLпFtEvB[pfHuƕ#!0=+[y.[?]lJ95MZϼ jRjXNSpp>H{İY*eJOc>]Ia~B/|)6+">{u9̯,7YTPNan :q,HքfAeFt<~D/L'T<Zh7;!2T&$Q:-:xVΪM=HA19t4,hX,yƉ2eɐƕ)I0^_gws$=;.ϸ)}KwNcτx<!N}~rYKj_t;f7\o_|wN5ho ߘxN@tUS-
M],|oEDt8陵H?.!hxԩ$I |_o488"f)dǋ	*E+.cQ{?_	jPf,"NB4QgM<#ɏ'QɬMAHۗ)PI6@?ehw7fw忂MbM2uiEelQv,5$J<P+Z*|üBƉ<HLc,ľݏ^Cjj<Bv(cS>d9D1&/5e /Eb|5(4uO!:o|BGp ~\Iŗ8)w|nK^89_	'(J9/~
P w<HSǁ}3~w|N*!2RmBoc~K7F-J_Kt*-F>hUjo9xo{第Z+pGh/[DE_?wCt7oc xlȃs=uOoM!ʩT2zcqt-#.+XLR->Yjnsfiб>CfދTi*\PR4lP|+8tݣ]^kmT?i*iLXe)#(;T7ًuV9d쓮|!ڥiǷ'v-gdK@FkY#a)y h~fZmą|!6M1hu]JݝmM}pّ "kZڰM1|2lnrz<P[EYȰ^P>wEj6 +mH37">ȻEfڬ"WK H[_nx/@Pt -   %  DXQ3     environment.h!J:\jUed$YPU5wzV_y!PGYztI	[pRJBH>
*q=73ws[٭PQ(<z999n_bs3:3̍PJi-b'3"PREtФ /E&4v0_.)ʭ`/&Z7Y9$/'/'յʷ@yJ3׸`[	'8yAuyE+A?/<̏+3ph[zqgBҤhOgZSqZ"ySۤ+eO5b9a<ԭmͳQ'@,X.VlWyiǓʦi
X}І3StW%gvEVoޯm0B5d(Ζ.#с?fsk5t7{ix*vq_j62o0}a)M
NE'A5k׎[	0c^<
8@IFl`d(wz=xZuN<ْv/lW~R4)Bh} VSr6N\˽W&뒛VX?B7pu
6g@.3*].T+'}I-vyYZ<0ԭ+<()Us&@/gt(0
zhWzȚM
xm҈5v R,w	TYRNZ%F&t/]WˆN^*l,K\`<u15**k`پ.PD q$i6X<OL[
8ppMI_[4c0c$n-/I,OA1warߦvׇmYkhSKs?C!|V~c~rqxs7`QpB`Љc@6vjNUTG6"3Xfe'<9hP؅3'Tjz|Lac	ˣ|GaL>Ԥjayzg^$I?>pSY5/*H ]/38_kbu<FPHOɕfjP#0j-z:aR?t!FOUIe<j.zcG2'G>7/{Kewcu]!La}2p,N_h$>0V%`ZeC^#B9Yn8fD|'CUUv˶#H14?M!vpdͅ,<	Bl(m@ F0 a?l_)3|i:sL3)sww]Bn}CvQD["		1FYbrpx_X<h])̫lMsɑlYjw|>2ҞxcjA5دp?RT;]24bKir`m>U<
Ok IIRl@C3`3G,``Zk&,vCgdۡQa&-^4~N;SQY|n\5i9j׵/B_!|o?t -     'DXQ3     evaluator.cppQ͝W0t	E&*;·CT,%JdB	}ڈSiQ9"KF7%^H|g3sywz}W]l;u@g'$%V4vոB'X!eɄd+T_e{[<64?x!r<<Oߥ3V=ԍ>'὞O媫bakn.+>;za [5 w/;h"cow5G-yNQM@֢j?;P8J@#.YuQ|OCi!_1g#Dhg! #^r^y~΂[`ºdB
;<$ūU%cOi|:f1+홳VT*EEϗj])\,/a.]>Khn4liޝBq±a-)edfZ7mHmtDXյor 2Cن74}BVg+!kGatPORT%T,4,GnG.GQԹ%T$|0'^fMjMhdFw0w#5zдeokC@8LRUINSj(eiZ̼WvYMLbtuMGfR:\@@?s׿s~tO"{雪<>x]bj(j@'	5YHa[ԀPZL?
˻I9=}}Gw2qFC[P
B
NFzAkQ [%#|Ta~Hq76IYR]԰.urF	Ν	CKP,YƞT&-ٓ\(]CLRK	:>yB!tQ|kĹE%ަHj+N\sbmfvub-z:~UR+2fv|<8%hRf0`ɯOh%<qkV9K7؁4"ps_Fjujs(=&(⤐_[>޻\^,;g6k(X
fٷkd#; xz/xV/nLI2@Bdi;ۭkSPw\DCJӱ4= ܖs/|>k-a<JЪ#Rhę(T4yi\r X'Qōl~#wu	!MUdƊťCڥH\[,+!eMWCI;Yd
~Š04\z0W'ʗUE3y֤CY/\'pcR3YT_dDʝm\u"d%jX!M ?%TФݒ|KV}uC5As=st +      NDXQ3     evaluator.h	Q́r`=C"F(HE1^5mcF,!!	d&$473gK2*Zm6W8|_WUzo|!IVev;tOx4ĺBM*/odODUT5+KO4TT։6܋ELj
|Y|~35Y32Y=s|ōt&Hw	C*b`nw3!em|!M}>Tχ*WDnՑUr&"̵JE|x呑P]A0:3ٯLp64iv\.=G>nZq9G%XQur:\E	zV"Ĵ;8]}b%攤O!E`jy!0	f#mN zd11ФtR(JPCddOm\n7c{8
_x-7PXyiyx.q@oo{roۛtͭc-_Or7-;Fk/8өg$[ld,nT	Ё/!
Yڤϱg+\ k	/J4@bu|=8ѾSF2St:l+J7MEiψ#P~:z*ew..JEn*zdYkZGJN.rf_,'t (     DXQ3     indi.cpp{JrܖF+oaTkPZRwݨ	Km(wRM$b|'spa^<$8G|I Gf_0xnAIÐ>1 ?Wr@i	"yA>B@6tL@i##q\}Bfت.&uyԪg&Es|l43ϝu5}Е岪"z e IӻZ'BҶ!V2qqU.]F)3F.\Z#+67-ީm,ʱ}aXcDL"!lxGx$hvPi+=ru(A	h+ޥ3m>f,yCDȈC
t:߃c7ym*PvqQ1bM`smv8#^2trpo]YI_3#bߗ;j^qr&s|ߏpwiG,kۧؿ}Tߔ-uTPWͬ/rjPft &   3  61VDXQ3     indi.h	{& AM!65''@'!d#VhMoqccpnspq!r~<x,ԱnԃS|luWYW=WyytUUƊe֧^lJADly__vORAsM	h0,pڏVS-|DhKi+WVĉ""L:4h{%(0\nrgdBH"dPb ج7-u{Z%SŻB;f+a;NAlWյ?.Se9<=YL05:6Lgh/%WE*K=;~{sQ=螟w~9v͐JhvÕ1q^~O'Xa@.гGɑ?6xO)Q88r,Qcǭpѡ#c1y26b)aM}m?"l=nOHS;[+=s@={ @ 
The file indi.cpp contains:
/*
 * indi.cpp
 *   created on: April 24, 2013
 * last updated: June 13, 2013
 *       author: liushujia
 */


#ifndef __INDI__
#include "indi.h"
#endif

TIndi::TIndi(){
	fN = 0;
	fLink = NULL;
	fEvaluationValue = 0;
}

TIndi::~TIndi(){
	for ( int i = 0; i < total_fN; ++i ) delete[] fLink[ i ];
	delete[] fLink;
}
void TIndi::define1( int N ){
	fN = N;
}
void TIndi::define( int N ){
	total_fN=N;
	fLink = new int* [ total_fN ];
	for( int i = 0; i < total_fN; ++i ) fLink[ i ] = new int [ 2 ];
}

TIndi& TIndi::operator = ( const TIndi& src ){
	fN = src.fN;
	for ( int i = 0; i < fN; ++i )
		for ( int j = 0; j < 2; ++j ) fLink[i][j] = src.fLink[i][j];
	fEvaluationValue = src.fEvaluationValue;
	return *this;
}

bool TIndi::operator == ( const TIndi& src ){
	int curr, next, pre, flag_identify;

	if( fN != src.fN ) return false;
	if( fEvaluationValue != src.fEvaluationValue ) return false;

	curr = 0;
	pre = -1;
	for( int i = 0; i < fN; ++i ){
		if( fLink[curr][0] == pre ) next = fLink[curr][1];
		else next = fLink[curr][0];

		if( src.fLink[curr][0] != next && src.fLink[curr][1] != next ) return false;
		pre = curr;
		curr = next;
	}
	return true;
}


The file indi.h contains:
/*
 * indi.h
 *   created on: April 24, 2013
 * last updated: June 13, 2013
 *       author: liushujia
 */

#ifndef __INDI__
#define __INDI__

#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>

class TIndi{
public:
	TIndi();
	~TIndi();
	void define1( int N );
	void define( int N );
	TIndi& operator = ( const TIndi& src );
	bool operator == (  const TIndi& indi2 );	// åˆ¤æ–­ä¸¤è·¯å¾„æ˜¯å�¦ç›¸å�Œ

	int total_fN;
	int fN;						// åŸŽå¸‚æ•°ç›®
	int** fLink;				// fLink[i][]è¡¨ç¤ºè·¯å¾„ä¸­içš„ä¸¤ä¸ªç›¸é‚»çš„åŸŽå¸‚     double linked list
	double fEvaluationValue;		// TSPè·¯å¾„é•¿åº¦
	//int fEvaluationValue;		// TSPè·¯å¾„é•¿åº¦
};

#endif

The file Individual.cpp contains:
/*
 * Indi.cpp
 *
 *  Created on: 18 Apr 2020
 *      Author: Peng
 */

#include "Individual.h"

Individual::Individual() {

}
Individual::~Individual() {
	for (int i=0;i<=v_num-1;i++)
	{
		delete [] sol[i];
		delete [] sol_r[i];
	}
	delete [] sol;
	delete [] sol_r;
	delete [] fit_tour;
}
void Individual::define(int number_nodes,int number_vehicles){
	num_v=number_nodes;
	v_num=number_vehicles;
	sol=new int *[v_num];
	sol_r=new int *[v_num];
	for (int i=0;i<=v_num-1;i++)
	{
		sol[i]=new int [num_v+1];
		sol_r[i]=new int [num_v+1];
	}
	fit_tour=new double [v_num];
}

The file Individual.h contains:
/*
 * Indi.h
 *
 *  Created on: 18 Apr 2020
 *      Author: Peng
 */

#ifndef INDIVIDUAL_H_
#define INDIVIDUAL_H_

class Individual {
public:
	Individual();
	virtual ~Individual();
	void define(int number_nodes,int number_vehicles);
	int ** sol;
	int ** sol_r;
	double * fit_tour;
	int num_v;
	int v_num;
	int num_s;
	double fitness;

};

#endif /* INDI_H_ */

The file initialsol.cpp contains:
/*
 * initialsol.cpp
 *
 *  Created on: 17 Apr 2020
 *      Author: Pengfei He
 */
#include "basic.h"
#include "initialsol.h"
initial_sol::initial_sol() {
}

initial_sol::~initial_sol() {
	//
}
void initial_sol::greedy_fun(){
	for (int i=0;i<=I_data->v_num-1;i++){
		for (int j=0;j<=I_data->num_v;j++)
			s->sol[i][j]=-1;
		s->sol[i][0]=0;
		s->fit_tour[i]=0;
	}
	vector <  int > node;
	for (int i=1;i<=I_data->num_v;i++)
		node.push_back(i);
	random_shuffle(node.begin(), node.end());
	for (int i=0;i<=I_data->v_num-1;i++){
		s->sol[i][0]=node[i];
		s->sol[i][node[i]]=0;
		s->fit_tour[i]+=2*I_data->Distance[0][node[i]];
	}
	int pointer,tem;
	int row,pos;double delta,delta_tem;
	int size_node=node.size();
	for (int i=I_data->v_num;i<=size_node-1;i++){
		delta=Max;
		row=0;
		for (int j=1;j<=I_data->v_num-1;j++)
			if (s->fit_tour[row]>s->fit_tour[j])
				row=j;
		pointer=0;
		while (1){
			delta_tem=I_data->Distance[node[i]][pointer]+I_data->Distance[node[i]][s->sol[row][pointer]]-
				I_data->Distance[pointer][s->sol[row][pointer]];
			if (delta>delta_tem){
				pos=pointer;
				delta=delta_tem;
			}
			pointer=s->sol[row][pointer];
			if (pointer==0)break;
		}
		tem=s->sol[row][pos];
		s->sol[row][pos]=node[i];
		s->sol[row][node[i]]=tem;
		s->fit_tour[row]+=delta;
	}
	s->fitness=0;
	for (int i=0;i<=I_data->v_num-1;i++){
		if (s->fitness<s->fit_tour[i])
			s->fitness=s->fit_tour[i];
	}
	// check the solution
	double check_fit=0;
	double fit_route;

	for (int i=0;i<=I_data->v_num-1;i++){
		pointer=0;
		fit_route=0;
		while(1){
			fit_route+=I_data->Distance[pointer][s->sol[i][pointer]];
			pointer=s->sol[i][pointer];
			if (pointer==0)break;
		}
		if (fit_route+1.0e-07> s->fit_tour[i] && fit_route-1.0e-07<s->fit_tour[i])
//			cout<<"  rignht "<<endl;
		if (check_fit<fit_route)
			check_fit=fit_route;
	}
	if (check_fit+1.0e-07> s->fitness && check_fit-1.0e-07<s->fitness)
		cout<<"the solution is right"<<endl;
	else
		cout<<"the initial solution is wrong"<<endl;

	int count=0;
	for (int i=0;i<=I_data->v_num-1;i++){
		pointer=0;
		while(1){
			pointer=s->sol[i][pointer];
			if (pointer>0)count++;
			else break;
		}
	}
	if (!(count==I_data->num_v)){
		cout<<"initial solution is wrong"<<endl;
		exit(0);
	}
}
void initial_sol::rand_fun(){
	for (int i=0;i<=I_data->v_num-1;i++){
		for (int j=0;j<=I_data->num_v;j++)
			s->sol[i][j]=-1;
		//s->sol[i][0]=0;
		s->fit_tour[i]=0;
	}
	vector <  int > node;
	for (int i=1;i<=I_data->num_v;i++)
		node.push_back(i);
	random_shuffle(node.begin(), node.end());
	int point[I_data->v_num];
	for (int i=0;i<=I_data->v_num-1;i++){
		s->sol[i][0]=node[i];
		point[i]=node[i];
		//s->sol[i][node[i]]=0;
	}
	int row;
	int size_node=node.size();
	for (int i=I_data->v_num;i<=size_node-1;i++){
		row=rand()%I_data->v_num;
		s->sol[row][point[row]]=node[i];
		point[row]=node[i];
	}
	int pointer;
	for (int i=0;i<=I_data->v_num-1;i++){
		s->sol[i][point[i]]=0;
		pointer=0;
		while(1){
			s->fit_tour[i]+=I_data->Distance[pointer][s->sol[i][pointer]];
			pointer=s->sol[i][pointer];
			if (pointer==0)break;
		}
	}
	s->fitness=0;
	for (int i=0;i<=I_data->v_num-1;i++){
		if (s->fitness<s->fit_tour[i])
			s->fitness=s->fit_tour[i];
	}
	// check the solution
	double check_fit=0;
	double fit_route;

	for (int i=0;i<=I_data->v_num-1;i++){
		pointer=0;
		fit_route=0;
		while(1){
			fit_route+=I_data->Distance[pointer][s->sol[i][pointer]];
			pointer=s->sol[i][pointer];
			if (pointer==0)break;
		}
		if (fit_route+1.0e-07> s->fit_tour[i] && fit_route-1.0e-07<s->fit_tour[i])
//			cout<<"  rignht "<<endl;
		if (check_fit<fit_route)
			check_fit=fit_route;
	}
	if (check_fit+1.0e-07> s->fitness && check_fit-1.0e-07<s->fitness)
		cout<<"the solution is right"<<endl;
	else
		cout<<"the initial solution is wrong"<<endl;

	int count=0;
	for (int i=0;i<=I_data->v_num-1;i++){
		pointer=0;
		while(1){
			pointer=s->sol[i][pointer];
			if (pointer>0)count++;
			else break;
		}
	}
	if (!(count==I_data->num_v)){
		cout<<"initial solution is wrong"<<endl;
		exit(0);
	}
}
void initial_sol::initilization(){
	if (I_data->num_v==199 || I_data->num_v==317 || I_data->num_v==531)
		rand_fun();
	else
		greedy_fun();
}

The file initialsol.h contains:
/*
 * initialsol.h
 *
 *  Created on: 17 Apr 2020
 *      Author: Peng
 */

#ifndef INITIALSOL_H_
#define INITIALSOL_H_
#include "read_data.h"
#include "Individual.h"
class initial_sol {
public:
	initial_sol();
	virtual ~initial_sol();
	void greedy_fun();
	Individual * s;
	read_data * I_data;
	void initilization();
	void rand_fun();


};

#endif /* INITIALSOL_H_ */

The file kopt.cpp contains:
/*
 * kopt.cpp
 *   created on: April 24, 2013
 * last updated: June 13, 2013
 *       author: liushujia
 */



#ifndef __KOPT__
#include "kopt.h"
#endif

TKopt::TKopt( int N ){
	total_fN = N;
	fLink = new int* [ total_fN ];
	for( int i = 0; i < total_fN; ++i ) fLink[ i ] = new int [ 2 ];

	fOrdCity = new int [ total_fN ];
	fOrdSeg = new int [ total_fN ];
	fSegCity = new int [ total_fN ];
	fOrient = new int [ total_fN ];
	fLinkSeg = new int* [ total_fN ];
	for( int i = 0; i < total_fN; ++i ) fLinkSeg[ i ] = new int [ 2 ];

	fSizeSeg = new int [ total_fN ];
	fCitySeg = new int* [ total_fN ];
	for( int i = 0; i < total_fN; ++i ) fCitySeg[ i ] = new int [ 2 ];

	fT = new int [ 5 ];
	fActiveV = new int [ total_fN ];
	fInvNearList = new int* [ total_fN ];
	for( int i = 0; i < total_fN; ++i ) fInvNearList[ i ] = new int [ 500 ];

	fNumOfINL = new int [ total_fN ];
	fArray = new int [ total_fN+2 ];
	fCheckN = new int [ total_fN ];
	fB = new int [ total_fN ];
	fGene = new int [ total_fN ];
}

TKopt::~TKopt(){
	for( int i = 0; i < total_fN; ++i ) delete [] fLink[ i ];
	delete [] fLink;

	for( int i = 0; i < total_fN; ++i ) delete [] fLinkSeg[ i ];
	delete [] fLinkSeg;

	for( int i = 0; i < total_fN; ++i ) delete [] fCitySeg[ i ];
	delete [] fCitySeg;

	for( int i = 0; i < total_fN; ++i ) delete [] fInvNearList[ i ];
	delete [] fInvNearList;

	delete [] fOrdCity;
	delete [] fOrdSeg;
	delete [] fSegCity;
	delete [] fOrient;
	delete [] fSizeSeg;
	delete [] fT;
	delete [] fActiveV;
	delete [] fNumOfINL;
	delete [] fArray;
	delete [] fCheckN;
	delete [] fB;
	delete [] fGene;
//	delete eval;
}
void TKopt::input_data(int N)
{
	fN=N;
}
void TKopt::setInvNearList(){
	for( int i = 0; i < fN; ++i ) fNumOfINL[ i ] = 0;
	int c;
	for( int i = 0; i < fN; ++i ){
		for( int k = 0; k < 50; ++k ){
			c = eval->fNearCity[i][k];
			if( fNumOfINL[c] < 500 ) fInvNearList[ c ][ fNumOfINL[c]++ ] = i;
			else{
				//printf( "Check fNumOfINL[c] < 500 ) in kopt.cpp \n" );
				//fflush( stdout );
			}
		}
	}
}

void TKopt::transIndiToTree( TIndi& indi ){
	int num, size, orient;
	fArray[1] = 0;
	for( int i = 2; i <= fN; ++i ) fArray[i] = indi.fLink[ fArray[i-1] ][ 1 ];

	fArray[0] = fArray[fN];
	fArray[fN+1] = fArray[1];
	num = 1;
	fNumOfSeg = 0;
	while(1){
		orient = 1;
		size = 0;
		fOrient[ fNumOfSeg ] = orient;
		fOrdSeg[ fNumOfSeg ] = fNumOfSeg;

		fLink[ fArray[ num ] ][ 0 ] = -1;
		fLink[ fArray[ num ] ][ 1 ] = fArray[ num+1 ];
		fOrdCity[ fArray[ num ] ] = size;
		fSegCity[ fArray[ num ] ] = fNumOfSeg;
		fCitySeg[ fNumOfSeg ][ this->turn(orient) ] = fArray[ num ];
		++num;
		++size;
		for( int i = 0; i < (int)sqrt( fN*1.0 )-1; ++i ){
			if( num == fN ) break;
			fLink[ fArray[ num ] ][ 0 ] = fArray[ num-1 ];
			fLink[ fArray[ num ] ][ 1 ] = fArray[ num+1 ];
			fOrdCity[ fArray[ num ] ] = size;
			fSegCity[ fArray[ num ] ] = fNumOfSeg;
			++num;
			++size;
		}
		if( num == fN-1 ){
			fLink[ fArray[ num ] ][ 0 ] = fArray[ num-1 ];
			fLink[ fArray[ num ] ][ 1 ] = fArray[ num+1 ];
			fOrdCity[ fArray[ num ] ] = size;
			fSegCity[ fArray[ num ] ] = fNumOfSeg;
			++num;
			++size;
		}
		fLink[ fArray[ num ] ][ 0 ] = fArray[ num-1 ];
		fLink[ fArray[ num ] ][ 1 ] = -1;
		fOrdCity[ fArray[ num ] ] = size;
		fSegCity[ fArray[ num ] ] = fNumOfSeg;
		fCitySeg[ fNumOfSeg ][ orient ] = fArray[ num ];
		++num;
		++size;
		fSizeSeg[ fNumOfSeg ] = size;
		++fNumOfSeg;
		if( num == fN+1 ) break;
	}
	for( int s = 1; s < fNumOfSeg-1; ++s ){
		fLinkSeg[ s ][ 0 ] = s-1;
		fLinkSeg[ s ][ 1 ] = s+1;
	}
	fLinkSeg[ 0 ][ 0 ] = fNumOfSeg-1;
	fLinkSeg[ 0 ][ 1 ] = 1;
	fLinkSeg[ fNumOfSeg-1 ][ 0 ] = fNumOfSeg-2;
	fLinkSeg[ fNumOfSeg-1 ][ 1 ] = 0;
	fTourLength = indi.fEvaluationValue;
	fFixNumOfSeg = fNumOfSeg;
}

void TKopt::transTreeToIndi( TIndi& indi ){
	int t_p, t_n;
	for( int t = 0; t < fN; ++t ){
		t_p = this->getPrev( t );
		t_n = this->getNext( t );
		indi.fLink[ t ][ 0 ] = t_p;
		indi.fLink[ t ][ 1 ] = t_n;
	}
	eval->doIt( indi );
}

void TKopt::doIt( TIndi& tIndi ){
	this->transIndiToTree( tIndi );
	this->sub();
	this->transTreeToIndi( tIndi );
}

void TKopt::sub(){
	int t1_st;
	double dis1, dis2;
	//int dis1, dis2;
	for( int t = 0; t < fN; ++t ) fActiveV[ t ] = 1;
BEGIN:
	t1_st = rand()%fN;// select a node randomly
	fT[1] = t1_st;
	//t1's loop
	while(1){
		fT[1] = this->getNext( fT[1] );
		if( fActiveV[ fT[1] ] == 0 ) goto RETURN;
		fFlagRev = 0;
		fT[2] = this->getPrev( fT[1] );
		for( int num1 = 1; num1 < 50; ++num1 ){
			fT[4] = eval->fNearCity[ fT[1] ][ num1 ];
			fT[3] = this->getPrev( fT[4] );
			dis1 = eval->fEdgeDis[fT[1]][fT[2]] - eval->fEdgeDis[fT[1]][fT[4]];
			if( dis1 > 1.0e-7 ){
				dis2 = dis1 + eval->fEdgeDis[fT[3]][fT[4]] - eval->fEdgeDis[fT[3]][fT[2]];
				if( dis2 > 1.0e-7 ){
					this->incrementImp( fFlagRev );// implement swap
					for( int a = 1; a <= 4; ++a )
						for( int k = 0; k < fNumOfINL[fT[a]]; ++k )
							fActiveV[ this->fInvNearList[fT[a]][k] ] = 1;
					goto BEGIN;
				}
			}
			else break;
		}
		fFlagRev = 1;
		fT[2] = this->getNext( fT[1] );
		for( int num1 = 1; num1 < 50; ++num1 ){
			fT[4] = eval->fNearCity[ fT[1] ][ num1 ];
			fT[3] = this->getNext( fT[4] );
			dis1 = eval->fEdgeDis[fT[1]][fT[2]] - eval->fEdgeDis[fT[1]][fT[4]];
			if( dis1 > 1.0e-7 ){
				dis2 = dis1 + eval->fEdgeDis[fT[3]][fT[4]] - eval->fEdgeDis[fT[3]][fT[2]];
				if( dis2 > 1.0e-7 ){
					this->incrementImp( fFlagRev );
					for( int a = 1; a <= 4; ++a )
						for( int k = 0; k < fNumOfINL[fT[a]]; ++k )
							fActiveV[ this->fInvNearList[fT[a]][k] ] = 1;
					goto BEGIN;
				}
			}
			else break;
		}
		fActiveV[ fT[1] ] = 0;
RETURN:
		if( fT[1] == t1_st ) break;
	}
}

int TKopt::getNext( int t ){
	int t_n, seg, orient;
	seg = fSegCity[ t ];
	orient = fOrient[ seg ];
	t_n = fLink[ t ][ orient ];
	if( t_n == -1 ){
		seg = fLinkSeg[ seg ][ orient ];
		orient = turn( fOrient[ seg ] );
		t_n = fCitySeg[ seg ][ orient ];
	}
	return t_n;
}

int TKopt::getPrev( int t ){
	int t_p, seg, orient;
	seg = fSegCity[ t ];
	orient = fOrient[ seg ];
	t_p = fLink[ t ][ this->turn( orient ) ];
	if( t_p == -1 ){
		seg = fLinkSeg[ seg ][ turn(orient) ];
		orient = fOrient[ seg ];
		t_p = fCitySeg[ seg ][ orient ];
	}
	return t_p;
}

void TKopt::swap(int &x, int &y){
	int s=x;
	x=y;
	y=s;
}

int TKopt::turn( int &orient ){
	return 1-orient;
}

void TKopt::incrementImp( int flagRev ){
	int t1_s, t1_e, t2_s, t2_e;
	int seg_t1_s, seg_t1_e, seg_t2_s, seg_t2_e;
	int ordSeg_t1_s, ordSeg_t1_e, ordSeg_t2_s, ordSeg_t2_e;
	int orient_t1_s, orient_t1_e, orient_t2_s, orient_t2_e;
	int numOfSeg1, numOfSeg2;
	int curr;
	int ord;

	int flag_t2e_t1s;
	int flag_t2s_t1e;
	int length_t1s_seg;
	int length_t1e_seg;
	int seg;

	if( fFlagRev == 0 ){
		t1_s = fT[1];
		t1_e = fT[3];
		t2_s = fT[4];
		t2_e = fT[2];
	}
	else if( fFlagRev == 1 ){
		t1_s = fT[2];
		t1_e = fT[4];
		t2_s = fT[3];
		t2_e = fT[1];
	}

	seg_t1_s = fSegCity[ t1_s ];
	ordSeg_t1_s = fOrdSeg[ seg_t1_s ];
	orient_t1_s = fOrient[ seg_t1_s ];
	seg_t1_e = fSegCity[ t1_e ];
	ordSeg_t1_e = fOrdSeg[ seg_t1_e ];
	orient_t1_e = fOrient[ seg_t1_e ];
	seg_t2_s = fSegCity[ t2_s ];
	ordSeg_t2_s = fOrdSeg[ seg_t2_s ];
	orient_t2_s = fOrient[ seg_t2_s ];
	seg_t2_e = fSegCity[ t2_e ];
	ordSeg_t2_e = fOrdSeg[ seg_t2_e ];
	orient_t2_e = fOrient[ seg_t2_e ];

	//////////////////// Type1 ////////////////////////
	if( ( seg_t1_s == seg_t1_e ) && ( seg_t1_s == seg_t2_s ) && ( seg_t1_s == seg_t2_e ) ){
		if( (fOrient[seg_t1_s] == 1 && (fOrdCity[ t1_s ] > fOrdCity[ t1_e ])) ||
			(fOrient[seg_t1_s] == 0 && (fOrdCity[ t1_s ] < fOrdCity[ t1_e ]))){
			this->swap( t1_s, t2_s );
			this->swap( t1_e, t2_e );
			this->swap( seg_t1_s, seg_t2_s );
			this->swap( seg_t1_e, seg_t2_e );
			this->swap( ordSeg_t1_s, ordSeg_t2_s );
			this->swap( ordSeg_t1_e, ordSeg_t2_e );
			this->swap( orient_t1_s, orient_t2_s );
			this->swap( orient_t1_e, orient_t2_e );
		}
		curr = t1_s;
		ord = fOrdCity[ t1_e ];
		while(1){
			this->swap( fLink[curr][0], fLink[curr][1] );
			fOrdCity[ curr ] = ord;
			if( curr == t1_e ) break;
			curr = fLink[curr][turn(orient_t1_s)];
			if( orient_t1_s == 0 ) ++ord;
			else --ord;
		}

		fLink[t2_e][orient_t1_s] = t1_e;
		fLink[t2_s][turn(orient_t1_s)] = t1_s;
		fLink[t1_s][orient_t1_s] = t2_s;
		fLink[t1_e][turn(orient_t1_s)] = t2_e;

		return;
	}
	//////////////////// Type1 ///////////////////////


	if( ordSeg_t1_e >= ordSeg_t1_s )	numOfSeg1 = ordSeg_t1_e - ordSeg_t1_s + 1;
	else								numOfSeg1 = ordSeg_t1_e - ordSeg_t1_s + 1 + fNumOfSeg;
	if( ordSeg_t2_e >= ordSeg_t2_s )	numOfSeg2 = ordSeg_t2_e - ordSeg_t2_s + 1;
	else								numOfSeg2 = ordSeg_t2_e - ordSeg_t2_s + 1 + fNumOfSeg;

	if( numOfSeg1 > numOfSeg2 ){
		this->swap( numOfSeg1, numOfSeg2 );
		this->swap( t1_s, t2_s );
		this->swap( t1_e, t2_e );
		this->swap( seg_t1_s, seg_t2_s );
		this->swap( seg_t1_e, seg_t2_e );
		this->swap( ordSeg_t1_s, ordSeg_t2_s );
		this->swap( ordSeg_t1_e, ordSeg_t2_e );
		this->swap( orient_t1_s, orient_t2_s );
		this->swap( orient_t1_e, orient_t2_e );
	}
	if( fLink[ t2_e ][ orient_t2_e ] == -1 ) flag_t2e_t1s = 1;
	else flag_t2e_t1s = 0;

	if( fLink[ t2_s ][ this->turn(orient_t2_s) ] == -1 ) flag_t2s_t1e = 1;
	else flag_t2s_t1e = 0;

	length_t1s_seg = abs( fOrdCity[ t2_e ] - fOrdCity[ fCitySeg[ seg_t2_e ][ orient_t2_e ] ] );
	length_t1e_seg = abs( fOrdCity[ t2_s ] - fOrdCity[ fCitySeg[ seg_t2_s ][ this->turn(orient_t2_s) ] ] );

	///////////////////// Type2 /////////////////
	if( seg_t1_s == seg_t1_e ){
		if( flag_t2e_t1s == 1 && flag_t2s_t1e == 1 ){
			orient_t1_s = turn( fOrient[ seg_t1_s ] );
			fOrient[ seg_t1_s ] = orient_t1_s;
			fCitySeg[ seg_t1_s ][ orient_t1_s ] = t1_s;
			fCitySeg[ seg_t1_s ][ turn(orient_t1_s) ] = t1_e;
			fLinkSeg[ seg_t1_s ][ orient_t1_s ] = seg_t2_s;
			fLinkSeg[ seg_t1_s ][ turn(orient_t1_s) ] = seg_t2_e;
			return;
		}
		if( flag_t2e_t1s == 0 && flag_t2s_t1e == 1 ){
			curr = t1_e;
			ord = fOrdCity[ t1_s ];
			while(1){
				this->swap( fLink[curr][0], fLink[curr][1] );
				fOrdCity[ curr ] = ord;
				if( curr == t1_s ) break;

				curr = fLink[curr][orient_t2_e];
				if( orient_t2_e == 0 ) --ord;
				else ++ord;
			}
			fLink[t2_e][orient_t2_e] = t1_e;
			fLink[t1_s][orient_t2_e] = -1;
			fLink[t1_e][turn(orient_t2_e)] = t2_e;
			fCitySeg[seg_t2_e][orient_t2_e] = t1_s;
			return;
		}
		if( flag_t2e_t1s == 1 && flag_t2s_t1e == 0 ){
			curr = t1_s;
			ord = fOrdCity[ t1_e ];
			while(1){
				this->swap( fLink[curr][0], fLink[curr][1] );
				fOrdCity[ curr ] = ord;
				if( curr == t1_e ) break;

				curr = fLink[curr][turn(orient_t2_s)];
				if( orient_t2_s == 0 ) ++ord;
				else --ord;
			}
			fLink[t2_s][turn(orient_t2_s)] = t1_s;
			fLink[t1_e][turn(orient_t2_s)] = -1;
			fLink[t1_s][orient_t2_s] = t2_s;
			fCitySeg[seg_t2_s][turn(orient_t2_s)] = t1_e;
			return;
		}
	}

	///////////////////// Type3 /////////////////

	if( flag_t2e_t1s == 1 ) fLinkSeg[seg_t1_s][turn(orient_t1_s)] = seg_t2_s;
	else{
		seg_t1_s = fNumOfSeg++;
		orient_t1_s = orient_t2_e;
		fLink[ t1_s ][turn(orient_t1_s)] = -1;
		fLink[ fCitySeg[seg_t2_e][orient_t2_e]][orient_t1_s] = -1;
		fOrient[seg_t1_s] = orient_t1_s;
		fSizeSeg[seg_t1_s] = length_t1s_seg;
		fCitySeg[seg_t1_s][turn(orient_t1_s)] = t1_s;
		fCitySeg[seg_t1_s][orient_t1_s] = fCitySeg[seg_t2_e][orient_t2_e];
		fLinkSeg[seg_t1_s][turn(orient_t1_s)] = seg_t2_s;
		fLinkSeg[seg_t1_s][orient_t1_s] = fLinkSeg[seg_t2_e][orient_t2_e];
		seg = fLinkSeg[seg_t2_e][orient_t2_e];
		fLinkSeg[seg][turn(fOrient[seg])] = seg_t1_s;
	}

	if( flag_t2s_t1e == 1 ) fLinkSeg[seg_t1_e][orient_t1_e] = seg_t2_e;
	else{
		seg_t1_e = fNumOfSeg++;
		orient_t1_e = orient_t2_s;
		fLink[ t1_e ][orient_t1_e] = -1;
		fLink[ fCitySeg[seg_t2_s][turn(orient_t2_s)] ][turn(orient_t1_e)] = -1;
		fOrient[seg_t1_e] = orient_t1_e;
		fSizeSeg[seg_t1_e] = length_t1e_seg;
		fCitySeg[seg_t1_e][orient_t1_e] = t1_e;
		fCitySeg[seg_t1_e][turn(orient_t1_e)] = fCitySeg[seg_t2_s][turn(orient_t2_s)];
		fLinkSeg[seg_t1_e][orient_t1_e] = seg_t2_e;
		fLinkSeg[seg_t1_e][turn(orient_t1_e)] = fLinkSeg[seg_t2_s][turn(orient_t2_s)];
		seg = fLinkSeg[seg_t2_s][turn(orient_t2_s)];
		fLinkSeg[seg][fOrient[seg]] = seg_t1_e;
	}

	fLink[t2_e][orient_t2_e] = -1;
	fSizeSeg[seg_t2_e] -= length_t1s_seg;
	fCitySeg[seg_t2_e][orient_t2_e] = t2_e;
	fLinkSeg[seg_t2_e][orient_t2_e] = seg_t1_e;
	fLink[t2_s][turn(orient_t2_s)] = -1;
	fSizeSeg[seg_t2_s] -= length_t1e_seg;
	fCitySeg[seg_t2_s][turn(orient_t2_s)] = t2_s;
	fLinkSeg[seg_t2_s][turn(orient_t2_s)] = seg_t1_s;

	seg = seg_t1_e;
	while(1){
		fOrient[seg] = turn(fOrient[seg]);
		if( seg == seg_t1_s ) break;
		seg = fLinkSeg[seg][fOrient[seg]];
	}

	if( fSizeSeg[seg_t2_e] < length_t1s_seg ){
		seg = fLinkSeg[seg_t2_e][turn(fOrient[seg_t2_e])];
		fLinkSeg[seg][fOrient[seg]] = seg_t1_s;
		seg = fLinkSeg[seg_t2_e][fOrient[seg_t2_e]];
		fLinkSeg[seg][turn(fOrient[seg])] = seg_t1_s;
		seg = fLinkSeg[seg_t1_s][turn(fOrient[seg_t1_s])];
		fLinkSeg[seg][fOrient[seg]] = seg_t2_e;
		seg = fLinkSeg[seg_t1_s][fOrient[seg_t1_s]];
		fLinkSeg[seg][turn(fOrient[seg])] = seg_t2_e;

		this->swap( fOrient[seg_t2_e], fOrient[seg_t1_s] );
		this->swap( fSizeSeg[seg_t2_e], fSizeSeg[seg_t1_s] );
		this->swap( fCitySeg[seg_t2_e][0], fCitySeg[seg_t1_s][0] );
		this->swap( fCitySeg[seg_t2_e][1], fCitySeg[seg_t1_s][1] );
		this->swap( fLinkSeg[seg_t2_e][0], fLinkSeg[seg_t1_s][0] );
		this->swap( fLinkSeg[seg_t2_e][1], fLinkSeg[seg_t1_s][1] );
		this->swap( seg_t2_e, seg_t1_s );
	}

	if( fSizeSeg[seg_t2_s] < length_t1e_seg ){
		seg = fLinkSeg[seg_t2_s][turn(fOrient[seg_t2_s])];
		fLinkSeg[seg][fOrient[seg]] = seg_t1_e;
		seg = fLinkSeg[seg_t2_s][fOrient[seg_t2_s]];
		fLinkSeg[seg][turn(fOrient[seg])] = seg_t1_e;
		seg = fLinkSeg[seg_t1_e][turn(fOrient[seg_t1_e])];
		fLinkSeg[seg][fOrient[seg]] = seg_t2_s;
		seg = fLinkSeg[seg_t1_e][fOrient[seg_t1_e]];
		fLinkSeg[seg][turn(fOrient[seg])] = seg_t2_s;

		this->swap( fOrient[seg_t2_s], fOrient[seg_t1_e] );
		this->swap( fSizeSeg[seg_t2_s], fSizeSeg[seg_t1_e] );
		this->swap( fCitySeg[seg_t2_s][0], fCitySeg[seg_t1_e][0] );
		this->swap( fCitySeg[seg_t2_s][1], fCitySeg[seg_t1_e][1] );
		this->swap( fLinkSeg[seg_t2_s][0], fLinkSeg[seg_t1_e][0] );
		this->swap( fLinkSeg[seg_t2_s][1], fLinkSeg[seg_t1_e][1] );
		this->swap( seg_t2_s, seg_t1_e );
	}

	while( fNumOfSeg > fFixNumOfSeg ){
	if( fSizeSeg[ fLinkSeg[fNumOfSeg-1][0] ] <
		fSizeSeg[ fLinkSeg[fNumOfSeg-1][1] ] )
		this->combineSeg( fLinkSeg[fNumOfSeg-1][0], fNumOfSeg-1 );
	else
		this->combineSeg( fLinkSeg[fNumOfSeg-1][1], fNumOfSeg-1 );
	}
	int ordSeg = 0;
	seg = 0;
	while(1){
		fOrdSeg[seg] = ordSeg;
		++ordSeg;
		seg = fLinkSeg[seg][ fOrient[seg] ];
		if( seg == 0 ) break;
	}
  return;
}

void TKopt::combineSeg( int segL, int segS ){
	int seg;
	int t_s, t_e, direction; t_s = 0; t_e = 0; direction = 0;
	int ord; ord = 0;
	int increment; increment = 0;
	int curr, next;

	if( fLinkSeg[segL][fOrient[segL]] == segS ){
		fLink[fCitySeg[segL][fOrient[segL]]][fOrient[segL]] = fCitySeg[segS][turn(fOrient[segS])];
		fLink[fCitySeg[segS][turn(fOrient[segS])]][turn(fOrient[segS])] = fCitySeg[segL][fOrient[segL]];
		ord = fOrdCity[fCitySeg[segL][fOrient[segL]]];

		fCitySeg[segL][fOrient[segL]] = fCitySeg[segS][fOrient[segS]];
		fLinkSeg[segL][fOrient[segL]] = fLinkSeg[segS][fOrient[segS]];
		seg = fLinkSeg[segS][fOrient[segS]];
		fLinkSeg[seg][turn(fOrient[seg])] = segL;

		t_s = fCitySeg[segS][turn(fOrient[segS])];
		t_e = fCitySeg[segS][fOrient[segS]];
		direction = fOrient[segS];

		if( fOrient[segL] == 1 ) increment = 1;
		else increment = -1;
	}
	else if( fLinkSeg[segL][turn(fOrient[segL])] == segS ){
		fLink[fCitySeg[segL][turn(fOrient[segL])]][turn(fOrient[segL])] = fCitySeg[segS][fOrient[segS]];
		fLink[fCitySeg[segS][fOrient[segS]]][fOrient[segS]] = fCitySeg[segL][turn(fOrient[segL])];
		ord = fOrdCity[fCitySeg[segL][turn(fOrient[segL])]];

		fCitySeg[segL][turn(fOrient[segL])] = fCitySeg[segS][turn(fOrient[segS])];
		fLinkSeg[segL][turn(fOrient[segL])] = fLinkSeg[segS][turn(fOrient[segS])];
		seg = fLinkSeg[segS][turn(fOrient[segS])];
		fLinkSeg[seg][fOrient[seg]] = segL;

		t_s = fCitySeg[segS][fOrient[segS]];
		t_e = fCitySeg[segS][turn(fOrient[segS])];
		direction = turn(fOrient[segS]);

		if( fOrient[segL] == 1 ) increment = -1;
		else increment = 1;
	}
	curr = t_s;
	ord = ord + increment;
	while(1){
		fSegCity[curr] = segL;
		fOrdCity[curr] = ord;

		next = fLink[curr][direction];
		if( fOrient[segL] != fOrient[segS] ) this->swap( fLink[curr][0], fLink[curr][1] );

		if( curr == t_e ) break;
		curr = next;
		ord += increment;
	}
	fSizeSeg[segL] += fSizeSeg[segS];
	--fNumOfSeg;
}

void TKopt::checkDetail(){
	int seg, seg_p, seg_n;
	int ord, ord_p, ord_n;
	int orient;
	int curr;

	seg = 0;
	for( int s = 0; s < fNumOfSeg; ++s ){
		seg = s;
		orient = fOrient[ seg ];
		seg_p = fLinkSeg[ seg ][ this->turn(orient) ];
		seg_n = fLinkSeg[ seg ][ orient ];

		ord = fOrdSeg[ seg ];
		ord_p = ord - 1 ;
		if( ord_p < 0 ) ord_p = fNumOfSeg - 1;

		ord_n = ord + 1;
		if( ord_n >= fNumOfSeg ) ord_n = 0;

		curr = fCitySeg[ s ][ 0 ];
		int count = 0;

		while(1){
			++count;
			if( curr == fCitySeg[ s ][1] ) break;
			curr = fLink[curr][1];
		}
	}
	int t, t_n, t_p, t_s, t_e;
	for( t = 0; t < fN; ++t ){
		seg = fSegCity[ t ];
		orient = fOrient[ seg ];
		t_s = fCitySeg[ seg ][ 0 ];
		t_e = fCitySeg[ seg ][ 1 ];

		t_p = fLink[ t ][ 0 ];
		t_n = fLink[ t ][ 1 ];
	}
}

void TKopt::checkValid(){
	int t_st, t_c, t_n, count, seg, orient, Invalid = 0;
	for( int i = 0; i < fN; ++i ) fCheckN[ i ] = 0;

	t_st = rand() % fN;
	t_n = t_st;
	count = 0;
	while(1){
		t_c = t_n;
		fCheckN[ t_c ] = 1;
		++count;

		seg = fSegCity[ t_c ];
		orient = fOrient[ seg ];
		t_n = this->getNext( t_c );

		if( t_n == t_st ) break;

		if( count == fN+1 ){
			Invalid = 1;
			break;
		}
	}
	for( int i = 0; i < fN; ++i )
		if( fCheckN[ i ] == 0 ) Invalid = 1;

	if( Invalid == 1 ) printf( "Invalid \n" ); fflush( stdout );

}

void TKopt::makeRandSol( TIndi& indi ){
	for( int j = 0; j < fN; ++j ) fB[j] = j;
	int r;
	for( int i = 0; i < fN; ++i ){
		r = rand() % (fN-i);
		fGene[i] = fB[r];
		fB[r] = fB[fN-i-1];
	}

	for( int j2 = 1 ; j2 < fN-1; ++j2 ){
		indi.fLink[fGene[j2]][0] = fGene[j2-1];
		indi.fLink[fGene[j2]][1] = fGene[j2+1];
	}
	indi.fLink[fGene[0]][0] = fGene[fN-1];
	indi.fLink[fGene[0]][1] = fGene[1];
	indi.fLink[fGene[fN-1]][0] = fGene[fN-2];
	indi.fLink[fGene[fN-1]][1] = fGene[0];

	eval->doIt( indi );
}


The file kopt.h contains:
/*
 * kopt.h
 *   created on: April 24, 2013
 * last updated: June 13, 2013
 *       author: liushujia
 */

#ifndef __KOPT__
#define __KOPT__

#ifndef __RAND__
#include "randomize.h"
#endif

#ifndef __Sort__
#include "sort.h"
#endif

#ifndef __INDI__
#include "indi.h"
#endif

#ifndef __EVALUATOR__
#include "evaluator.h"
#endif

#include <stdio.h>
#include <stdlib.h>
#include <assert.h>

class TKopt{
public:
	TKopt( int N );
	~TKopt();
	void input_data(int N);
	void setInvNearList();
	void transIndiToTree( TIndi& indi );
	void transTreeToIndi( TIndi& indi );
	void doIt( TIndi& tIndi );			// å±€éƒ¨æ�œç´¢(2-opt neighborhood)

	int getNext( int t );
	int getPrev( int t );
	int turn( int &orient );

	void sub();
	void incrementImp( int flagRev );
	void combineSeg( int segL, int segS );

	void checkDetail();
	void checkValid();
	void swap(int &x, int &y);
	void makeRandSol( TIndi& indi );		// è®¾ç½®éš�æœºè·¯ç¨‹

	TEvaluator* eval;

private:
	int fN;
	int total_fN;
	int fFixNumOfSeg;
	int fNumOfSeg;
	int fFlagRev;
	double fTourLength;
	//int fTourLength;

	int **fLink;
	int **fLinkSeg;
	int **fCitySeg;
	int **fInvNearList;

	int *fT;
	int *fB;
	int *fSegCity;
	int *fOrdCity;
	int *fOrdSeg;
	int *fOrient;
	int *fSizeSeg;
	int *fActiveV;
	int *fNumOfINL;
	int *fArray;
	int *fCheckN;
	int *fGene;
};

#endif

The file LS.cpp contains:
/*
 * LS.cpp
 *
 *  Created on: 18 Apr 2020
 *      Author: Peng
 */

#include "LS.h"
#include "basic.h"
#include "Tstwoopt.h"
#include "EAX.h"
#include "environment.h"
#include "Individual.h"
LS::LS(read_data * data) {
	num_v=data->num_v;
	v_num=data->v_num;
	tem=new Individual();
	tem->define(num_v,v_num);
	each_route=new Tstwoopt (data);
	each_route->I_data=data;
	record_table=new int [v_num];
	s_t=new int [num_v+1];
	cand_str1=new int *[length_s*length_s];
	cand_str2=new int *[length_s*length_s];
	for (int i=0;i<=length_s*length_s-1;i++){
		cand_str1[i]=new int [length_s];
		cand_str2[i]=new int [length_s];
	}
	cand_fit=new double [length_s*length_s];
	near_cand1=new int *[num_near_nodes+100];
	for (int i=0;i<=num_near_nodes+100-1;i++)
		near_cand1[i]=new int [6];
	near_fit=new double [num_near_nodes+100];
	rever_list=new int [length_s*length_s];
	// tabu search variables
	tabu_table=new int *[v_num];
	tabu_table_c=new int *[v_num];
	for (int i=0;i<=v_num-1;i++){
		tabu_table[i]=new int [num_v+1];
		tabu_table_c[i]=new int [num_v+1];
	}
	t_t_swap=new int *[num_v+1];
	for (int i=0;i<=num_v;i++)
		t_t_swap[i]=new int [num_v+1];
	for (int i=0;i<=num_v;i++)
		for (int j=0;j<=num_v;j++)
			t_t_swap[i][j]=0;
	iteration=0;
}
LS::~LS() {
	delete tem;
	delete each_route;
	delete [] record_table;
	delete [] s_t;
	for (int i=0;i<=length_s*length_s-1;i++){
		delete [] cand_str1[i];
		delete [] cand_str2[i];
	}
	delete [] cand_str1;
	delete [] cand_str2;
	delete [] cand_fit;
	for (int i=0;i<=num_near_nodes+100-1;i++)
		delete [] near_cand1[i];
	delete [] near_cand1;
	delete [] near_fit;
	delete [] rever_list;
	for (int i=0;i<=v_num-1;i++){
		delete [] tabu_table[i];
		delete [] tabu_table_c[i];
	}
	delete [] tabu_table;
	delete [] tabu_table_c;
	for (int i=0;i<=num_v;i++)
		delete [] t_t_swap[i];
	delete [] t_t_swap;
}
void LS::update_best_solution(){
	if (s->fitness < b_s->fitness){
		for (int i=0;i<=v_num-1;i++){
			for (int j=0;j<=num_v;j++){
				b_s->sol[i][j]=s->sol[i][j];
				b_s->sol_r[i][j]=s->sol_r[i][j];
			}
			b_s->fit_tour[i]=s->fit_tour[i];
		}
		b_s->fitness=s->fitness;
	}
}
void LS::supply_edge(){
	int p;
	for (int i=0;i<v_num;i++){
		p=0;
		while(1){
			I_data->edge[p][b_s->sol[i][p]]=1;
			p=b_s->sol[i][p];
			if (p==0)break;
		}
	}
}
void LS::reverse_fun(){// get value for sol_r;
	int pointer;
	vector<int >tour;
	for (int i=0;i<=v_num-1;i++)	{
		pointer=s->sol[i][0];
		while (pointer!=0)		{
			tour.push_back(pointer);
			pointer=s->sol[i][pointer];
		}
		s->sol_r[i][0]=tour.back();
		tour.pop_back();
		pointer=s->sol_r[i][0];
		while (tour.size())		{
			s->sol_r[i][pointer]=tour.back();
			pointer=s->sol_r[i][pointer];
			tour.pop_back();
		}
		s->sol_r[i][pointer]=0;
	}
}
int LS::replace_fun_insert(double min_delta,int row_out,int city_out,int row_in,int city_in){
	double delta1=0;
	double delta2=0;
	delta1+=I_data->Distance[s->sol_r[row_out][city_out]][s->sol[row_out][city_out]];
	delta1=delta1-I_data->Distance[s->sol_r[row_out][city_out]][city_out]-I_data->Distance[s->sol[row_out][city_out]][city_out];
	//
	delta2+=I_data->Distance[city_in][city_out]+I_data->Distance[city_out][s->sol[row_in][city_in]];
	delta2=delta2-I_data->Distance[city_in][s->sol[row_in][city_in]];
	//
	s->fit_tour[row_out]=s->fit_tour[row_out]+delta1;
	s->fit_tour[row_in]=s->fit_tour[row_in]+delta2;
	int longest_tour=0;
	for (int i=1;i<=v_num-1;i++)
		if (s->fit_tour[i]>s->fit_tour[longest_tour])
			longest_tour=i;
	s->fitness=s->fit_tour[longest_tour];
	//
	int p_p,n_p;
	p_p=s->sol_r[row_out][city_out];
	n_p=s->sol[row_out][city_out];
	s->sol[row_out][p_p]=n_p;
	s->sol[row_out][city_out]=-1;
	s->sol_r[row_out][n_p]=p_p;
	s->sol_r[row_out][city_out]=-1;
	//
	n_p=s->sol[row_in][city_in];
	s->sol[row_in][city_in]=city_out;
	s->sol[row_in][city_out]=n_p;
	s->sol_r[row_in][n_p]=city_out;
	s->sol_r[row_in][city_out]=city_in;
	return 	longest_tour;
}
double LS::calculate_fit_insert(int row_out,int city_out,int row_in,int city_in,int longest_third){
	double delta1=0;
	double delta2=0;
	delta1+=I_data->Distance[s->sol_r[row_out][city_out]][s->sol[row_out][city_out]];
	delta1=delta1-I_data->Distance[s->sol_r[row_out][city_out]][city_out]-I_data->Distance[s->sol[row_out][city_out]][city_out];
	//
	delta2+=I_data->Distance[city_in][city_out]+I_data->Distance[city_out][s->sol[row_in][city_in]];
	delta2=delta2-I_data->Distance[city_in][s->sol[row_in][city_in]];
	//
	delta1=s->fit_tour[row_out]+delta1;
	delta2=s->fit_tour[row_in]+delta2;
	double delta=delta1;
	if (delta<delta2)
		delta=delta2;
	if (delta<s->fit_tour[longest_third])
		delta=s->fit_tour[longest_third];
	delta=delta-s->fitness;
	return delta;
}

void LS::calculate_fit(int st1,int end1,int st2,int end2,int k, int reverse){
	double fit1=0;double fit2=0;
	int pointer;double tem_fit=0;double tem_fit2=0;
	if (k==0 && reverse==1){//
		pointer=st2;
		while (pointer!=end2){
			tem_fit+=I_data->Distance[pointer][s->sol[s_t[pointer]][pointer]];
			pointer=s->sol[s_t[pointer]][pointer];
		}
		fit1+=tem_fit+I_data->Distance[st1][st2]+I_data->Distance[end2][s->sol[s_t[st1]][st1]]-I_data->Distance[st1][s->sol[s_t[st1]][st1]];
		fit2+=I_data->Distance[s->sol_r[s_t[st2]][st2]][s->sol[s_t[end2]][end2]]-I_data->Distance[s->sol_r[s_t[st2]][st2]][st2]-
				I_data->Distance[s->sol[s_t[st2]][end2]][end2];
		fit2=fit2-tem_fit;
	}
	if (k==0 && reverse==0){//
		pointer=st2;
		while (pointer!=end2){
			tem_fit+=I_data->Distance[pointer][s->sol_r[s_t[pointer]][pointer]];
			pointer=s->sol_r[s_t[pointer]][pointer];
		}
		fit1+=tem_fit+I_data->Distance[st1][st2]+I_data->Distance[end2][s->sol[s_t[st1]][st1]]-I_data->Distance[st1][s->sol[s_t[st1]][st1]];
		fit2+=I_data->Distance[s->sol[s_t[st2]][st2]][s->sol_r[s_t[end2]][end2]]-
			I_data->Distance[st2][s->sol[s_t[st2]][st2]]-I_data->Distance[end2][s->sol_r[s_t[end2]][end2]];
		fit2=fit2-tem_fit;
	}
	if (k!=0 && reverse==1){
		pointer=s->sol[s_t[end1]][st1];
		while (pointer!=end1){
			tem_fit+=I_data->Distance[pointer][s->sol[s_t[pointer]][pointer]];
			pointer=s->sol[s_t[pointer]][pointer];
		}
		pointer=st2;
		while (pointer!=end2){
			tem_fit2+=I_data->Distance[pointer][s->sol[s_t[pointer]][pointer]];
			pointer=s->sol[s_t[pointer]][pointer];
		}
		fit1+=tem_fit2+I_data->Distance[st1][st2]+I_data->Distance[end2][s->sol[s_t[end1]][end1]]-
			tem_fit-I_data->Distance[st1][s->sol[s_t[end1]][st1]]-I_data->Distance[end1][s->sol[s_t[end1]][end1]];
		fit2+=tem_fit+I_data->Distance[s->sol_r[s_t[st2]][st2]][s->sol[s_t[end1]][st1]]+I_data->Distance[s->sol[s_t[end2]][end2]][end1]-
			tem_fit2-I_data->Distance[st2][s->sol_r[s_t[st2]][st2]]-I_data->Distance[end2][s->sol[s_t[end2]][end2]];
	}
	if (k!=0 && reverse==0){
		pointer=s->sol[s_t[end1]][st1];
		while (pointer!=end1){
			tem_fit+=I_data->Distance[pointer][s->sol[s_t[pointer]][pointer]];
			pointer=s->sol[s_t[pointer]][pointer];
		}
		pointer=st2;
		while (pointer!=end2){
			tem_fit2+=I_data->Distance[pointer][s->sol_r[s_t[pointer]][pointer]];
			pointer=s->sol_r[s_t[pointer]][pointer];
		}
		fit1+=tem_fit2+I_data->Distance[st1][st2]+I_data->Distance[end2][s->sol[s_t[end1]][end1]]-
			tem_fit-I_data->Distance[st1][s->sol[s_t[st1]][st1]]-I_data->Distance[end1][s->sol[s_t[end1]][end1]];
		fit2+=tem_fit+I_data->Distance[s->sol[s_t[st2]][st2]][s->sol[s_t[st1]][st1]]+I_data->Distance[s->sol_r[s_t[end2]][end2]][end1]
			-tem_fit2-I_data->Distance[st2][s->sol[s_t[st2]][st2]]-I_data->Distance[end2][s->sol_r[s_t[end2]][end2]];
	}
	s->fit_tour[s_t[end1]]=fit1+s->fit_tour[s_t[end1]];
	s->fit_tour[s_t[st2]]=fit2+s->fit_tour[s_t[st2]];
	s->fitness=0;
	for(int i=0;i<=v_num-1;i++)
		if (s->fit_tour[i]>s->fitness){
			s->fitness=s->fit_tour[i];
			ot=i;
		}
}
void LS::replace_fun(int *move){
	int string1[length_s];
	int string2[length_s];
	for (int i=0;i<=length_s-1;i++){
		string1[i]=-1;
		string2[i]=-1;
	}
	int count1=0;int row1=s_t[move[1]];int row2=s_t[move[2]];
	while(1){
		if (move[0]!=move[1]){
			string1[count1]=move[0];
			count1++;
			move[0]=s->sol[row1][move[0]];
		}
		else{
			string1[count1]=move[1];count1++;
			break;
		}
	}
	int count2=0;
	while (1){
		if (move[2]!=move[3]){
			string2[count2]=move[2];
			count2++;
			if (move[4]==1)
				move[2]=s->sol[row2][move[2]];
			else
				move[2]=s->sol_r[row2][move[2]];
		}
		else{
			string2[count2]=move[3];count2++;
			break;
		}
	}
	// calculating move gains
	double fit1=0;
	double fit2=0;
	for (int i=2;i<=count1-1;i++){
		fit1+=I_data->Distance[string1[i-1]][string1[i]];
	}
	for (int i=1;i<=count2-1;i++){
		fit2+=I_data->Distance[string2[i-1]][string2[i]];
	}
	calculate_fit(string1[0],string1[count1-1],string2[0],string2[count2-1],count1-1, move[4]);
	I_data->use_frequency[count1-1][count2-1]=I_data->use_frequency[count1-1][count2-1]+1;
	for (int i=1;i<=count1-1;i++)
		s_t[string1[i]]=row2;
	for (int i=0;i<=count2-1;i++)
		s_t[string2[i]]=row1;
	if (cross_exchange_identify==2){
		for (int i=1;i<=count1-1;i++)
			tabu_table[s_t[string1[i]]][string1[i]]=iteration + tabu_l+rand()%tabu_l;// tabu
		for (int i=0;i<=count2-1;i++)
			tabu_table[s_t[string2[i]]][string2[i]]=iteration + tabu_l+rand()%tabu_l;// tabu
	}
	int start1=string1[0];
	int start11=start1;
	int end1=s->sol[row1][string1[count1-1]];
	int end11=end1;
	int start2,end2,start22;
	if (move[4]==1){//whether reverse 1 is not and 0 is true
		start2=s->sol_r[row2][string2[0]];
		end2=s->sol[row2][string2[count2-1]];
		start22=start2;
		for (int i=1;i<=count1-1;i++){
			s->sol[row1][string1[i]]=-1;
			s->sol_r[row1][string1[i]]=-1;
		}
		for (int i=0;i<=count2-1;i++){
			s->sol[row2][string2[i]]=-1;
			s->sol_r[row2][string2[i]]=-1;
		}
		for (int i=0;i<=count2-1;i++){
			s->sol[row1][start1]=string2[i];
			start1=string2[i];
		}
		s->sol[row1][start1]=end11;
		for(int i=1;i<=count1-1;i++){
			s->sol[row2][start2]=string1[i];
			start2=string1[i];
		}
		s->sol[row2][start2]=end2;
		// for sol_r
		for (int i=count2-1;i>=0;i--){
			s->sol_r[row1][end1]=string2[i];
			end1=string2[i];
		}
		s->sol_r[row1][end1]=start11;
		for (int i=count1-1;i>=1;i--){
			s->sol_r[row2][end2]=string1[i];
			end2=string1[i];
		}
		s->sol_r[row2][end2]=start22;
	}
	else{
		start2=s->sol[row2][string2[0]];
		end2=s->sol_r[row2][string2[count2-1]];
		start22=start2;
		for (int i=1;i<=count1-1;i++){
			s->sol[row1][string1[i]]=-1;
			s->sol_r[row1][string1[i]]=-1;
		}
		for (int i=0;i<=count2-1;i++){
			s->sol[row2][string2[i]]=-1;
			s->sol_r[row2][string2[i]]=-1;
		}
		for (int i=0;i<=count2-1;i++){
			s->sol[row1][start1]=string2[i];
			start1=string2[i];
		}
		s->sol[row1][start1]=end11;
		for(int i=1;i<=count1-1;i++){
			s->sol_r[row2][start2]=string1[i];
			start2=string1[i];
		}
		s->sol_r[row2][start2]=end2;
		// for sol_r
		for (int i=count2-1;i>=0;i--){
			s->sol_r[row1][end1]=string2[i];
			end1=string2[i];
		}
		s->sol_r[row1][end1]=start11;
		for (int i=count1-1;i>=1;i--){
			s->sol[row2][end2]=string1[i];
			end2=string1[i];
		}
		s->sol[row2][end2]=start22;
	}
}
void LS::intra_route_optimization(){// this method will include many methods to optimize each route, such as 2-opt, Lk and EAX.
	tem->fitness=s->fitness;
	int pointer;
	for (int i=0;i<=v_num-1;i++)
		for (int j=0;j<=num_v;j++){
			tem->sol[i][j]=s->sol[i][j];
			tem->sol_r[i][j]=s->sol_r[i][j];
		}
	int number_routes[v_num];
	int route[num_v+1];
	for (int i=0;i<=v_num-1;i++){
		if (record_table[i]==1){
			record_table[i]=0;
			pointer=s->sol[i][0];number_routes[i]=0;
			route[number_routes[i]]=0;number_routes[i]++;
			while (1){
				if (pointer==0)
					break;
				else{
					route[number_routes[i]]=pointer;
					number_routes[i]++;
					pointer=s->sol[i][pointer];
				}
			}
			int sub_route[number_routes[i]];
			for (int j=0;j<=number_routes[i]-1;j++)
				sub_route[j]=route[j];
//			for (int j=0;j<=number_routes[i]-1;j++)
//				cout<<sub_route[j]<<"  ";
//			cout<<endl;
			// here are many intra-route optimization operators.
			if (intra_opt==1)
				each_route->twoopt(sub_route,number_routes[i]);
			if (intra_opt==3){
				if (number_routes[i]>4)
					EAX(gEnv, sub_route,number_routes[i],I_data->x,I_data->y);
				else
					if (number_routes[i]==4)
						each_route->twoopt(sub_route,number_routes[i]);
			}
			// insert results to sol;
			pointer=0;
			for (int j=1;j<=number_routes[i]-1;j++){
				tem->sol[i][pointer]=sub_route[j];
				pointer=tem->sol[i][pointer];
			}
			tem->sol[i][pointer]=0;
			pointer=0;
			for (int j=number_routes[i]-1;j>=1;j--){
				tem->sol_r[i][pointer]=sub_route[j];
				pointer=tem->sol_r[i][pointer];
			}
			tem->sol_r[i][pointer]=0;
		}
		else
			continue;
	}
	double current_cost=0;
	for (int i=0;i<=v_num-1;i++){
		pointer=0;tem->fit_tour[i]=0;
		while (1){
			tem->fit_tour[i]+=I_data->Distance[pointer][tem->sol[i][pointer]];
			if (tem->sol[i][pointer]==0)
				break;
			else
				pointer=tem->sol[i][pointer];
		}
	}
	for (int i=0;i<=v_num-1;i++){
		if (tem->fit_tour[i]>current_cost)
			current_cost=tem->fit_tour[i];
	}
	if (current_cost<s->fitness){
		s->fitness=current_cost;
		for (int i=0;i<=v_num-1;i++){
			for (int j=0;j<=num_v;j++){
				s->sol[i][j]=tem->sol[i][j];
				s->sol_r[i][j]=tem->sol_r[i][j];
			}
			s->fit_tour[i]=tem->fit_tour[i];
		}
	}
	//update_best_solution();
}
double LS::gain_fun(int st1,int end1,int st2,int end2,int k, int reverse,int longest_third){
	double fit1=0;double fit2=0;
	//double opt_fit=s->fit_tour[ot];
	int pointer;double tem_fit=0;double tem_fit2=0;
	if (k==0 && reverse==1){//
		pointer=st2;
		while (pointer!=end2){
			tem_fit+=I_data->Distance[pointer][s->sol[s_t[pointer]][pointer]];
			pointer=s->sol[s_t[pointer]][pointer];
		}
		fit1+=tem_fit+I_data->Distance[st1][st2]+I_data->Distance[end2][s->sol[s_t[st1]][st1]]-I_data->Distance[st1][s->sol[s_t[st1]][st1]];
		fit2+=I_data->Distance[s->sol_r[s_t[st2]][st2]][s->sol[s_t[end2]][end2]]-I_data->Distance[s->sol_r[s_t[st2]][st2]][st2]-
				I_data->Distance[s->sol[s_t[st2]][end2]][end2];
		fit2=fit2-tem_fit;
	}
	if (k==0 && reverse==0){//
		pointer=st2;
		while (pointer!=end2){
			tem_fit+=I_data->Distance[pointer][s->sol_r[s_t[pointer]][pointer]];
			pointer=s->sol_r[s_t[pointer]][pointer];
		}
		fit1+=tem_fit+I_data->Distance[st1][st2]+I_data->Distance[end2][s->sol[s_t[st1]][st1]]-I_data->Distance[st1][s->sol[s_t[st1]][st1]];
		fit2+=I_data->Distance[s->sol[s_t[st2]][st2]][s->sol_r[s_t[end2]][end2]]-
			I_data->Distance[st2][s->sol[s_t[st2]][st2]]-I_data->Distance[end2][s->sol_r[s_t[end2]][end2]];
		fit2=fit2-tem_fit;
	}
	if (k!=0 && reverse==1){
		pointer=s->sol[s_t[end1]][st1];
		while (pointer!=end1){
			tem_fit+=I_data->Distance[pointer][s->sol[s_t[pointer]][pointer]];
			pointer=s->sol[s_t[pointer]][pointer];
		}
		pointer=st2;
		while (pointer!=end2){
			tem_fit2+=I_data->Distance[pointer][s->sol[s_t[pointer]][pointer]];
			pointer=s->sol[s_t[pointer]][pointer];
		}
		fit1+=tem_fit2+I_data->Distance[st1][st2]+I_data->Distance[end2][s->sol[s_t[end1]][end1]]-
			tem_fit-I_data->Distance[st1][s->sol[s_t[end1]][st1]]-I_data->Distance[end1][s->sol[s_t[end1]][end1]];
		fit2+=tem_fit+I_data->Distance[s->sol_r[s_t[st2]][st2]][s->sol[s_t[end1]][st1]]+I_data->Distance[s->sol[s_t[end2]][end2]][end1]-
			tem_fit2-I_data->Distance[st2][s->sol_r[s_t[st2]][st2]]-I_data->Distance[end2][s->sol[s_t[end2]][end2]];
	}
	if (k!=0 && reverse==0){
		pointer=s->sol[s_t[st1]][st1];
		while (pointer!=end1){
			tem_fit+=I_data->Distance[pointer][s->sol[s_t[pointer]][pointer]];
			pointer=s->sol[s_t[pointer]][pointer];
		}
		pointer=st2;
		while (pointer!=end2){
			tem_fit2+=I_data->Distance[pointer][s->sol_r[s_t[pointer]][pointer]];
			pointer=s->sol_r[s_t[pointer]][pointer];
		}
		fit1+=tem_fit2+I_data->Distance[st1][st2]+I_data->Distance[end2][s->sol[s_t[end1]][end1]]-
			tem_fit-I_data->Distance[st1][s->sol[s_t[st1]][st1]]-I_data->Distance[end1][s->sol[s_t[end1]][end1]];
		fit2+=tem_fit+I_data->Distance[s->sol[s_t[st2]][st2]][s->sol[s_t[st1]][st1]]+I_data->Distance[s->sol_r[s_t[end2]][end2]][end1]
			-tem_fit2-I_data->Distance[st2][s->sol[s_t[st2]][st2]]-I_data->Distance[end2][s->sol_r[s_t[end2]][end2]];
	}
	double result1=fit1+s->fit_tour[s_t[end1]];
	double result2=fit2+s->fit_tour[s_t[st2]];
	double delta=result1;;
	if (delta<result2)
		delta=result2;
	if (delta<s->fit_tour[longest_third])
		delta=s->fit_tour[longest_third];
	delta=delta-s->fitness;
	return delta;
}
void LS:: cross_exchange_1(){
	int pointer;
	for (int i=0;i<=v_num-1;i++){
		pointer=s->sol[i][0];
		while (pointer!=0){
			s_t[pointer]=i;
			pointer=s->sol[i][pointer];
		}
	}
	double delta;int in_num;
	int end2,end1;int count;double tem;int iden1,iden2;
	int better_move[6];double better_fit;
	int reverse;
	int step=0;
	double max_fitness;	int pt;int j;int longest_third;
	while (1){
		max_fitness=0;
		for (int i=0;i<=v_num-1;i++)
			if (s->fit_tour[i]>max_fitness){
				max_fitness=s->fit_tour[i];
				ot=i;
			}
		better_fit=0;step++;
		for (int i=0;i<=v_num-1;i++){
			if (i==ot)continue;// do not exchange substring in the same route
			pointer=s->sol[i][0];

			longest_third=-1;
			for (int j=0;j<=v_num-1;j++){
				if (j!=ot && j!=i && longest_third==-1)
					longest_third=j;
				if (longest_third>-1 && j!=ot && j!=i && s->fit_tour[longest_third]<s->fit_tour[j])
					longest_third=j;
			}
			while(1){
				if (pointer==0)break;
				else{
					pt=0;
					j=0;
					while(1){
						in_num=-1;
						pt=s->sol[ot][pt];
						if (pt==0)break;
						if (I_data->edge[pt][pointer]==0)
							continue;
						in_num=pt;
						if (in_num==-1)continue;
						count=0;
						if (1){// case 1
							iden1=0;end1=pointer;
							for (int k=0;k<=length_s-1;k++){// carry the out row
								reverse=1;
								if (k>0){
									end1=s->sol[i][end1];
								}
								if (end1==0 || iden1==1)break;//
								iden2=0;
								end2=in_num;
								for (int n=0;n<=length_s-1;n++){////////////////////////////////////////////////////
									if (n==1){// determine the right or left
										if (s->sol[s_t[in_num]][in_num]==0)reverse=0;//
										if (s->sol_r[s_t[in_num]][in_num]==0)reverse=1;//
										if (s->sol_r[s_t[in_num]][in_num]!=0 && s->sol[s_t[in_num]][in_num]!=0){
											if (gain_fun(pointer,end1,in_num,s->sol[s_t[in_num]][in_num],k,1,longest_third)<
												gain_fun(pointer,end1,in_num,s->sol_r[s_t[in_num]][in_num],k,0,longest_third))
												reverse=1;
											else
												reverse=0;
										}
									}
									if (reverse==1 && n!=0){
										end2=s->sol[s_t[end2]][end2];
									}
									if (reverse==0 && n!=0){
										end2=s->sol_r[s_t[end2]][end2];
									}
									if (end2==0 || iden2==1)break;
									delta=gain_fun(pointer,end1,in_num,end2,k,reverse,longest_third);
									if (delta<0){
										count++;
										cand_str1[count-1][0]=pointer;
										cand_str1[count-1][1]=end1;
										cand_str2[count-1][0]=in_num;
										cand_str2[count-1][1]=end2;
										rever_list[count-1]=reverse;
										cand_fit[count-1]=delta;
									}
								}
							}
						}
						if (count==0){continue;}
						tem=0;
						for (int k=0;k<=count-1;k++)
							if (tem>cand_fit[k]){
								near_cand1[j][0]=cand_str1[k][0];
								near_cand1[j][1]=cand_str1[k][1];
								near_cand1[j][2]=cand_str2[k][0];
								near_cand1[j][3]=cand_str2[k][1];
								near_cand1[j][4]=rever_list[k];
								near_fit[j]=cand_fit[k];
								tem=cand_fit[k];/////////////////////////////////////////////////////////////////////////////////////////////////////
							}
						j++;
					}
					for (int k=0;k<=j-1;k++){
						if (better_fit>near_fit[k]){
							better_fit=near_fit[k];
							better_move[0]=near_cand1[k][0];
							better_move[1]=near_cand1[k][1];
							better_move[2]=near_cand1[k][2];
							better_move[3]=near_cand1[k][3];
							better_move[4]=near_cand1[k][4];
						}
					}
				}
				pointer=s->sol[i][pointer];
			}
		}
		if (better_fit>-1.0e-7)
			break;
		record_table[s_t[better_move[0]]]=1;
		record_table[s_t[better_move[2]]]=1;
		replace_fun(better_move);
	}
//	update_best_solution();
}


void LS::insert(){
	int pointer;
	int pointer_2;
	int longest_tour=0;
	int longest_third;
	double delta,min_delta;
	int row_out,city_out,row_in,city_in;
	for (int i=1;i<=v_num-1;i++){// determine the longest tour;
		if (s->fit_tour[longest_tour]<s->fit_tour[i])
			longest_tour=i;
	}
	while(1){
		min_delta=Max;
		pointer=0;
		while(1){// loop for the longest tour
			pointer=s->sol[longest_tour][pointer];// this is the first city in longest tour;
			if (pointer==0)break;
			for (int i=0;i<=v_num-1;i++){
				if (i==longest_tour)continue;// not overlap
				//
				longest_third=-1;
				for (int j=0;j<=v_num-1;j++){
					if (j!=longest_tour && j!=i && longest_third==-1)
						longest_third=j;
					if (longest_third>-1 && j!=longest_tour && j!=i && s->fit_tour[longest_third]<s->fit_tour[j])
						longest_third=j;
				}
				pointer_2=0;
				while(1){
					/////////////////////////////////////////////////////////////////
					if (I_data->edge[pointer][pointer_2]!=1){
						pointer_2=s->sol[i][pointer_2];
						if (pointer_2==0)break;
						else continue;
					}
					///////////////////////////////////////////////////////////////////
					delta=calculate_fit_insert(longest_tour,pointer,i,pointer_2,longest_third);
					if (delta<min_delta){
						min_delta=delta;
						row_out=longest_tour;
						city_out=pointer;
						row_in=i;
						city_in=pointer_2;
					}
					pointer_2=s->sol[i][pointer_2];
					if (pointer_2==0)break;
				}
			}
		}
		if (min_delta+1.0e-7>0)break;
		longest_tour=replace_fun_insert(min_delta,row_out,city_out,row_in,city_in);
		record_table[row_out]=1;
		record_table[row_in]=1;
//		cout<<min_delta<<endl;
	}
}

void LS::inter_route_optimization(){
		insert();
	//	swap();
		cross_exchange_1();
}
void LS::local_search(){
	reverse_fun();// get value for sol_r;
	// to iterate all steps
	for (int i=0;i<=v_num-1;i++)
		record_table[i]=1;
	double local_optima;
	inter_route_optimization();
//	intra_route_optimization();
	local_optima=s->fitness;
	while (1){
		inter_route_optimization();
		if (local_optima-1.0e-7<s->fitness && local_optima+1.0e-7>s->fitness)
			break;
		else{
			local_optima=s->fitness;
			intra_route_optimization();
		}
		if(ceil((clock() - I_data->start)/static_cast<double>(CLOCKS_PER_SEC))>=time_length)
			break;
	}
	for (int i=0;i<=v_num-1;i++){
		for (int j=0;j<=num_v;j++){
			b_s->sol[i][j]=s->sol[i][j];
			b_s->sol_r[i][j]=s->sol_r[i][j];
		}
		b_s->fit_tour[i]=s->fit_tour[i];
	}
	b_s->fitness=s->fitness;
}













































///////////////////////////////////////////////////////////////////////weak perturbation





void LS:: cross_exchange_tabu(){
	int pointer;improve=0;
	for (int i=0;i<=v_num-1;i++){
		pointer=s->sol[i][0];
		while (pointer!=0){
			s_t[pointer]=i;
			pointer=s->sol[i][pointer];
		}
	}
	double delta;int in_num;int rand_order;
	int end2,end1;int iden1,iden2;
	int better_move[6];
	int reverse;
	double max_fitness;	int pt;int longest_third;

	double min_delta,min_tabu_delta;
	int can_node[100][6];
	int can_tabu_node[100][6];
	int num_best;
	int num_tabu_best;
	while (1){
		max_fitness=0;
		for (int i=0;i<=v_num-1;i++)
			if (s->fit_tour[i]>max_fitness){
				max_fitness=s->fit_tour[i];
				ot=i;
			}
		min_delta=Max;
		min_tabu_delta=Max;
		num_best=0;
		num_tabu_best=0;
		for (int i=0;i<=v_num-1;i++){
			if (ot==i)continue;
			pointer=s->sol[i][0];
			longest_third=-1;
			for (int j=0;j<=v_num-1;j++){
				if (j!=ot && j!=i && longest_third==-1)
					longest_third=j;
				if (longest_third>-1 && j!=ot && j!=i && s->fit_tour[longest_third]<s->fit_tour[j])
					longest_third=j;
			}
			while(1){
				if (pointer==0 )break;
				else{
					pt=0;
					while(1){
						in_num=-1;
						pt=s->sol[ot][pt];
						if (pt==0)break;
						if (I_data->edge[pt][pointer]==0)
							continue;
						in_num=pt;
						if (in_num==-1)continue;
						if (1){// case 1
							iden1=0;end1=pointer;
							for (int k=0;k<=length_s-1;k++){// carry the out row
								reverse=1;
								if (k>0){
									end1=s->sol[i][end1];
								}
								if (end1==0 || iden1==1)break;//
								iden2=0;
								end2=in_num;
								if (s->sol_r[s_t[in_num]][in_num]==0 && end2==in_num && s->sol[s_t[in_num]][in_num]==0)
									break;
								for (int n=0;n<=length_s-1;n++){////////////////////////////////////////////////////
									if (n==1){// determine the right or left
										if (s->sol[s_t[in_num]][in_num]==0)reverse=0;//
										if (s->sol_r[s_t[in_num]][in_num]==0)reverse=1;//
										if (s->sol_r[s_t[in_num]][in_num]!=0 && s->sol[s_t[in_num]][in_num]!=0){
											if (gain_fun(pointer,end1,in_num,s->sol[s_t[in_num]][in_num],k,1,longest_third)<
												gain_fun(pointer,end1,in_num,s->sol_r[s_t[in_num]][in_num],k,0,longest_third))
												reverse=1;
											else
												reverse=0;
										}
									}
									if (reverse==1 && n!=0){
										end2=s->sol[s_t[end2]][end2];
									}
									if (reverse==0 && n!=0){
										end2=s->sol_r[s_t[end2]][end2];
									}



									if (end2==0 || iden2==1 )break;
									if ((reverse==1 && s->sol[s_t[end2]][end2]==0 && s->sol_r[s_t[end2]][in_num]==0))
										break;
									if (reverse==0 && s->sol_r[s_t[end2]][end2]==0 && s->sol[s_t[end2]][in_num]==0)
										break;




									delta=gain_fun(pointer,end1,in_num,end2,k,reverse,longest_third);

									if ((end1==0 && tabu_table[i][end2]<=iteration)
										|| (tabu_table[i][end2]<=iteration && tabu_table[s_t[end2]][end1]<=iteration)){
										if (delta<min_delta){
											min_delta=delta;
											can_node[0][0]=pointer;
											can_node[0][1]=end1;
											can_node[0][2]=in_num;
											can_node[0][3]=end2;
											can_node[0][4]=reverse;
											can_node[0][5]=i;
											num_best=1;
										}
										else if (min_delta+1.0e-7>delta && min_delta-1.0e-7<delta && num_best<100){
											can_node[num_best][0]=pointer;
											can_node[num_best][1]=end1;
											can_node[num_best][2]=in_num;
											can_node[num_best][3]=end2;
											can_node[num_best][4]=reverse;
											can_node[num_best][5]=i;
											num_best++;
										}
									}
									else{
										if (min_tabu_delta>delta){
											min_tabu_delta=delta;
											can_tabu_node[0][0]=pointer;
											can_tabu_node[0][1]=end1;
											can_tabu_node[0][2]=in_num;
											can_tabu_node[0][3]=end2;
											can_tabu_node[0][4]=reverse;
											can_tabu_node[0][5]=i;
											num_tabu_best=1;
										}
										else if (min_tabu_delta+1.0e-7>delta && min_tabu_delta-1.0e-7<delta && num_tabu_best<100){
											min_tabu_delta=delta;
											can_tabu_node[num_tabu_best][0]=pointer;
											can_tabu_node[num_tabu_best][1]=end1;
											can_tabu_node[num_tabu_best][2]=in_num;
											can_tabu_node[num_tabu_best][3]=end2;
											can_tabu_node[num_tabu_best][4]=reverse;
											can_tabu_node[num_tabu_best][5]=i;
											num_tabu_best++;
										}
									}
								}
							}
						}
					}
				}
				pointer=s->sol[i][pointer];
				if (pointer==0)break;
			}
		}
		if (num_tabu_best==0 && num_best==0)
			break;
		if ((num_tabu_best>0 && min_tabu_delta+1.0e-7>min_delta && (s->fitness-min_tabu_delta - 1.0e-7 <b_s->fitness)) || num_best==0){
//			s->fitness=s->fitness-min_tabu_delta;
			rand_order=rand()%num_tabu_best;
			better_move[0]=can_tabu_node[rand_order][0];
			better_move[1]=can_tabu_node[rand_order][1];
			better_move[2]=can_tabu_node[rand_order][2];
			better_move[3]=can_tabu_node[rand_order][3];
			better_move[4]=can_tabu_node[rand_order][4];
			better_move[5]=can_tabu_node[rand_order][5];
		}
		else{
//			s->fitness=s->fitness-min_delta;
			rand_order=rand()%num_best;
			better_move[0]=can_node[rand_order][0];
			better_move[1]=can_node[rand_order][1];
			better_move[2]=can_node[rand_order][2];
			better_move[3]=can_node[rand_order][3];
			better_move[4]=can_node[rand_order][4];
			better_move[5]=can_node[rand_order][5];
		}
		record_table[better_move[5]]=1;
		record_table[s_t[better_move[2]]]=1;
		replace_fun(better_move);
		double costtt=b_s->fitness;
		if (s->fitness+1.0e-7<b_s->fitness){
			update_best_solution();
			improve=0;iteration_c=iteration;
			supply_edge();
		}
		else
			improve++;
		if (improve>threshold)
			break;
		iteration++;
		double fitness=0; double fitness_tem;
		for (int i=0;i<=v_num-1;i++){
			pointer=0;
			fitness_tem=0;
			while(1){
				fitness_tem+=I_data->Distance[pointer][s->sol[i][pointer]];
				pointer=s->sol[i][pointer];
				if (pointer==0)
					break;
			}
			if (fitness<fitness_tem)
				fitness=fitness_tem;
		}
		if(ceil((clock() - I_data->start)/static_cast<double>(CLOCKS_PER_SEC))>=time_length)
			break;
	}
//	for (int i=0;i<=v_num-1;i++){
//		for (int j=0;j<=num_v;j++){
//			s->sol[i][j]=b_s->sol[i][j];
//			s->sol_r[i][j]=b_s->sol_r[i][j];
//		}
//		s->fit_tour[i]=b_s->fit_tour[i];
//	}
//	s->fitness=b_s->fitness;
}



void LS::insert_tabu(){
	int pointer;improve=0;
	int pointer_2;
	int longest_tour=0;
	int longest_third;
	double delta;
	int row_out,city_out,row_in,city_in;
	int can_node[100][4];
	int can_tabu_node[100][4];
	double min_delta,min_tabu_delta;
	int num_best,num_tabu_best;
	for (int i=1;i<=v_num-1;i++){// determine the longest tour;
		if (s->fit_tour[longest_tour]<s->fit_tour[i])
			longest_tour=i;
	}
	while(1){
		min_delta=Max;min_tabu_delta=Max;num_best=0;num_tabu_best=0;
		pointer=0;
		if (s->sol[longest_tour][s->sol[longest_tour][pointer]]==0){
			I_data->determing_longest=1;
			return;
		}
		while(1){// loop for the longest tour
			pointer=s->sol[longest_tour][pointer];// this is the first city in longest tour;
			if (pointer==0)break;
			for (int i=0;i<=v_num-1;i++){
				if (i==longest_tour)continue;// not overlap
				//
				longest_third=-1;
				for (int j=0;j<=v_num-1;j++){
					if (j!=longest_tour && j!=i && longest_third==-1)
						longest_third=j;
					if (longest_third>-1 && j!=longest_tour && j!=i && s->fit_tour[longest_third]<s->fit_tour[j])
						longest_third=j;
				}
				pointer_2=0;
				while(1){
					/////////////////////////////////////////////////////////////////
					if (I_data->edge[pointer][pointer_2]!=1){
						pointer_2=s->sol[i][pointer_2];
						if (pointer_2==0)break;
						else continue;
					}
					///////////////////////////////////////////////////////////////////
					delta=calculate_fit_insert(longest_tour,pointer,i,pointer_2,longest_third);
					if (tabu_table[i][pointer]<iteration){
						if (delta<min_delta){
							min_delta=delta;
							can_node[0][0]=longest_tour;
							can_node[0][1]=pointer;
							can_node[0][2]=i;
							can_node[0][3]=pointer_2;
							num_best=1;
						}
						else if (min_delta+1.0e-7>delta && min_delta-1.0e-7<delta && num_best<100){
							can_node[num_best][0]=longest_tour;
							can_node[num_best][1]=pointer;
							can_node[num_best][2]=i;
							can_node[num_best][3]=pointer_2;
							num_best++;
						}
					}
					else{
						if (min_tabu_delta>delta){
							min_tabu_delta=delta;
							can_tabu_node[0][0]=longest_tour;
							can_tabu_node[0][1]=pointer;
							can_tabu_node[0][2]=i;
							can_tabu_node[0][3]=pointer_2;
							num_tabu_best=1;
						}
						else if (min_tabu_delta+1.0e-7>delta && min_tabu_delta-1.0e-7<delta && num_tabu_best<100)
						{
							can_tabu_node[num_tabu_best][0]=longest_tour;
							can_tabu_node[num_tabu_best][1]=pointer;
							can_tabu_node[num_tabu_best][2]=i;
							can_tabu_node[num_tabu_best][3]=pointer_2;
							num_tabu_best++;
						}
					}
					pointer_2=s->sol[i][pointer_2];
					if (pointer_2==0)break;
				}
			}
		}
		int rand_order;double delta_tabu;
		if ((num_tabu_best>0 && min_tabu_delta+1.0e-7<min_delta && (s->fitness+min_tabu_delta+1.0e-7 <b_s->fitness))|| num_best==0){
			rand_order=rand()%num_tabu_best;
			delta_tabu=min_tabu_delta;
			row_out=can_tabu_node[rand_order][0];
			city_out=can_tabu_node[rand_order][1];
			row_in=can_tabu_node[rand_order][2];
			city_in=can_tabu_node[rand_order][3];
		}
		else{
			rand_order=rand()%num_best;
			delta_tabu=min_delta;
			row_out=can_node[rand_order][0];
			city_out=can_node[rand_order][1];
			row_in=can_node[rand_order][2];
			city_in=can_node[rand_order][3];
		}
		tabu_table[row_out][city_out]=iteration + tabu_l+rand()%tabu_l;
		longest_tour=replace_fun_insert(delta_tabu,row_out,city_out,row_in,city_in);
		record_table[row_out]=1;
		record_table[row_in]=1;
		double costtt=b_s->fitness;
		if (s->fitness+1.0e-7<b_s->fitness){
			update_best_solution();
			supply_edge();
			improve=0;iteration_c=iteration;
		}
		else
			improve++;

		if (improve>threshold)
			break;
		iteration++;

		if(ceil((clock() - I_data->start)/static_cast<double>(CLOCKS_PER_SEC))>=time_length)
			break;
	}
}


void LS:: weak_perturb(){
	reverse_fun();// get value for sol_r;
	for (int i=0;i<=v_num-1;i++)
		for (int j=0;j<=num_v;j++)
			if (tabu_table[i][j]>0)
				tabu_table[i][j]=0;
	iteration=1;
	double local_optima=s->fitness;
	int no_imrpove=0;
	int step=0;
	while(1){
		if(ceil((clock() - I_data->start)/static_cast<double>(CLOCKS_PER_SEC))>=time_length)
			break;

		insert_tabu();
		iteration+=tabu_l*2;
		cross_exchange_tabu();

		iteration+=tabu_l*2;
//		for (int i=0;i<=v_num-1;i++)
//			record_table[i]=1;
		intra_route_optimization();


		if (s->fitness+1.0e-7<b_s->fitness)
			update_best_solution();


		if (local_optima+1.0e-7>b_s->fitness && local_optima-1.0e-7<b_s->fitness)
			no_imrpove++;
		else{
			local_optima=b_s->fitness;no_imrpove=0;
		}
		step++;
//		if (no_imrpove>50)break;
		cout<<step<<"   "<<b_s->fitness<<"   "<<s->fitness<<"    "<<no_imrpove<<endl;
		if (step==200)
			cout<<ceil((clock() - I_data->start)/static_cast<double>(CLOCKS_PER_SEC))<<endl;
	}
}

The file LS.h contains:
/*
 * LS.h
 *
 *  Created on: 18 Apr 2020
 *      Author: Peng
 */

#ifndef LS_H_
#define LS_H_
#include "Individual.h"
#include "read_data.h"
#include "Tstwoopt.h"
#include "environment.h"
class LS {
public:
	// methods
	LS(read_data * data);
	virtual ~LS();
	void local_search();
	void weak_perturb();
	// variables
	Individual* s;
	Individual*b_s;
	Individual * tem;
	read_data * I_data;
	Tstwoopt * each_route;
	TEnvironment * gEnv;
	int time_length;

private:
	void update_best_solution();
	void reverse_fun();
	void intra_route_optimization();
	void inter_route_optimization();
	// the methods for inter-routing methods 3
	double gain_fun(int st1,int end1,int st2,int end2,int k, int reverse,int longest_third);
	void replace_fun(int *move);
	void cross_exchange_1();
	void cross_exchange_tabu();
//	void swap();
//	void swap_tabu();
	void calculate_fit(int st1,int end1,int st2,int end2,int k, int reverse);
	void insert_tabu();
	void insert();
	int replace_fun_insert(double min_delta,int row_out,int city_out,int row_in,int city_in);
	double calculate_fit_insert(int row_out,int city_out,int row_in,int city_in,int longest_third);
	void supply_edge();
//	double calculate_fit_swap(int row_out,int city_out,int row_in,int city_in,int longest_third);
//	int replace_fun_swap(double min_delta,int row_out,int city_out,int row_in,int city_in);






	// general variables
	int num_v;
	int v_num;
	int* record_table;
	int * s_t;// this variable is used to record cities are belonged to which routes during in searching
	// variables for inter-routing methods 3
	int ** cand_str1;
	int ** cand_str2;
	double * cand_fit;
	int **near_cand1;
	double *near_fit;
	int *rever_list;
	int ot;// to record the best route;
	// variables for tabu search.
	int iteration;
	int ** tabu_table;
	int **tabu_table_c;
	int iteration_c;
	int improve;
	//
	int **t_t_swap;



};
#endif /* LS_H_ */





/* void LS::swap_tabu(){
	int pointer;improve=0;
	int pointer_2;
	int longest_tour=0;
	int longest_third;
	double delta,delta_tabu;
	int row_out,city_out,row_in,city_in;
	int can_node[100][4];
	int can_tabu_node[100][4];
	double min_delta,min_tabu_delta;
	int num_best,num_tabu_best;
	int rand_order;
	int i,j;
	for ( i=1;i<=v_num-1;i++){// determine the longest tour;
		if (s->fit_tour[longest_tour]<s->fit_tour[i])
			longest_tour=i;
	}
	while (1){
		min_delta=Max;min_tabu_delta=Max;
		pointer=0;
		if (s->sol[longest_tour][s->sol[longest_tour][pointer]]==0){
			I_data->determing_longest=1;
			return;
		}
		while(1){
			pointer=s->sol[longest_tour][pointer];
			if (pointer==0)break;
			for ( i=0;i<=v_num-1;i++){
				if (i==longest_tour)continue;
				longest_third=-1;
				for ( j=0;j<=v_num-1;j++){
					if (j!=longest_tour && j!=i && longest_third==-1)
						longest_third=j;
					if (longest_third>-1 && j!=longest_tour && j!=i && s->fit_tour[longest_third]<s->fit_tour[j])
						longest_third=j;
				}
				pointer_2=s->sol[i][0];
				while(1){
					delta=calculate_fit_swap(longest_tour,pointer,i,pointer_2,longest_third);
					if (tabu_table[i][pointer]<iteration && tabu_table[longest_tour][pointer_2]<iteration){
						if (delta<min_delta){
							min_delta=delta;
							can_node[0][0]=longest_tour;
							can_node[0][1]=pointer;
							can_node[0][2]=i;
							can_node[0][3]=pointer_2;
							num_best=1;
						}
						else if (min_delta+1.0e-7>delta && min_delta-1.0e-7<delta && num_best<100){
							can_node[num_best][0]=longest_tour;
							can_node[num_best][1]=pointer;
							can_node[num_best][2]=i;
							can_node[num_best][3]=pointer_2;
							num_best++;
						}
					}
					else {
						if (min_tabu_delta>delta){
							min_tabu_delta=delta;
							can_tabu_node[0][0]=longest_tour;
							can_tabu_node[0][1]=pointer;
							can_tabu_node[0][2]=i;
							can_tabu_node[0][3]=pointer_2;
							num_tabu_best=1;
						}
						else if (min_tabu_delta+1.0e-7>delta && min_tabu_delta-1.0e-7<delta && num_tabu_best<100)
						{
							can_tabu_node[num_tabu_best][0]=longest_tour;
							can_tabu_node[num_tabu_best][1]=pointer;
							can_tabu_node[num_tabu_best][2]=i;
							can_tabu_node[num_tabu_best][3]=pointer_2;
							num_tabu_best++;
						}
					}
					pointer_2=s->sol[i][pointer_2];
					if (pointer_2==0)break;
				}
			}
		}
		if ((num_tabu_best>0 && min_tabu_delta+1.0e-7<min_delta && (s->fitness+min_tabu_delta+1.0e-7 <b_s->fitness))|| num_best==0){
			rand_order=rand()%num_tabu_best;
			delta_tabu=min_tabu_delta;
			row_out=can_tabu_node[rand_order][0];
			city_out=can_tabu_node[rand_order][1];
			row_in=can_tabu_node[rand_order][2];
			city_in=can_tabu_node[rand_order][3];
		}
		else{
			rand_order=rand()%num_best;
			delta_tabu=min_delta;
			row_out=can_node[rand_order][0];
			city_out=can_node[rand_order][1];
			row_in=can_node[rand_order][2];
			city_in=can_node[rand_order][3];
		}
		tabu_table[row_out][city_out]=iteration+tabu_l+rand()%tabu_l;
		tabu_table[row_in][city_in]=iteration+tabu_l+rand()%tabu_l;
		longest_tour=replace_fun_swap(delta_tabu,row_out,city_out,row_in,city_in);
		record_table[row_out]=1;
		record_table[row_in]=1;
		if (s->fitness+1.0e-7<b_s->fitness){
			update_best_solution();
			improve=0;iteration_c=iteration;
//			return;
		}
		else
			improve++;

		if (improve>threshold)
			return;
		iteration++;
//		cout<<min_delta<<endl;
	}
} */
/* void LS::swap(){
	int pointer;
	int pointer_2;
	int longest_tour=0;
	int longest_third;
	double delta,min_delta;
	int row_out,city_out,row_in,city_in;
	for (int i=1;i<=v_num-1;i++){// determine the longest tour;
		if (s->fit_tour[longest_tour]<s->fit_tour[i])
			longest_tour=i;
	}
	while (1){
		min_delta=Max;
		pointer=0;
		while(1){
			pointer=s->sol[longest_tour][pointer];
			if (pointer==0)break;
			for (int i=0;i<=v_num-1;i++){
				if (i==longest_tour)continue;
				longest_third=-1;
				for (int j=0;j<=v_num-1;j++){
					if (j!=longest_tour && j!=i && longest_third==-1)
						longest_third=j;
					if (longest_third>-1 && j!=longest_tour && j!=i && s->fit_tour[longest_third]<s->fit_tour[j])
						longest_third=j;
				}
				pointer_2=s->sol[i][0];
				while(1){
					delta=calculate_fit_swap(longest_tour,pointer,i,pointer_2,longest_third);
					if (delta<min_delta){
						min_delta=delta;
						row_out=longest_tour;
						city_out=pointer;
						row_in=i;
						city_in=pointer_2;
					}
					pointer_2=s->sol[i][pointer_2];
					if (pointer_2==0)break;
				}
			}
		}
		if (min_delta+1.0e-7>0)break;
		longest_tour=replace_fun_swap(min_delta,row_out,city_out,row_in,city_in);
		record_table[row_out]=1;
		record_table[row_in]=1;
//		cout<<min_delta<<endl;
	}
} */
/* double LS::calculate_fit_swap(int row_out,int city_out,int row_in,int city_in,int longest_third){
	double delta1=0;
	double delta2=0;
	delta1+=I_data->Distance[s->sol_r[row_out][city_out]][city_in]+I_data->Distance[city_in][s->sol[row_out][city_out]];
	delta1=delta1-I_data->Distance[s->sol_r[row_out][city_out]][city_out]-I_data->Distance[city_out][s->sol[row_out][city_out]];
	//
	delta2+=I_data->Distance[s->sol_r[row_in][city_in]][city_out]+I_data->Distance[s->sol[row_in][city_in]][city_out];
	delta2=delta2-I_data->Distance[s->sol_r[row_in][city_in]][city_in]-I_data->Distance[s->sol[row_in][city_in]][city_in];
	//
	delta1=s->fit_tour[row_out]+delta1;
	delta2=s->fit_tour[row_in]+delta2;
	double delta=delta1;
	if (delta<delta2)
		delta=delta2;
	if (delta<s->fit_tour[longest_third])
		delta=s->fit_tour[longest_third];
	delta=delta-s->fitness;
	return delta;
}
int LS::replace_fun_swap(double min_delta,int row_out,int city_out,int row_in,int city_in){
	double delta1=0;
	double delta2=0;
	delta1+=I_data->Distance[s->sol_r[row_out][city_out]][city_in]+I_data->Distance[city_in][s->sol[row_out][city_out]];
	delta1=delta1-I_data->Distance[s->sol_r[row_out][city_out]][city_out]-I_data->Distance[city_out][s->sol[row_out][city_out]];
	//
	delta2+=I_data->Distance[s->sol_r[row_in][city_in]][city_out]+I_data->Distance[s->sol[row_in][city_in]][city_out];
	delta2=delta2-I_data->Distance[s->sol_r[row_in][city_in]][city_in]-I_data->Distance[s->sol[row_in][city_in]][city_in];
	//
	s->fit_tour[row_out]=s->fit_tour[row_out]+delta1;
	s->fit_tour[row_in]=s->fit_tour[row_in]+delta2;
	int longest_tour=0;
	for (int i=1;i<=v_num-1;i++)
		if (s->fit_tour[i]>s->fit_tour[longest_tour])
			longest_tour=i;
	s->fitness=s->fit_tour[longest_tour];
	//
	int p_p,n_p;
	p_p=s->sol_r[row_out][city_out];
	n_p=s->sol[row_out][city_out];
	s->sol[row_out][p_p]=city_in;
	s->sol[row_out][city_in]=n_p;
	s->sol[row_out][city_out]=-1;
	s->sol_r[row_out][n_p]=city_in;
	s->sol_r[row_out][city_in]=p_p;
	s->sol_r[row_out][city_out]=-1;
	//
	p_p=s->sol_r[row_in][city_in];
	n_p=s->sol[row_in][city_in];
	s->sol[row_in][p_p]=city_out;
	s->sol[row_in][city_out]=n_p;
	s->sol[row_in][city_in]=-1;
	s->sol_r[row_in][n_p]=city_out;
	s->sol_r[row_in][city_out]=p_p;
	s->sol_r[row_in][city_in]=-1;
	return longest_tour;
} */

The file main.cpp contains:
/*
 * main.cpp
 *
 *  Created on: 17 Apr 2020
 *      Author: Peng
 */
#include"solution.h"
#include"basic.h"
int main(int argc, char*argv[]){
	if (argc!=5){
		cout << "the input parameters in configuration are wrong" << endl;	return 1;
	}
	int rand_num;
	int time_length;
	int num_v;
	sscanf(argv[2],"%d",&num_v);
	sscanf(argv[3],"%d",&time_length);
	sscanf(argv[4],"%d",&rand_num);
	solution* sol=new solution();// assign a new object for class solution.
	sol->define(argv[1],num_v,time_length);// initialization all data and assigning memory
	srand(rand_num);
	sol->main_loop(rand_num);// in this place the running time could be input
	delete sol;
	return 0;
}

The file Makefile contains:
# test.cpp tabu_search.cpp basic.h
tar = ils
obj = cross.o perturb.o environment.o evaluator.o indi.o Individual.o kopt.o LS.o randomize.o sort.o EAX.o LS.o read_data.o Tstwoopt.o initialsol.o solution.o main.o
deps = cross.h perturb.h environment.h evaluator.h indi.h Individual.h kopt.h LS.h randomize.h sort.h EAX.h LS.h  read_data.h Tstwoopt.h initialsol.h solution.h basic.h
cc = g++
RMRF :=rm -rf

$(tar): $(obj)      # transfer to exe files
	$(cc) $^ -o $@
#test: tabu_search.o test.o
#	g++ tabu_search.o test.o -o test
%.o: %.c $(deps)    # head files
	$(cc) -c %.c -o %.o   # transfer a file
#test.o: test.cpp
#	g++ -c test.cpp -o test.o
#tabu_search.o: tabu_search.cpp
#	g++ -c tabu_search.cpp -o tabu_search.o

.PHONY:
clearall:
	$(RMRF) $(obj) $(tar)
clear:
	$(RMRF) $(obj) 
The file my-directory-list.txt contains:
The file basic.h contains:
/*
 * basic.h
 *
 *  Created on: 18 Apr 2020
 *      Author: Peng
 */

#ifndef BASIC_H_
#define BASIC_H_
#include<algorithm>
#include <vector>
#include<math.h>
#include <iostream>
#include <time.h>
#include <string.h>
#include <fstream>
using namespace std;
///////////////////////////////////////////////////////////////////////////////

#define Max 100000000

#define num_inital 20
#define num_near_nodes 10
#define length_s 7 // the length of each string, the actual value is length_s-1
#define tabu_l  20
#define threshold 50
#define alpha_num 10



#define num_prunning     100

#define control_para 300

#define Probability 400


#define cross_exchange_identify 2

// the parameters to select operators for intra-route and inter-route optimization in local search
#define intra_opt 3                // the number 1, 2 and 3    are 2-opt, tabu search and EAX, respectively
#define inter_opt 3          // the number 1, 2 and 3 are insert operators, solution based tabu search and cross-exchange
#define perturbation_method 2


#endif /* BASIC_H_ */

The file cross.cpp contains:
/*
 * cross.cpp
 *   created on: April 24, 2013
 * last updated: June 13, 2013
 *       author: liushujia
 */

#ifndef __Cross__
#include "cross.h"
#endif

TCross::TCross( int N ){
	fMaxNumOfABcycle = 2000;	// 设置适当的值(2000)
	total_fN = N;
//	tBestTmp.define( total_fN );
	nearData = new int* [ total_fN ];
	for ( int j = 0; j < total_fN; ++j ) nearData[j] = new int [ 5 ];

	fABcycle = new int* [ fMaxNumOfABcycle ];
	for ( int j = 0; j < fMaxNumOfABcycle; ++j ) fABcycle[j] = new int [ 2*total_fN + 4 ];

	koritsu = new int [ total_fN ];
	bunki = new int [ total_fN ];
	koriInv = new int [ total_fN ];
	bunInv = new int [ total_fN ];
	checkKoritsu = new int [ total_fN ];
	fRoute = new int [ 2*total_fN + 1 ];
	fPermu = new int [ fMaxNumOfABcycle ];

	fC = new int [ 2*total_fN+4 ];
	fJun = new int[ total_fN+ 1 ];
	fOrd1 = new int [ total_fN ];
	fOrd2 = new int [ total_fN ];

	// Speed Up Start
	fOrder = new int [ total_fN ];
	fInv = new int [ total_fN ];
	fSegment = new int* [ total_fN ];
	for ( int j = 0; j < total_fN; ++j ) fSegment[ j ] = new int [ 2 ];

	fSegUnit = new int [ total_fN ];
	fSegPosiList = new int[ total_fN ];
	LinkAPosi = new int [ total_fN ];
	LinkBPosi = new int* [ total_fN ];
	for ( int j = 0; j < total_fN; ++j ) LinkBPosi[ j ] = new int [ 2 ];

	fPosiSeg = new int [ total_fN ];
	fNumOfElementInUnit = new int [ total_fN ];
	fCenterUnit = new int [ total_fN ];
	for ( int j = 0; j < total_fN; ++j ) fCenterUnit[ j ] = 0;

	fListOfCenterUnit = new int [ total_fN+2 ];
	fSegForCenter = new int [ total_fN ];
	fGainAB = new double [ total_fN ];
	//fGainAB = new int [ fN ];
	fModiEdge = new int* [ total_fN ];
	for ( int j = 0; j < total_fN; ++j ) fModiEdge[ j ] = new int [ 4 ];

	fBestModiEdge = new int* [ total_fN ];
	for ( int j = 0; j < total_fN; ++j ) fBestModiEdge[ j ] = new int [ 4 ];

	fAppliedCylce = new int [ total_fN ];
	fBestAppliedCylce = new int [ total_fN ];
	// Speed Up End

	// Block2
	fNumOfElementINAB = new int [ fMaxNumOfABcycle ];
	fInEffectNode = new int* [ total_fN ];
	for( int i = 0; i < total_fN; ++i ) fInEffectNode[ i ] = new int [ 2 ];

	fWeightRR = new int* [ fMaxNumOfABcycle ];
	for( int i = 0; i < fMaxNumOfABcycle; ++i ) fWeightRR[ i ] = new int [ fMaxNumOfABcycle ];

	fWeightSR = new int [ fMaxNumOfABcycle ];
	fWeightC = new int [ fMaxNumOfABcycle ];
	fUsedAB = new int [ total_fN ];
	fMovedAB = new int [ total_fN ];
	fABcycleInEset = new int [ fMaxNumOfABcycle ];
}

TCross::~TCross()
{
	delete [] koritsu;
	delete [] bunki;
	delete [] koriInv;
	delete [] bunInv;
	delete [] checkKoritsu;
	delete [] fRoute;
	delete [] fPermu;
	for ( int j = 0; j < total_fN; ++j ) delete[] nearData[ j ];

	delete[] nearData;
	for ( int j = 0; j < fMaxNumOfABcycle; ++j ) delete[] fABcycle[ j ];

	delete[] fABcycle;
	delete [] fC;
	delete [] fJun;
	delete [] fOrd1;
	delete [] fOrd2;

	// Speed Up Start
	delete [] fOrder;
	delete [] fInv;

	for ( int j = 0; j < total_fN; ++j ) delete[] fSegment[ j ];

	delete[] fSegment;
	delete[] fSegUnit;
	delete [] fSegPosiList;
	delete [] LinkAPosi;
	for ( int j = 0; j < total_fN; ++j ) delete[] LinkBPosi[ j ];

	delete [] LinkBPosi;
	delete [] fPosiSeg;
	delete [] fNumOfElementInUnit;
	delete [] fCenterUnit;
	delete [] fListOfCenterUnit;
	delete [] fSegForCenter;
	delete [] fGainAB;

	for ( int j = 0; j < total_fN; ++j ) delete[] fModiEdge[ j ];
	delete [] fModiEdge;
	for ( int j = 0; j < total_fN; ++j ) delete[] fBestModiEdge[ j ];
	delete [] fBestModiEdge;

	delete [] fAppliedCylce;
	delete [] fBestAppliedCylce;
	// Speed Up End

	// Block2
	delete [] fNumOfElementINAB;
	for ( int j = 0; j < total_fN; ++j ) delete [] fInEffectNode[ j ];

	delete [] fInEffectNode;
	for( int i = 0; i < fMaxNumOfABcycle; ++i ) delete [] fWeightRR[ i ];
	delete [] fWeightRR;
	
	delete [] fWeightSR;
	delete [] fWeightC;
	delete [] fUsedAB;
	delete [] fMovedAB;
	delete [] fABcycleInEset;
//	delete eval;
}

void TCross::input_data(int N)
{
	fN=N;
}
void TCross::setParents( const TIndi& tPa1, const TIndi& tPa2, int flagC[ 10 ], int numOfKids ){
	this->setABcycle( tPa1, tPa2, flagC, numOfKids );
	fDisAB = 0;
	int curr, next, st, pre;
	st = 0;
	curr=-1;
	next = st;
	for( int i = 0; i < fN; ++i ){
		pre=curr;
		curr=next;
		if( tPa1.fLink[curr][0] != pre ) next = tPa1.fLink[ curr ][ 0 ];
		else next=tPa1.fLink[curr][1];

		if( tPa2.fLink[ curr ][ 0 ] != next && tPa2.fLink[ curr ][ 1 ] != next ) ++fDisAB;
		fOrder[ i ] = curr;
		fInv[ curr ] = i;
	}
	if( flagC[ 1 ] == 2 ){
		fTmax = 10;
		fMaxStag = 20;                 //1:Greedy LS, 20:Tabu Search
		this->setWeight( tPa1, tPa2 );
	}
}

void TCross::doIt( TIndi& tKid, TIndi& tPa2, int numOfKids, int flagP, int flagC[ 10 ], int **fEdgeFreq ){
	int Num;
	int jnum, centerAB;
	//int gain;
	double gain;
	//int BestGain;
	double BestGain;
	double pointMax, point;
	double DLoss;

	fEvalType = flagC[ 0 ];              //1:Greedy, 2:---, 3:Distance, 4:Entropy
	fEsetType = flagC[ 1 ];              //1:Single-AB, 2:Block2

	if ( numOfKids <= fNumOfABcycle ) Num = numOfKids;
	else Num = fNumOfABcycle;

	if( fEsetType == 1 )		// Single-AB
	tRand->permutation( fPermu, fNumOfABcycle, fNumOfABcycle );

	else if( fEsetType == 2 ){  // Block2
		for( int k =0; k< fNumOfABcycle; ++k ) fNumOfElementINAB[ k ] = fABcycle[ k ][ 0 ];
		tSort->indexB( fNumOfElementINAB, fNumOfABcycle, fPermu, fNumOfABcycle );
	}
	fNumOfGeneratedCh = 0;
	pointMax = 0.0;
	BestGain = 0.0;
	fFlagImp = 0;
	for( int j =0; j < Num; ++j ){
		fNumOfABcycleInEset = 0;
		if( fEsetType == 1 ){         //Single-AB
			jnum = fPermu[ j ];
			fABcycleInEset[ fNumOfABcycleInEset++ ] = jnum;
		}
		else if( fEsetType == 2 ){    //Block2
			jnum = fPermu[ j ];
			centerAB = jnum;
			for( int s = 0; s < fNumOfABcycle; ++s ){
				if( s == centerAB ) fABcycleInEset[ fNumOfABcycleInEset++ ] = s;
				else{
					if( fWeightRR[ centerAB ][ s ] > 0 && fABcycle[ s ][ 0 ] < fABcycle[ centerAB ][ 0 ] )
					if( rand() %2 == 0 ) fABcycleInEset[ fNumOfABcycleInEset++ ] = s;
				}
			}
		this->searchEset( centerAB );
		}
		fNumOfSPL = 0;
		gain = 0.0;
		fNumOfAppliedCycle = 0;
		fNumOfModiEdge = 0;

		fNumOfAppliedCycle = fNumOfABcycleInEset;
		for( int k = 0; k < fNumOfAppliedCycle; ++k ){
			fAppliedCylce[ k ] = fABcycleInEset[ k ];
			jnum = fAppliedCylce[ k ];
			this->changeSol( tKid, jnum, flagP );
			gain += fGainAB[ jnum ];
		}

		this->makeUnit();
		this->makeCompleteSol( tKid );
		gain += fGainModi;

		++fNumOfGeneratedCh;

		if( fEvalType == 1 ) DLoss = 1.0;									//Greedy
		else if( fEvalType == 3 ) DLoss = this->calAdpLoss( fEdgeFreq );	// Distance preservation
		else if( fEvalType == 4 ) DLoss = this->calEntLoss( fEdgeFreq );	// Entropy preservation

		if( DLoss <= 0.0 ) DLoss = 0.00000001;

		point = (double)gain / DLoss;
		tKid.fEvaluationValue = tKid.fEvaluationValue - gain;

		if( pointMax < point && (2 * fBestNumE < fDisAB || tKid.fEvaluationValue != tPa2.fEvaluationValue ) ){
			pointMax = point;
			BestGain = gain;
			fFlagImp = 1;

			fNumOfBestAppliedCycle = fNumOfAppliedCycle;
			for( int s = 0; s < fNumOfBestAppliedCycle; ++s ) fBestAppliedCylce[ s ] = fAppliedCylce[ s ];

			fNumOfBestModiEdge = fNumOfModiEdge;
			for( int s = 0; s < fNumOfBestModiEdge; ++s ){
				fBestModiEdge[ s ][ 0 ] = fModiEdge[ s ][ 0 ];
				fBestModiEdge[ s ][ 1 ] = fModiEdge[ s ][ 1 ];
				fBestModiEdge[ s ][ 2 ] = fModiEdge[ s ][ 2 ];
				fBestModiEdge[ s ][ 3 ] = fModiEdge[ s ][ 3 ];
			}

		}
		this->backToPa1( tKid );
		tKid.fEvaluationValue = tKid.fEvaluationValue + gain;
	}
	if( fFlagImp == 1 ){
		this->goToBest( tKid );
		tKid.fEvaluationValue = tKid.fEvaluationValue - BestGain;
		this->incrementEdgeFreq( fEdgeFreq );
	}
}

void TCross::setABcycle( const TIndi& tPa1, const TIndi& tPa2, int flagC[ 10 ], int numOfKids ){
	bunkiMany=0; koritsuMany=0;
	for( int j = 0; j < fN ; ++j ){
		nearData[j][1]=tPa1.fLink[j][0];
		nearData[j][3]=tPa1.fLink[j][1];
		nearData[j][0] = 2;

		koritsu[koritsuMany]=j;
		koritsuMany++;

		nearData[j][2]=tPa2.fLink[j][0];
		nearData[j][4]=tPa2.fLink[j][1];
	}
	for(int j = 0; j < fN; ++j ){
		checkKoritsu[j]=-1;
		koriInv[koritsu[j]]=j;
	}
	fNumOfABcycle=0;
	flagSt=1;
	while(koritsuMany!=0){
		if(flagSt==1){
			fPosiCurr=0;
			r=rand()%koritsuMany;
			st=koritsu[r];
			checkKoritsu[st]=fPosiCurr;
			fRoute[fPosiCurr]=st;
			ci=st;
			prType=2;
		}
		else if(flagSt==0) ci=fRoute[fPosiCurr];

		flagCycle=0;
		while(flagCycle==0){
			fPosiCurr++;
			pr=ci;
			switch(prType){
			case 1:
				ci=nearData[pr][fPosiCurr%2+1];
			break;
			case 2:
				r=rand()%2;
				ci=nearData[pr][fPosiCurr%2+1+2*r];
				if(r==0) this->swap(nearData[pr][fPosiCurr%2+1],nearData[pr][fPosiCurr%2+3]);
			break;
			case 3:
				ci=nearData[pr][fPosiCurr%2+3];
			}
			fRoute[fPosiCurr]=ci;
			if(nearData[ci][0]==2){
				if(ci==st){
					if(checkKoritsu[st]==0){
					if((fPosiCurr-checkKoritsu[st])%2==0){
						if(nearData[st][fPosiCurr%2+1]==pr) this->swap(nearData[ci][fPosiCurr%2+1],nearData[ci][fPosiCurr%2+3]);

						stAppear = 1;
						this->formABcycle();
						if( flagC[ 1 ] == 1 && fNumOfABcycle == numOfKids ) goto RETURN;
						if( fNumOfABcycle == fMaxNumOfABcycle ) goto RETURN;

						flagSt=0;
						flagCycle=1;
						prType=1;
					}
					else{
						this->swap(nearData[ci][fPosiCurr%2+1],nearData[ci][fPosiCurr%2+3]);
						prType=2;
					}
					checkKoritsu[st]=fPosiCurr;
					}
					else{
					stAppear = 2;
					this->formABcycle();
					if( flagC[ 1 ] == 1 && fNumOfABcycle == numOfKids ) goto RETURN;
					if( fNumOfABcycle == fMaxNumOfABcycle ) goto RETURN;

					flagSt=1;
					flagCycle=1;
					}
				}
				else if(checkKoritsu[ci]==-1) {
					checkKoritsu[ci]=fPosiCurr;
					if(nearData[ci][fPosiCurr%2+1]==pr) this->swap(nearData[ci][fPosiCurr%2+1],nearData[ci][fPosiCurr%2+3]);
					prType=2;
				}
				else if(checkKoritsu[ci]>0){
					this->swap(nearData[ci][fPosiCurr%2+1],nearData[ci][fPosiCurr%2+3]);
					if((fPosiCurr-checkKoritsu[ci])%2==0){
						stAppear = 1;
						this->formABcycle();
						if( flagC[ 1 ] == 1 && fNumOfABcycle == numOfKids ) goto RETURN;
						if( fNumOfABcycle == fMaxNumOfABcycle ) goto RETURN;

						flagSt=0;
						flagCycle=1;
						prType=1;
					}
					else{
						this->swap(nearData[ci][(fPosiCurr+1)%2+1],nearData[ci][(fPosiCurr+1)%2+3]);
						prType=3;
					}
				}
			}
			else if(nearData[ci][0]==1){
				if(ci==st){
					stAppear = 1;
					this->formABcycle();
					if( flagC[ 1 ] == 1 && fNumOfABcycle == numOfKids ) goto RETURN;
					if( fNumOfABcycle == fMaxNumOfABcycle ) goto RETURN;
					flagSt=1;
					flagCycle=1;
				}
				else prType=1;
			}
		}
	}
	while(bunkiMany!=0){
		fPosiCurr=0;
		r=rand()%bunkiMany;
		st=bunki[r];
		fRoute[fPosiCurr]=st;
		ci=st;

		flagCycle=0;
		while(flagCycle==0){
			pr=ci;
			fPosiCurr++;
			ci=nearData[pr][fPosiCurr%2+1];
			fRoute[fPosiCurr]=ci;
			if(ci==st){
				stAppear = 1;
				this->formABcycle();
				if( flagC[ 1 ] == 1 && fNumOfABcycle == numOfKids ) goto RETURN;
				if( fNumOfABcycle == fMaxNumOfABcycle ) goto RETURN;

				flagCycle=1;
			}
		}
	}
RETURN:
	if( fNumOfABcycle == fMaxNumOfABcycle ){
		printf( "fMaxNumOfABcycle(%d) must be increased\n", fMaxNumOfABcycle );
		exit( 1 );
	}
}

void TCross::formABcycle(){
	int j;
	int st_count;
	int edge_type;
	int st,ci, stock;
	int cem;
	double diff;
	//int diff;

	if(fPosiCurr%2==0) edge_type=1;
	else edge_type=2;
	st=fRoute[fPosiCurr];
	cem=0;
	fC[cem]=st;

	st_count=0;
	while(1){
		cem++;
		fPosiCurr--;
		ci=fRoute[fPosiCurr];
		if(nearData[ci][0]==2){
			koritsu[koriInv[ci]]=koritsu[koritsuMany-1];
			koriInv[koritsu[koritsuMany-1]]=koriInv[ci];
			koritsuMany--;
			bunki[bunkiMany]=ci;
			bunInv[ci]=bunkiMany;
			bunkiMany++;
		}
		else if(nearData[ci][0]==1){
			bunki[bunInv[ci]]=bunki[bunkiMany-1];
			bunInv[bunki[bunkiMany-1]]=bunInv[ci];
			bunkiMany--;
		}

		nearData[ci][0]--;
		if(ci==st) st_count++;
		if(st_count==stAppear) break;
		fC[cem]=ci;
	}

	if(cem==2) return;

	fABcycle[fNumOfABcycle][0]=cem;

	if(edge_type==2){
		stock=fC[0];
		for( int j=0;j<cem-1;j++) fC[j]=fC[j+1];
		fC[cem-1]=stock;
	}

	for( int j=0;j<cem;j++) fABcycle[fNumOfABcycle][j+2]=fC[j];

	fABcycle[fNumOfABcycle][1]=fC[cem-1];
	fABcycle[fNumOfABcycle][cem+2]=fC[0];
	fABcycle[fNumOfABcycle][cem+3]=fC[1];

	fC[ cem ] = fC[ 0 ];
	fC[ cem+1 ] = fC[ 1 ];
	diff = 0.0;
	for( j = 0; j < cem/2; ++j ) diff = diff + eval->fEdgeDis[fC[2*j]][fC[1+2*j]] - eval->fEdgeDis[fC[1+2*j]][fC[2+2*j]];

	fGainAB[fNumOfABcycle] = diff;
	++fNumOfABcycle;
}

void TCross::swap(int &x, int &y){
	int s=x;
	x=y;
	y=s;
}

void TCross::changeSol( TIndi& tKid, int ABnum, int type ){
	int j;
	int cem, r1, r2, b1, b2;
	int po_r1, po_r2, po_b1, po_b2;

	cem=fABcycle[ABnum][0];
	fC[0]=fABcycle[ABnum][0];

	if(type==2) for(j=0;j<cem+3;j++) fC[cem+3-j]=fABcycle[ABnum][j+1];
	else for(j=1;j<=cem+3;j++) fC[j]=fABcycle[ABnum][j];

	for(j=0;j<cem/2;j++){
		r1=fC[2+2*j];r2=fC[3+2*j];
		b1=fC[1+2*j];b2=fC[4+2*j];

		if(tKid.fLink[r1][0]==r2) tKid.fLink[r1][0]=b1;
		else tKid.fLink[r1][1]=b1;
		if(tKid.fLink[r2][0]==r1) tKid.fLink[r2][0]=b2;
		else tKid.fLink[r2][1]=b2;

		po_r1 = fInv[ r1 ];
		po_r2 = fInv[ r2 ];
		po_b1 = fInv[ b1 ];
		po_b2 = fInv[ b2 ];

		if( po_r1 == 0 && po_r2 == fN-1 ) fSegPosiList[ fNumOfSPL++ ] = po_r1;
		else if( po_r1 == fN-1 && po_r2 == 0 ) fSegPosiList[ fNumOfSPL++ ] = po_r2;
		else if( po_r1 < po_r2 ) fSegPosiList[ fNumOfSPL++ ] = po_r2;
		else if( po_r2 < po_r1 ) fSegPosiList[ fNumOfSPL++ ] = po_r1;

		LinkBPosi[ po_r1 ][ 1 ] = LinkBPosi[ po_r1 ][ 0 ];
		LinkBPosi[ po_r2 ][ 1 ] = LinkBPosi[ po_r2 ][ 0 ];
		LinkBPosi[ po_r1 ][ 0 ] = po_b1;
		LinkBPosi[ po_r2 ][ 0 ] = po_b2;
	}
}

void TCross::makeCompleteSol( TIndi& tKid ){
	int j, j1, j2;
	int st ,pre, curr, next, a, b, c, d, aa, bb, a1, b1;
	int min_unit_city;
	int center_un, select_un;
	double diff, max_diff;
	//int diff, max_diff;
	int near_num, nearMax;

	fGainModi = 0;
	while( fNumOfUnit != 1 ){
		min_unit_city = fN + 12345;
		for( int u = 0; u < fNumOfUnit; ++u )
			if( fNumOfElementInUnit[ u ] < min_unit_city ){
				center_un = u;
				min_unit_city = fNumOfElementInUnit[ u ];
			}


		st = -1;
		fNumOfSegForCenter = 0;
		for( int s = 0; s < fNumOfSeg; ++s )
			if( fSegUnit[ s ] == center_un ){
				int posi = fSegment[ s ][ 0 ];
				st = fOrder[ posi ];
				fSegForCenter[  fNumOfSegForCenter++ ] = s;
			}
		curr = -1;
		next = st;
		fNumOfElementInCU = 0;
		while(1){
			pre = curr;
			curr = next;
			fCenterUnit[ curr ] = 1;
			fListOfCenterUnit[ fNumOfElementInCU ] = curr;
			++fNumOfElementInCU;
			if( tKid.fLink[ curr ][ 0 ] != pre ) next = tKid.fLink[ curr ][ 0 ];
			else next = tKid.fLink[ curr ][ 1 ];
			if( next == st ) break;
		}
		fListOfCenterUnit[ fNumOfElementInCU ] = fListOfCenterUnit[ 0 ];
		fListOfCenterUnit[ fNumOfElementInCU+1 ] = fListOfCenterUnit[ 1 ];

		max_diff = -999999999;
		a1 = -1; b1 = -1;
		nearMax = 10;	// N_near
						// nearMax <= eva->fNearNumMax (kopt.cpp)

	RESTART:
		for( int s = 1; s <= fNumOfElementInCU; ++s ){
			a = fListOfCenterUnit[ s ];

			for( near_num = 1; near_num <= nearMax; ++near_num ){
				c = eval->fNearCity[ a ][ near_num ];
				if( fCenterUnit[ c ] == 0 ){
					for( j1 = 0; j1 < 2; ++j1 ){
						b = fListOfCenterUnit[ s-1+2*j1 ];
						for( j2 = 0; j2 < 2; ++j2 ){
							d = tKid.fLink[ c ][ j2 ];
							diff = eval->fEdgeDis[a][b] + eval->fEdgeDis[c][d] - eval->fEdgeDis[a][c] - eval->fEdgeDis[b][d];
							if( diff > max_diff ){
								aa = a; bb = b; a1 = c; b1 = d;
								max_diff = diff;
							}
							diff = eval->fEdgeDis[a][b] + eval->fEdgeDis[d][c] -
								eval->fEdgeDis[a][d] - eval->fEdgeDis[b][c];
							if( diff > max_diff ){
								aa = a; bb = b; a1 = d; b1 = c;
								max_diff = diff;
							}
						}
					}
				}
			}
		}

		if( a1 == -1 && nearMax == 10 ){
			nearMax = 50;
			goto RESTART;
		}
		else if( a1 == -1 && nearMax == 50  ){
			int r = rand() % ( fNumOfElementInCU - 1 );
			a = fListOfCenterUnit[ r ];
			b = fListOfCenterUnit[ r+1 ];
			for( j = 0; j < fN; ++j ){
				if( fCenterUnit[ j ] == 0 ){
					aa = a; bb = b;
					a1 = j;
					b1 = tKid.fLink[ j ][ 0 ];
					break;
				}
			}
			max_diff = eval->fEdgeDis[aa][bb] + eval->fEdgeDis[a1][b1] - eval->fEdgeDis[a][a1] - eval->fEdgeDis[b][b1];
		}

		if( tKid.fLink[aa][0] == bb ) tKid.fLink[aa][0]=a1;
		else tKid.fLink[aa][1] = a1;
		if( tKid.fLink[bb][0] == aa ) tKid.fLink[bb][0] = b1;
		else tKid.fLink[bb][1] = b1;
		if( tKid.fLink[a1][0] == b1 ) tKid.fLink[a1][0] = aa;
		else tKid.fLink[a1][1] = aa;
		if( tKid.fLink[b1][0] == a1 ) tKid.fLink[b1][0] = bb;
		else tKid.fLink[b1][1] = bb;

		fModiEdge[ fNumOfModiEdge ][ 0 ] = aa;
		fModiEdge[ fNumOfModiEdge ][ 1 ] = bb;
		fModiEdge[ fNumOfModiEdge ][ 2 ] = a1;
		fModiEdge[ fNumOfModiEdge ][ 3 ] = b1;
		++fNumOfModiEdge;

		fGainModi += max_diff;

		int posi_a1 = fInv[ a1 ];
		select_un = -1;
		for( int s = 0; s < fNumOfSeg; ++s )
			if( fSegment[ s ][ 0 ] <= posi_a1 && posi_a1 <=  fSegment[ s ][ 1 ] ){
				select_un = fSegUnit[ s ];
				break;
			}


		for( int s = 0; s < fNumOfSeg; ++s )
			if( fSegUnit[ s ] == select_un ) fSegUnit[ s ] = center_un;

		fNumOfElementInUnit[ center_un ] += fNumOfElementInUnit[ select_un ];

		for( int s = 0; s < fNumOfSeg; ++s )
			if( fSegUnit[ s ] == fNumOfUnit - 1 ) fSegUnit[ s ] = select_un;

		fNumOfElementInUnit[ select_un ] = fNumOfElementInUnit[ fNumOfUnit - 1 ];
		--fNumOfUnit;

		for( int s = 0; s < fNumOfElementInCU; ++s ){
			c = fListOfCenterUnit[ s ];
			fCenterUnit[ c ] = 0;
		}
	}
}

void TCross::makeUnit(){
	int flag = 1;
	for( int s = 0; s < fNumOfSPL; ++s ){
		if( fSegPosiList[ s ] == 0 ){
			flag = 0;
			break;
		}
	}
	if( flag == 1 ){
		fSegPosiList[ fNumOfSPL++ ] = 0;
		LinkBPosi[ fN-1 ][ 1 ]  = LinkBPosi[ fN-1 ][ 0 ];
		LinkBPosi[ 0 ][ 1 ] = LinkBPosi[ 0 ][ 0 ];
		LinkBPosi[ fN-1 ][ 0 ] = 0;
		LinkBPosi[ 0 ][ 0 ] = fN-1;
	}

	tSort->sort( fSegPosiList, fNumOfSPL );
	fNumOfSeg = fNumOfSPL;
	for( int s = 0; s < fNumOfSeg-1; ++s ){
		fSegment[ s ][ 0 ] = fSegPosiList[ s ];
		fSegment[ s ][ 1 ] = fSegPosiList[ s+1 ]-1;
	}

	fSegment[ fNumOfSeg-1 ][ 0 ] = fSegPosiList[ fNumOfSeg-1 ];
	fSegment[ fNumOfSeg-1 ][ 1 ] = fN - 1;

	for( int s = 0; s < fNumOfSeg; ++s ){
		LinkAPosi[ fSegment[ s ][ 0 ] ] = fSegment[ s ][ 1 ];
		LinkAPosi[ fSegment[ s ][ 1 ] ] = fSegment[ s ][ 0 ];
		fPosiSeg[ fSegment[ s ][ 0 ] ] = s;
		fPosiSeg[ fSegment[ s ][ 1 ] ] = s;
	}

	for( int s = 0; s < fNumOfSeg; ++s ) fSegUnit[ s ] = -1;
	fNumOfUnit = 0;

	int p_st, p1, p2, p_next, p_pre;
	int segNum;
	while(1){
		flag = 0;
		for( int s = 0; s < fNumOfSeg; ++s ){
			if( fSegUnit[ s ] == -1 ){
				p_st = fSegment[ s ][ 0 ];
				p_pre = -1;
				p1 = p_st;
				flag = 1;
				break;
			}
		}
		if( flag == 0 ) break;

		while(1){
			segNum = fPosiSeg[ p1 ];
			fSegUnit[ segNum ] = fNumOfUnit;

			p2 = LinkAPosi[ p1 ];
			p_next = LinkBPosi[ p2 ][ 0 ];
			if( p1 == p2 )
				if( p_next == p_pre ) p_next = LinkBPosi[ p2 ][ 1 ];

			if( p_next == p_st ){
				++fNumOfUnit;
				break;
			}

			p_pre = p2;
			p1 = p_next;
		}
	}

	for( int s = 0; s < fNumOfUnit; ++s ) fNumOfElementInUnit[ s ] = 0;

	int unitNum = -1;
	int tmpNumOfSeg = -1;
	for( int s = 0; s < fNumOfSeg; ++s ){
		if( fSegUnit[ s ] != unitNum ){
			++tmpNumOfSeg;
			fSegment[ tmpNumOfSeg ][ 0 ] = fSegment[ s ][ 0 ];
			fSegment[ tmpNumOfSeg ][ 1 ] = fSegment[ s ][ 1 ];
			unitNum = fSegUnit[ s ];
			fSegUnit[ tmpNumOfSeg ] = unitNum;
			fNumOfElementInUnit[ unitNum ] +=
			fSegment[ s ][ 1 ] - fSegment[ s ][ 0 ] + 1;
		}
		else{
			fSegment[ tmpNumOfSeg ][ 1 ] = fSegment[ s ][ 1 ];
			fNumOfElementInUnit[ unitNum ] +=
			fSegment[ s ][ 1 ] - fSegment[ s ][ 0 ] + 1;
		}
	}
	fNumOfSeg = tmpNumOfSeg + 1;
}

void TCross::backToPa1( TIndi& tKid ){
	int aa, bb, a1, b1;
	int jnum;

	for( int s = fNumOfModiEdge -1; s >= 0; --s ){
		aa = fModiEdge[ s ][ 0 ];
		a1 = fModiEdge[ s ][ 1 ];
		bb = fModiEdge[ s ][ 2 ];
		b1 = fModiEdge[ s ][ 3 ];

		if( tKid.fLink[aa][0] == bb ) tKid.fLink[aa][0] = a1;
		else tKid.fLink[aa][1] = a1;
		if( tKid.fLink[b1][0] == a1 ) tKid.fLink[b1][0] = bb;
		else tKid.fLink[b1][1] = bb;
		if( tKid.fLink[bb][0] == aa ) tKid.fLink[bb][0] = b1;
		else tKid.fLink[bb][1] = b1;
		if( tKid.fLink[a1][0] == b1 ) tKid.fLink[a1][0] = aa;
		else tKid.fLink[a1][1] = aa;
	}

	for( int s = 0; s < fNumOfAppliedCycle; ++s ){
		jnum = fAppliedCylce[ s ];
		this->changeSol( tKid, jnum, 2 );
	}
}

void TCross::goToBest( TIndi& tKid ){
	int aa, bb, a1, b1;
	int jnum;

	for( int s = 0; s < fNumOfBestAppliedCycle; ++s ){
		jnum = fBestAppliedCylce[ s ];
		this->changeSol( tKid, jnum, 1 );
	}

	 for( int s = 0; s < fNumOfBestModiEdge; ++s ){
		aa = fBestModiEdge[ s ][ 0 ];
		bb = fBestModiEdge[ s ][ 1 ];
		a1 = fBestModiEdge[ s ][ 2 ];
		b1 = fBestModiEdge[ s ][ 3 ];

		if( tKid.fLink[aa][0] == bb ) tKid.fLink[aa][0]=a1;
		else tKid.fLink[aa][1] = a1;
		if( tKid.fLink[bb][0] == aa ) tKid.fLink[bb][0] = b1;
		else tKid.fLink[bb][1] = b1;
		if( tKid.fLink[a1][0] == b1 ) tKid.fLink[a1][0] = aa;
		else tKid.fLink[a1][1] = aa;
		if( tKid.fLink[b1][0] == a1 ) tKid.fLink[b1][0] = bb;
		else tKid.fLink[b1][1] = bb;
	}
}

void TCross::incrementEdgeFreq( int **fEdgeFreq ){
	int j, jnum, cem;
	int r1, r2, b1, b2;
	int aa, bb, a1;

	for( int s = 0; s < fNumOfBestAppliedCycle; ++s ){
		jnum = fBestAppliedCylce[ s ];

		cem = fABcycle[ jnum ][ 0 ];
		fC[ 0 ] = fABcycle[ jnum ][ 0 ];

		for( j = 1; j <= cem+3; ++j )
			fC[ j ] = fABcycle[ jnum ][ j ];

		for( j = 0; j <cem/2; ++j ){
			r1 = fC[2+2*j]; r2 = fC[3+2*j];
			b1 = fC[1+2*j]; b2 = fC[4+2*j];

			++fEdgeFreq[ r1 ][ b1 ];
			--fEdgeFreq[ r1 ][ r2 ];
			--fEdgeFreq[ r2 ][ r1 ];
			++fEdgeFreq[ r2 ][ b2 ];
		}
	}
	for( int s = 0; s < fNumOfBestModiEdge; ++s ){
		aa = fBestModiEdge[ s ][ 0 ];
		bb = fBestModiEdge[ s ][ 1 ];
		a1 = fBestModiEdge[ s ][ 2 ];
		b1 = fBestModiEdge[ s ][ 3 ];

		--fEdgeFreq[ aa ][ bb ];
		--fEdgeFreq[ a1 ][ b1 ];
		++fEdgeFreq[ aa ][ a1 ];
		++fEdgeFreq[ bb ][ b1 ];
		--fEdgeFreq[ bb ][ aa ];
		--fEdgeFreq[ b1 ][ a1 ];
		++fEdgeFreq[ a1 ][ aa ];
		++fEdgeFreq[ b1 ][ bb ];
	}
}

int TCross::calAdpLoss( int **fEdgeFreq ){
	int j, jnum, cem;
	int r1, r2, b1, b2;
	int aa, bb, a1;
	double DLoss;

	DLoss = 0;
	for( int s = 0; s < fNumOfAppliedCycle; ++s ){
		jnum = fAppliedCylce[ s ];

		cem = fABcycle[ jnum ][ 0 ];
		fC[ 0 ] = fABcycle[ jnum ][ 0 ];

		for( j = 1; j <= cem+3; ++j ) fC[ j ] = fABcycle[ jnum ][ j ];

		for( j = 0; j <cem/2; ++j ){
			r1 = fC[2+2*j]; r2 = fC[3+2*j];
			b1 = fC[1+2*j]; b2 = fC[4+2*j];


			DLoss -= (fEdgeFreq[ r1 ][ r2 ]-1);
			DLoss -= (fEdgeFreq[ r2 ][ r1 ]-1);
			DLoss += fEdgeFreq[ r2 ][ b2 ];
			DLoss += fEdgeFreq[ b2 ][ r2 ];


			--fEdgeFreq[ r1 ][ r2 ];
			--fEdgeFreq[ r2 ][ r1 ];
			++fEdgeFreq[ r2 ][ b2 ];
			++fEdgeFreq[ b2 ][ r2 ];
		}
	}
	for( int s = 0; s < fNumOfModiEdge; ++s ){
		aa = fModiEdge[ s ][ 0 ];
		bb = fModiEdge[ s ][ 1 ];
		a1 = fModiEdge[ s ][ 2 ];
		b1 = fModiEdge[ s ][ 3 ];

		DLoss -= (fEdgeFreq[ aa ][ bb ]-1);
		DLoss -= (fEdgeFreq[ bb ][ aa ]-1);
		DLoss -= (fEdgeFreq[ a1 ][ b1 ]-1);
		DLoss -= (fEdgeFreq[ b1 ][ a1 ]-1);

		DLoss += fEdgeFreq[ aa ][ a1 ];
		DLoss += fEdgeFreq[ a1 ][ aa ];
		DLoss += fEdgeFreq[ bb ][ b1 ];
		DLoss += fEdgeFreq[ b1 ][ bb ];

		--fEdgeFreq[ aa ][ bb ];
		--fEdgeFreq[ bb ][ aa ];
		--fEdgeFreq[ a1 ][ b1 ];
		--fEdgeFreq[ b1 ][ a1 ];

		++fEdgeFreq[ aa ][ a1 ];
		++fEdgeFreq[ a1 ][ aa ];
		++fEdgeFreq[ bb ][ b1 ];
		++fEdgeFreq[ b1 ][ bb ];
	}
	for( int s = 0; s < fNumOfAppliedCycle; ++s ){
		jnum = fAppliedCylce[ s ];
		cem = fABcycle[ jnum ][ 0 ];
		fC[ 0 ] = fABcycle[ jnum ][ 0 ];
		for( j = 1; j <= cem+3; ++j ) fC[ j ] = fABcycle[ jnum ][ j ];

		for( j = 0; j <cem/2; ++j ){
			r1 = fC[2+2*j]; r2 = fC[3+2*j];
			b1 = fC[1+2*j]; b2 = fC[4+2*j];

			++fEdgeFreq[ r1 ][ r2 ];
			++fEdgeFreq[ r2 ][ r1 ];
			--fEdgeFreq[ r2 ][ b2 ];
			--fEdgeFreq[ b2 ][ r2 ];
		}
	}
	for( int s = 0; s < fNumOfModiEdge; ++s ){
		aa = fModiEdge[ s ][ 0 ];
		bb = fModiEdge[ s ][ 1 ];
		a1 = fModiEdge[ s ][ 2 ];
		b1 = fModiEdge[ s ][ 3 ];

		++fEdgeFreq[ aa ][ bb ];
		++fEdgeFreq[ bb ][ aa ];
		++fEdgeFreq[ a1 ][ b1 ];
		++fEdgeFreq[ b1 ][ a1 ];

		--fEdgeFreq[ aa ][ a1 ];
		--fEdgeFreq[ a1 ][ aa ];
		--fEdgeFreq[ bb ][ b1 ];
		--fEdgeFreq[ b1 ][ bb ];
	}
	return int(DLoss / 2);
}

double TCross::calEntLoss( int **fEdgeFreq ){
	int j, jnum, cem;
	int r1, r2, b1, b2;
	int aa, bb, a1;
	double DLoss;
	double h1, h2;

	DLoss = 0;	// AB-cycle
	for( int s = 0; s < fNumOfAppliedCycle; ++s ){
		jnum = fAppliedCylce[ s ];
		cem = fABcycle[ jnum ][ 0 ];
		fC[ 0 ] = fABcycle[ jnum ][ 0 ];

		for( j = 1; j <= cem+3; ++j ) fC[ j ] = fABcycle[ jnum ][ j ];

		for( j = 0; j <cem/2; ++j ){
			r1 = fC[2+2*j]; r2 = fC[3+2*j];
			b1 = fC[1+2*j]; b2 = fC[4+2*j];

		  h1 = (double)( fEdgeFreq[ r1 ][ r2 ] - 1 )/(double)Npop;
		  h2 = (double)( fEdgeFreq[ r1 ][ r2 ] )/(double)Npop;
		  if( fEdgeFreq[ r1 ][ r2 ] - 1 != 0 ) DLoss -= h1 * log( h1 );
		  DLoss += h2 * log( h2 );
		  --fEdgeFreq[ r1 ][ r2 ];
		  --fEdgeFreq[ r2 ][ r1 ];

		  h1 = (double)( fEdgeFreq[ r2 ][ b2 ] + 1 )/(double)Npop;
		  h2 = (double)( fEdgeFreq[ r2 ][ b2 ])/(double)Npop;
		  DLoss -= h1 * log( h1 );
		  if( fEdgeFreq[ r2 ][ b2 ] != 0 ) DLoss += h2 * log( h2 );
		  ++fEdgeFreq[ r2 ][ b2 ];
		  ++fEdgeFreq[ b2 ][ r2 ];
		}
	}

	for( int s = 0; s < fNumOfModiEdge; ++s ){
		aa = fModiEdge[ s ][ 0 ];
		bb = fModiEdge[ s ][ 1 ];
		a1 = fModiEdge[ s ][ 2 ];
		b1 = fModiEdge[ s ][ 3 ];

		h1 = (double)( fEdgeFreq[ aa ][ bb ] - 1 )/(double)Npop;
		h2 = (double)( fEdgeFreq[ aa ][ bb ] )/(double)Npop;
		if( fEdgeFreq[ aa ][ bb ] - 1 != 0 )
		  DLoss -= h1 * log( h1 );
		DLoss += h2 * log( h2 );
		--fEdgeFreq[ aa ][ bb ];
		--fEdgeFreq[ bb ][ aa ];

		h1 = (double)( fEdgeFreq[ a1 ][ b1 ] - 1 )/(double)Npop;
		h2 = (double)( fEdgeFreq[ a1 ][ b1 ] )/(double)Npop;
		if( fEdgeFreq[ a1 ][ b1 ] - 1 != 0 )
		  DLoss -= h1 * log( h1 );
		DLoss += h2 * log( h2 );
		--fEdgeFreq[ a1 ][ b1 ];
		--fEdgeFreq[ b1 ][ a1 ];

		h1 = (double)( fEdgeFreq[ aa ][ a1 ] + 1 )/(double)Npop;
		h2 = (double)( fEdgeFreq[ aa ][ a1 ])/(double)Npop;
		DLoss -= h1 * log( h1 );
		if( fEdgeFreq[ aa ][ a1 ] != 0 )
		  DLoss += h2 * log( h2 );
		++fEdgeFreq[ aa ][ a1 ];
		++fEdgeFreq[ a1 ][ aa ];

		h1 = (double)( fEdgeFreq[ bb ][ b1 ] + 1 )/(double)Npop;
		h2 = (double)( fEdgeFreq[ bb ][ b1 ])/(double)Npop;
		DLoss -= h1 * log( h1 );
		if( fEdgeFreq[ bb ][ b1 ] != 0 )
		  DLoss += h2 * log( h2 );
		++fEdgeFreq[ bb ][ b1 ];
		++fEdgeFreq[ b1 ][ bb ];
	}
	DLoss = -DLoss;

	// 更新 EdgeFreq
	for( int s = 0; s < fNumOfAppliedCycle; ++s ){
		jnum = fAppliedCylce[ s ];

		cem = fABcycle[ jnum ][ 0 ];
		fC[ 0 ] = fABcycle[ jnum ][ 0 ];

		for( j = 1; j <= cem+3; ++j ) fC[ j ] = fABcycle[ jnum ][ j ];

		for( j = 0; j <cem/2; ++j ){
		  r1 = fC[2+2*j]; r2 = fC[3+2*j];
		  b1 = fC[1+2*j]; b2 = fC[4+2*j];

		  ++fEdgeFreq[ r1 ][ r2 ];
		  ++fEdgeFreq[ r2 ][ r1 ];
		  --fEdgeFreq[ r2 ][ b2 ];
		  --fEdgeFreq[ b2 ][ r2 ];
		}
	}
	for( int s = 0; s < fNumOfModiEdge; ++s ){
		aa = fModiEdge[ s ][ 0 ];
		bb = fModiEdge[ s ][ 1 ];
		a1 = fModiEdge[ s ][ 2 ];
		b1 = fModiEdge[ s ][ 3 ];

		++fEdgeFreq[ aa ][ bb ];
		++fEdgeFreq[ bb ][ aa ];
		++fEdgeFreq[ a1 ][ b1 ];
		++fEdgeFreq[ b1 ][ a1 ];

		--fEdgeFreq[ aa ][ a1 ];
		--fEdgeFreq[ a1 ][ aa ];
		--fEdgeFreq[ bb ][ b1 ];
		--fEdgeFreq[ b1 ][ bb ];
	}
  return DLoss;
}

void TCross::setWeight( const TIndi& tPa1, const TIndi& tPa2 ){
	int cem;
	int r1, r2, v1, v2, v_p;
	int AB_num;

	for( int i = 0; i < fN; ++i ){
		fInEffectNode[ i ][ 0 ] = -1;
		fInEffectNode[ i ][ 1 ] = -1;
	}

	// Step 1:
	for( int s = 0; s < fNumOfABcycle; ++s ){
		cem = fABcycle[ s ][ 0 ];
		for( int j = 0; j < cem/2; ++j ){
			r1 = fABcycle[ s ][ 2*j+2 ];  // red edge
			r2 = fABcycle[ s ][ 2*j+3 ];

			if( fInEffectNode[ r1 ][ 0 ] == -1 ) fInEffectNode[ r1 ][ 0 ] = s;
			else if ( fInEffectNode[ r1 ][ 1 ] == -1 ) fInEffectNode[ r1 ][ 1 ] = s;


			if( fInEffectNode[ r2 ][ 0 ] == -1 ) fInEffectNode[ r2 ][ 0 ] = s;
			else if ( fInEffectNode[ r2 ][ 1 ] == -1 ) fInEffectNode[ r2 ][ 1 ] = s;

		}
	}

	// Step 2:
	for( int i = 0; i < fN; ++i ){
		if( fInEffectNode[ i ][ 0 ] != -1 && fInEffectNode[ i ][ 1 ] == -1 ){
			AB_num = fInEffectNode[ i ][ 0 ];
			v1 = i;

			if( tPa1.fLink[ v1 ][ 0 ] != tPa2.fLink[ v1 ][ 0 ] && tPa1.fLink[ v1 ][ 0 ] != tPa2.fLink[ v1 ][ 1 ] )
				v_p = tPa1.fLink[ v1 ][ 0 ];
			else if( tPa1.fLink[ v1 ][ 1 ] != tPa2.fLink[ v1 ][ 0 ] && tPa1.fLink[ v1 ][ 1 ] != tPa2.fLink[ v1 ][ 1 ] )
				v_p = tPa1.fLink[ v1 ][ 1 ];


			while( 1 ){
				fInEffectNode[ v1 ][ 1 ] = AB_num;

				if( tPa1.fLink[ v1 ][ 0 ] != v_p ) v2 = tPa1.fLink[ v1 ][ 0 ];
				else if( tPa1.fLink[ v1 ][ 1 ] != v_p ) v2 = tPa1.fLink[ v1 ][ 1 ];


				if( fInEffectNode[ v2 ][ 0 ] == -1 ) fInEffectNode[ v2 ][ 0 ] = AB_num;
				else if( fInEffectNode[ v2 ][ 1 ] == -1 ) fInEffectNode[ v2 ][ 1 ] = AB_num;


				if( fInEffectNode[ v2 ][ 1 ] != -1 ) break;
				v_p = v1;
				v1 = v2;
			}
		}
	}

	// Step 3:

	for( int s1 = 0; s1 < fNumOfABcycle; ++s1 ){
		fWeightC[ s1 ] = 0;
		for( int s2 = 0; s2 < fNumOfABcycle; ++s2 ) fWeightRR[ s1 ][ s2 ] = 0;
	}

	for( int i = 0; i < fN; ++i ){

		if( fInEffectNode[ i ][ 0 ] != -1 && fInEffectNode[ i ][ 1 ] != -1 ){
			++fWeightRR[ fInEffectNode[ i ][ 0 ] ][ fInEffectNode[ i ][ 1 ] ];
			++fWeightRR[ fInEffectNode[ i ][ 1 ] ][ fInEffectNode[ i ][ 0 ] ];
		}
		if( fInEffectNode[ i ][ 0 ] != fInEffectNode[ i ][ 1 ] ){
			++fWeightC[ fInEffectNode[ i ][ 0 ] ];
			++fWeightC[ fInEffectNode[ i ][ 1 ] ];
		}
	}
	for( int s1 = 0; s1 < fNumOfABcycle; ++s1 ) fWeightRR[ s1 ][ s1 ] = 0;
}

int TCross::calCNaive(){
	int count_C;
	int tt;

	count_C = 0;

	for( int i = 0; i < fN; ++i ){
		if( fInEffectNode[ i ][ 0 ] != -1 && fInEffectNode[ i ][ 1 ] != -1 ){
			tt = 0;
			if( fUsedAB[ fInEffectNode[ i ][ 0 ] ] == 1 ) ++tt;
			if( fUsedAB[ fInEffectNode[ i ][ 1 ] ] == 1 ) ++tt;
			if( tt == 1 ) ++count_C;
		}
	}
	return count_C;
}

void TCross::searchEset( int centerAB ){
	int nIter, stagImp;
	int delta_weight, min_delta_weight_nt;
	int flag_AddDelete, flag_AddDelete_nt;
	int selected_AB, selected_AB_nt;
	int jnum;

	fNumC = 0;  // Number of C nodes in E-set
	fNumE = 0;  // Number of Edges in E-set

	fNumOfUsedAB = 0;
	for( int s1 = 0; s1 < fNumOfABcycle; ++s1 ){
		fUsedAB[ s1 ] = 0;
		fWeightSR[ s1 ] = 0;
		fMovedAB[ s1 ] = 0;
	}

	for( int s = 0; s < fNumOfABcycleInEset; ++s ){
		jnum = fABcycleInEset[ s ];
		this->addAB( jnum );
	}
	fBestNumC = fNumC;
	fBestNumE = fNumE;

	stagImp = 0;
	nIter = 0;
	while( 1 ){
		++nIter;
		min_delta_weight_nt = 99999999;
		flag_AddDelete = 0;
		flag_AddDelete_nt = 0;
		for( int s1 = 0; s1 < fNumOfABcycle; ++s1 ){
			if( fUsedAB[ s1 ] == 0 && fWeightSR[ s1 ] > 0 ){
				delta_weight = fWeightC[ s1 ] - 2 * fWeightSR[ s1 ];
				if( fNumC + delta_weight < fBestNumC ){
					selected_AB = s1;
					flag_AddDelete = 1;
					fBestNumC = fNumC + delta_weight;
				}
				if( delta_weight < min_delta_weight_nt && nIter > fMovedAB[ s1 ] ){
					selected_AB_nt = s1;
					flag_AddDelete_nt = 1;
					min_delta_weight_nt = delta_weight;
				}
			}
			else if( fUsedAB[ s1 ] == 1 && s1 != centerAB ){
				delta_weight = - fWeightC[ s1 ] + 2 * fWeightSR[ s1 ];
				if( fNumC + delta_weight < fBestNumC ){
					selected_AB = s1;
					flag_AddDelete = -1;
					fBestNumC = fNumC + delta_weight;
				}
				if( delta_weight < min_delta_weight_nt && nIter > fMovedAB[ s1 ] ){
					selected_AB_nt = s1;
					flag_AddDelete_nt = -1;
					min_delta_weight_nt = delta_weight;
				}
			}
		}

		if( flag_AddDelete != 0 ){
			if( flag_AddDelete == 1 ) this->addAB( selected_AB );
			else if( flag_AddDelete == -1 ) this->deleteAB( selected_AB );

			fMovedAB[ selected_AB ] = nIter + tRand->Integer( 1, fTmax );

			fBestNumE = fNumE;

			fNumOfABcycleInEset = 0;
			for( int s1 = 0; s1 < fNumOfABcycle; ++s1 )
				if( fUsedAB[ s1 ] == 1 ) fABcycleInEset[ fNumOfABcycleInEset++ ] = s1;

			stagImp = 0;
		}
		else if( flag_AddDelete_nt != 0 ) {
			if( flag_AddDelete_nt == 1 ) this->addAB( selected_AB_nt );
			else if( flag_AddDelete_nt == -1 )

			this->deleteAB( selected_AB_nt );
			fMovedAB[ selected_AB_nt ] = nIter + tRand->Integer( 1, fTmax );
		}
		if( flag_AddDelete == 0 ) ++stagImp;
		if( stagImp == fMaxStag ) break;
	}
}

void TCross::addAB( int num ){
	fNumC += fWeightC[ num ] - 2 * fWeightSR[ num ];
	fNumE += fABcycle[ num ][ 0 ] / 2;

	fUsedAB[ num ] = 1;
	++fNumOfUsedAB;
	for( int s1 = 0; s1 < fNumOfABcycle; ++s1 ) fWeightSR[ s1 ] += fWeightRR[ s1 ][ num ];
}

void TCross::deleteAB( int num ){
	fNumC -= fWeightC[ num ] - 2 * fWeightSR[ num ];
	fNumE -= fABcycle[ num ][ 0 ] / 2;

	fUsedAB[ num ] = 0;
	--fNumOfUsedAB;
	for( int s1 = 0; s1 < fNumOfABcycle; ++s1 ) fWeightSR[ s1 ] -= fWeightRR[ s1 ][ num ];
}

The file cross.h contains:
/*
 * cross.h
 *   created on: April 24, 2013
 * last updated: June 13, 2013
 *       author: liushujia
 */

#ifndef __Cross__
#define __Cross__

#ifndef __RAND__
#include "randomize.h"
#endif

#ifndef __Sort__
#include "sort.h"
#endif

#ifndef __INDI__
#include "indi.h"
#endif

#ifndef __EVALUATOR__
#include "evaluator.h"
#endif

#include <stdio.h>
#include <stdlib.h>
#include <assert.h>

class TCross{
public:
	TCross( int N );
	~TCross();
	void input_data(int N);
	void doIt( TIndi& tKid, TIndi& tPa2, int numOfKids, int flagP, int flagC[ 10 ], int** fEdgeFreq );	// EAXÃ¤Â¸Â»Ã§Â¨â€¹Ã¥Âºï¿½
	void setParents( const TIndi& tPa1, const TIndi& tPa2, int flagC[ 10 ], int numOfKids );			// Ã¨Â®Â¾Ã§Â½Â®Ã§Ë†Â¶Ã¦Å“Â¬Ã¤Â¸Å½Ã¦Â¯ï¿½Ã¦Å“Â¬
	void setABcycle( const TIndi& parent1, const TIndi& parent2, int flagC[ 10 ], int numOfKids );		// Ã¨Â®Â¾Ã§Â½Â®ABcycle

	void swap(int &x, int &y);
	void formABcycle();																// Ã¤Â¿ï¿½Ã¥Â­ËœABcycle
	void changeSol( TIndi& tKid, int ABnum, int type );								// Ã§â€�Â¨ABcycleÃ¤ÂºÂ§Ã§â€�Å¸Ã¤Â¸Â­Ã©â€”Â´Ã¨Â§Â£

	void makeCompleteSol( TIndi& tKid );					// EAXÃ§Â¬Â¬5Ã¦Â­Â¥
	void makeUnit();										// EAXÃ§Â¬Â¬5-1Ã¦Â­Â¥
	void backToPa1( TIndi& tKid );							// Ã¥â€ºÅ¾Ã¦Â»Å¡p_A
	void goToBest( TIndi& tKid );							// Ã¤Â¿Â®Ã¦â€�Â¹tKidÃ¤Â¸ÂºÃ¥Â­ï¿½Ã¤Â»Â£Ã¦Å“â‚¬Ã¤Â¼ËœÃ¨Â§Â£

	void incrementEdgeFreq( int **fEdgeFreq );				// Ã¥Â¢Å¾Ã¥Å Â fEdgeFreq[][]
	int calAdpLoss( int **fEdgeFreq );						// Ã¨Â®Â¡Ã§Â®â€”Ã¥Â¹Â³Ã¥ï¿½â€¡Ã¨Â·Â¯Ã§Â¨â€¹Ã§Å¡â€žÃ¥Â·Â®
	double calEntLoss( int **fEdgeFreq );					// Ã¨Â®Â¡Ã§Â®â€”Ã¨Â¾Â¹Ã§â€ ÂµÃ§Å¡â€žÃ¥Â·Â®

	void setWeight( const TIndi& parent1, const TIndi& parent2 );	// Block2
	int	calCNaive();
	void searchEset( int num );
	void addAB( int num );
	void deleteAB( int num );

	int fNumOfGeneratedCh;
	TEvaluator* eval;
	int Npop;

private:
//	TIndi tBestTmp;
	int fFlagImp;
	int fN;
	int total_fN;////////////////////////////////
	int r;
	int exam;
	int examFlag;
	int flagSt;
	int flagCycle;
	int prType;
	int chDis;
	int koritsuMany;
	int bunkiMany;
	int st;
	int ci;
	int pr;
	int stock;
	int stAppear;
	int fEvalType;
	int fEsetType;
	int fNumOfABcycleInESet;
	int fNumOfABcycle;
	int fPosiCurr;
	int fMaxNumOfABcycle;

	int *koritsu;
	int *bunki;
	int *koriInv;
	int *bunInv;
	int *checkKoritsu;
	int *fRoute;
	int *fPermu;
	int *fC;
	int *fJun;
	int *fOrd1;
	int *fOrd2;

	int **nearData;
	int **fABcycle;

	// Speed Up Start
	int fNumOfUnit;
	int fNumOfSeg;
	int fNumOfSPL;
	int fNumOfElementInCU;
	int fNumOfSegForCenter;
	double fGainModi;
	//int fGainModi;
	int fNumOfModiEdge;
	int fNumOfBestModiEdge;
	int fNumOfAppliedCycle;
	int fNumOfBestAppliedCycle;

	int *fOrder;
	int *fInv;
	int *fSegUnit;
	int *fSegPosiList;
	int *LinkAPosi;
	int *fPosiSeg;
	int *fNumOfElementInUnit;
	int *fCenterUnit;
	int *fListOfCenterUnit;
	int *fSegForCenter;
	//int *fGainAB;
	double *fGainAB;
	int *fAppliedCylce;
	int *fBestAppliedCylce;

	int **fSegment;
	int **LinkBPosi;
	int **fModiEdge;
	int **fBestModiEdge;
	// Speed Up End

	// Block2
	int fNumOfUsedAB;
	int fNumC;
	int fNumE;
	int fTmax;
	int fMaxStag;
	int fNumOfABcycleInEset;
	int fDisAB;
	int fBestNumC;
	int fBestNumE;

	int *fNumOfElementINAB;
	int *fWeightSR;
	int *fWeightC;
	int *fUsedAB;
	int *fMovedAB;
	int *fABcycleInEset;

	int **fInEffectNode;
	int **fWeightRR;
};

#endif

The file EAX.cpp contains:
/*
 *
 *
 *
 *
 */

#ifndef __ENVIRONMENT__
#include "environment.h"
#endif
#include<iostream>
#include <time.h>
#include <stdio.h>
#include <stdlib.h>
using namespace std;

void EAX(TEnvironment* gEnv, int * given_sol,int count, double *x_coor,double *y_coor){// given a initial tour and coordiantion
//	InitURandom(); //
	int maxNumOfTrial;
	maxNumOfTrial=1;					// repeated times
//	gEnv->Npop=100;						// number of items
//	gEnv->Nch=30;						// number of offsprings

	int opt_tour[count];
	int cc[count];
	for (int i=0;i<=count-1;i++)
		cc[i]=given_sol[i];
//	cout<<"Initializing ..."<<endl;
//	clock_t start = clock();
	gEnv->input_data(given_sol,count,x_coor,y_coor);
//	cout<<"Building solution ..."<<endl;
	for ( int n = 0; n < maxNumOfTrial; ++n ){
		gEnv->doIt();
		gEnv->writeBest(opt_tour);
	}
	int best_sol[count];
	for (int i=0;i<count;i++)
	{
		best_sol[i]=given_sol[opt_tour[i]-1];
	}
	for (int i=0;i<=count;i++)
		given_sol[i]=best_sol[i];
}

The file EAX.h contains:
/*
 * EAX.h
 *
 *  Created on: 13 Apr 2020
 *      Author: Peng
 */

#ifndef EAX_H_
#define EAX_H_

#ifndef __ENVIRONMENT__
#include "environment.h"
#endif




int EAX(TEnvironment* gEnv, int * given_sol,int count, double *x_coor,double *y_coor);





#endif /* EAX_H_ */

The file environment.cpp contains:
/*
 * environment.cpp
 *   created on: April 24, 2013
 * last updated: June 13, 2013
 *       author: liushujia
 */

#ifndef __ENVIRONMENT__
#include "environment.h"
#endif
#include "basic.h"
#include <math.h>
#include<iostream>
using namespace std;

void MakeRandSol(TEvaluator* eval, TIndi& indi);
void Make2optSol(TEvaluator* eval, TIndi& indi);

TEnvironment::TEnvironment(){
	fEvaluator = new TEvaluator();
}

TEnvironment::~TEnvironment(){
	delete [] fIndexForMating;
	delete [] tCurPop;
	int N = fEvaluator->totalCity;
	delete fEvaluator;
	delete tCross;
	delete tKopt;
	for( int i = 0; i < N; ++i ) delete [] fEdgeFreq[ i ];
	delete [] fEdgeFreq;
}
void TEnvironment::input_data(int * given_sol,int count,double *x_coor,double *y_coor)
{
	fEvaluator->setInstance1(given_sol, count,x_coor,y_coor);
	for ( int i = 0; i < Npop; ++i ) tCurPop[i].define1(count);
	tBest.define1(count);// define the best solution
	tCross->input_data(count);
	tKopt->input_data(count);
	tKopt->setInvNearList();
	tCross->Npop = Npop;
	num_nodes=count;
}

void TEnvironment::define(int count,int graph_type){
	fEvaluator->setInstance(count,graph_type);
	int N_c = fEvaluator->totalCity;//æ€»å…±ç‚¹çš„æ•°é‡�
	fIndexForMating = new int [ Npop + 1 ];
	tCurPop = new TIndi [ Npop ];// define the number of population
	for ( int i = 0; i < Npop; ++i ) tCurPop[i].define( N_c );
	tBest.define( N_c );// define the best solution
	tCross = new TCross( N_c );// define a crossover objective by using parameter N which is the number cities
	tCross->eval = fEvaluator;// probe directs it
	tKopt = new TKopt(N_c );
	tKopt->eval = fEvaluator;
	fEdgeFreq = new int* [ N_c ];
	for( int i = 0; i < N_c; ++i ) fEdgeFreq[ i ] = new int [ N_c ];
}

void TEnvironment::doIt(){
	this->fTimeStart = clock();// to calculate the initial time
	this->initPop();				// åˆ�å§‹åŒ–ç§�ç¾¤
	if (num_nodes<10){// in this place, if the number of cities is too small, the k-optis used
		this->setAverageBest();
		return;
	}
	this->fTimeInit = clock();    // initial time
	this->init();
	this->getEdgeFreq();
	no_improve=0;
	change=Max;
	while( 1 ){
		this->setAverageBest();
		if ((change-1.0e-7)>tBest.fEvaluationValue){// indicate the improvement
			change=tBest.fEvaluationValue;
			no_improve=0;
		}
		else
			no_improve++;
//		printf( "%d:\t%f\t%lf\n", fCurNumOfGen, fBestValue, fAverageValue );
		if( this->terminationCondition() || no_improve>100) break;

		this->selectForMating();
		for( int s =0; s < Npop; ++s ) this->generateKids( s );

		++fCurNumOfGen;
	}
	this->fTimeEnd = clock();
}

void TEnvironment::init(){
	fAccumurateNumCh = 0;
	fCurNumOfGen = 0;
	fStagBest = 0;
	fMaxStagBest = 0;
	fStage = 1;				// é˜¶æ®µ1
	fFlagC[ 0 ] = 4;		// ç»´æŒ�ç§�ç¾¤å¤šæ ·æ€§	1:Greedy, 2:---, 3:Distance, 4:Entropy
	fFlagC[ 1 ] = 1;		// Esetç±»åž‹			1:Single-AB, 2:Block2
}

bool TEnvironment::terminationCondition(){
	if ( fAverageValue - fBestValue < 0.00001 )  return true;
	if( fStage == 1 ){
		if( fStagBest == int(1500/Nch) && fMaxStagBest == 0 )			// 1500/Nch
			fMaxStagBest =int( fCurNumOfGen / 10 );						// fMaxStagBest = G/10
		else if( fMaxStagBest != 0 && fMaxStagBest <= fStagBest ){
			fStagBest = 0;
			fMaxStagBest = 0;
			fCurNumOfGen1 = fCurNumOfGen;
			fFlagC[ 1 ] = 2;
			fStage = 2;
		}
		return false;
	}
	if( fStage == 2 ){
		if( fStagBest == int(1500/Nch) && fMaxStagBest == 0 )			// 1500/Nch
			fMaxStagBest = int( (fCurNumOfGen - fCurNumOfGen1) / 10 );	// fMaxStagBest = G/10
		else if( fMaxStagBest != 0 && fMaxStagBest <= fStagBest ) return true;
		return false;
	}

	return true;
}

void TEnvironment::setAverageBest(){
	double stockBest = tBest.fEvaluationValue;
	//int stockBest = tBest.fEvaluationValue;
	fAverageValue = 0.0;
	fBestIndex = 0;
	fBestValue = tCurPop[0].fEvaluationValue;
	for(int i = 0; i < Npop; ++i ){
		fAverageValue += tCurPop[i].fEvaluationValue;
		if( tCurPop[i].fEvaluationValue < fBestValue ){
			fBestIndex = i;
			fBestValue = tCurPop[i].fEvaluationValue;
		}
	}
	tBest = tCurPop[ fBestIndex ];
	fAverageValue /= (double)Npop;
	if( tBest.fEvaluationValue < stockBest ){
		fStagBest = 0;
		fBestNumOfGen = fCurNumOfGen;
		fBestAccumeratedNumCh = fAccumurateNumCh;
	}
	else ++fStagBest;
}

void TEnvironment::initPop(){
	for ( int i = 0; i < Npop; ++i ){
		tKopt->makeRandSol( tCurPop[ i ] );		// è®¾ç½®ä¸€ä¸ªéš�æœºè·¯ç¨‹
		tKopt->doIt( tCurPop[ i ] );			// å±€éƒ¨æ�œç´¢(2-opt neighborhood)
	}
}

void TEnvironment::selectForMating(){
	tRand->permutation( fIndexForMating, Npop, Npop );
	fIndexForMating[ Npop ] = fIndexForMating[ 0 ];
}

void TEnvironment::generateKids( int s ){
	// tCurPop[fIndexForMating[s]] è¢«æ›¿æ�¢ä¸ºtCross->DoIt()ä¸­å­�ä»£çš„ä¸€ä¸ªæœ€ä¼˜è§£
	// fEdgeFreq[][] å�Œæ—¶è¢«æ›´æ–°
	tCross->setParents( tCurPop[fIndexForMating[s]], tCurPop[fIndexForMating[s+1]], fFlagC, Nch );
	tCross->doIt( tCurPop[fIndexForMating[s]], tCurPop[fIndexForMating[s+1]], Nch, 1, fFlagC, fEdgeFreq );
	fAccumurateNumCh += tCross->fNumOfGeneratedCh;
}

void TEnvironment::getEdgeFreq(){
	int  k0, k1, N = fEvaluator->Ncity;
	for( int j1 = 0; j1 < N; ++j1 )
		for( int j2 = 0; j2 < N; ++j2 )
			fEdgeFreq[ j1 ][ j2 ] = 0;

	for( int i = 0; i < Npop; ++i )
		for(int j = 0; j < N; ++j ){
			k0 = tCurPop[ i ].fLink[ j ][ 0 ];
			k1 = tCurPop[ i ].fLink[ j ][ 1 ];
			++fEdgeFreq[ j ][ k0 ];
			++fEdgeFreq[ j ][ k1 ];
		}
}

void TEnvironment::printOn( int n ){
	printf( "n = %d val = %f Gen = %d Time = %d %d\n" , n, tBest.fEvaluationValue, fCurNumOfGen,
		(int)((double)(this->fTimeInit - this->fTimeStart)/(double)CLOCKS_PER_SEC),
		(int)((double)(this->fTimeEnd - this->fTimeStart)/(double)CLOCKS_PER_SEC) );
//	fflush(stdout);

}

void TEnvironment::writeBest(int *given_sol){
//	FILE *fp;
//	char filename[ 80 ];

//	sprintf( filename, "bestSolution.txt" );
//	fp = fopen( filename, "a");
	fEvaluator->writeTo(given_sol, tBest );
//	fclose( fp );
}

The file environment.h contains:

/*
 * environment.h
 *   created on: April 24, 2013
 * last updated: June 13, 2013
 *       author: liushujia
 */

#ifndef __ENVIRONMENT__
#define __ENVIRONMENT__

#ifndef __INDI__
#include "indi.h"
#endif

#ifndef __RAND__
#include "randomize.h"
#endif

#ifndef __EVALUATOR__
#include "evaluator.h"
#endif

#ifndef __Cross__
#include "cross.h"
#endif

#ifndef __KOPT__
#include "kopt.h"
#endif

#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <string.h>
#include <time.h>

class TEnvironment{
public:
	TEnvironment();
	~TEnvironment();
	void input_data(int * given_sol,int count,double *x_coor,double *y_coor);
	void define(int count,int graph_type);						// ÃƒÂ¥Ã‹â€ Ã¯Â¿Â½ÃƒÂ¥Ã‚Â§Ã¢â‚¬Â¹ÃƒÂ¥Ã…â€™Ã¢â‚¬â€œ
	//void define();						// ÃƒÂ¥Ã‹â€ Ã¯Â¿Â½ÃƒÂ¥Ã‚Â§Ã¢â‚¬Â¹ÃƒÂ¥Ã…â€™Ã¢â‚¬â€œ
	void doIt();						// GAÃƒÂ¤Ã‚Â¸Ã‚Â»ÃƒÂ§Ã‚Â¨Ã¢â‚¬Â¹ÃƒÂ¥Ã‚ÂºÃ¯Â¿Â½
	void init();						// GAÃƒÂ¥Ã‹â€ Ã¯Â¿Â½ÃƒÂ¥Ã‚Â§Ã¢â‚¬Â¹ÃƒÂ¥Ã…â€™Ã¢â‚¬â€œ
	bool terminationCondition();		// ÃƒÂ©Ã¢â€šÂ¬Ã¢â€šÂ¬ÃƒÂ¥Ã¢â‚¬Â¡Ã‚ÂºÃƒÂ¦Ã¯Â¿Â½Ã‚Â¡ÃƒÂ¤Ã‚Â»Ã‚Â¶
	void setAverageBest();				// ÃƒÂ¨Ã‚Â®Ã‚Â¡ÃƒÂ§Ã‚Â®Ã¢â‚¬â€�ÃƒÂ§Ã‚Â§Ã¯Â¿Â½ÃƒÂ§Ã‚Â¾Ã‚Â¤ÃƒÂ¥Ã‚Â¹Ã‚Â³ÃƒÂ¥Ã¯Â¿Â½Ã¢â‚¬Â¡TSPÃƒÂ©Ã¢â‚¬Â¢Ã‚Â¿ÃƒÂ¥Ã‚ÂºÃ‚Â¦ÃƒÂ¤Ã‚Â¸Ã…Â½ÃƒÂ§Ã‚Â§Ã¯Â¿Â½ÃƒÂ§Ã‚Â¾Ã‚Â¤ÃƒÂ¦Ã…â€œÃ¢â€šÂ¬ÃƒÂ¤Ã‚Â¼Ã‹Å“TSPÃƒÂ©Ã¢â‚¬Â¢Ã‚Â¿ÃƒÂ¥Ã‚ÂºÃ‚Â¦

	void initPop();						// ÃƒÂ¥Ã‹â€ Ã¯Â¿Â½ÃƒÂ¥Ã‚Â§Ã¢â‚¬Â¹ÃƒÂ¥Ã…â€™Ã¢â‚¬â€œÃƒÂ§Ã‚Â§Ã¯Â¿Â½ÃƒÂ§Ã‚Â¾Ã‚Â¤
	void selectForMating();				// ÃƒÂ©Ã¢â€šÂ¬Ã¢â‚¬Â°ÃƒÂ¦Ã¢â‚¬Â¹Ã‚Â©ÃƒÂ§Ã‹â€ Ã‚Â¶ÃƒÂ¦Ã…â€œÃ‚Â¬ÃƒÂ¤Ã‚Â¸Ã…Â½ÃƒÂ¦Ã‚Â¯Ã¯Â¿Â½ÃƒÂ¦Ã…â€œÃ‚Â¬
	void generateKids( int s );			// ÃƒÂ¤Ã‚ÂºÃ‚Â§ÃƒÂ§Ã¢â‚¬ï¿½Ã…Â¸ÃƒÂ¥Ã‚Â¹Ã‚Â¶ÃƒÂ©Ã¢â€šÂ¬Ã¢â‚¬Â°ÃƒÂ¦Ã¢â‚¬Â¹Ã‚Â©ÃƒÂ¥Ã‚Â­Ã¯Â¿Â½ÃƒÂ¤Ã‚Â»Ã‚Â£
	void getEdgeFreq();					// ÃƒÂ¨Ã‚Â®Ã‚Â¡ÃƒÂ§Ã‚Â®Ã¢â‚¬â€�ÃƒÂ§Ã‚Â§Ã¯Â¿Â½ÃƒÂ§Ã‚Â¾Ã‚Â¤ÃƒÂ¤Ã‚Â¸Ã‚Â­ÃƒÂ¦Ã‚Â¯Ã¯Â¿Â½ÃƒÂ¦Ã¯Â¿Â½Ã‚Â¡ÃƒÂ¨Ã‚Â¾Ã‚Â¹ÃƒÂ§Ã…Â¡Ã¢â‚¬Å¾ÃƒÂ©Ã‚Â¢Ã¢â‚¬ËœÃƒÂ§Ã…Â½Ã¢â‚¬Â¡

	void printOn( int n );				// ÃƒÂ¨Ã‚Â¾Ã¢â‚¬Å“ÃƒÂ¥Ã¢â‚¬Â¡Ã‚ÂºÃƒÂ§Ã‚Â»Ã¢â‚¬Å“ÃƒÂ¦Ã…Â¾Ã…â€œ
	void writeBest(int *given_sol);					// ÃƒÂ¨Ã‚Â¾Ã¢â‚¬Å“ÃƒÂ¥Ã¢â‚¬Â¡Ã‚ÂºÃƒÂ¦Ã…â€œÃ¢â€šÂ¬ÃƒÂ¤Ã‚Â¼Ã‹Å“TSPÃƒÂ¨Ã‚Â·Ã‚Â¯ÃƒÂ¥Ã‚Â¾Ã¢â‚¬Å¾
	//void writeBest();					// ÃƒÂ¨Ã‚Â¾Ã¢â‚¬Å“ÃƒÂ¥Ã¢â‚¬Â¡Ã‚ÂºÃƒÂ¦Ã…â€œÃ¢â€šÂ¬ÃƒÂ¤Ã‚Â¼Ã‹Å“TSPÃƒÂ¨Ã‚Â·Ã‚Â¯ÃƒÂ¥Ã‚Â¾Ã¢â‚¬Å¾

	TEvaluator* fEvaluator;				// ÃƒÂ¨Ã‚Â¾Ã‚Â¹ÃƒÂ¨Ã‚Â·Ã¯Â¿Â½ÃƒÂ§Ã‚Â¦Ã‚Â»
	TCross* tCross;						// ÃƒÂ¨Ã‚Â¾Ã‚Â¹ÃƒÂ©Ã¢â‚¬ÂºÃ¢â‚¬Â ÃƒÂ¥Ã¯Â¿Â½Ã‹â€ ÃƒÂ¤Ã‚ÂºÃ‚Â¤ÃƒÂ¥Ã¯Â¿Â½Ã¢â‚¬Â°
	TKopt* tKopt;						// ÃƒÂ¥Ã‚Â±Ã¢â€šÂ¬ÃƒÂ©Ã†â€™Ã‚Â¨ÃƒÂ¦Ã¯Â¿Â½Ã…â€œÃƒÂ§Ã‚Â´Ã‚Â¢(2-opt neighborhood)
//	char *fFileNameTSP;					// TSPÃƒÂ¦Ã¢â‚¬â€œÃ¢â‚¬Â¡ÃƒÂ¤Ã‚Â»Ã‚Â¶ÃƒÂ¥Ã¯Â¿Â½Ã¯Â¿Â½

	int Npop;							// ÃƒÂ§Ã‚Â§Ã¯Â¿Â½ÃƒÂ§Ã‚Â¾Ã‚Â¤ÃƒÂ¦Ã¢â‚¬Â¢Ã‚Â°ÃƒÂ©Ã¢â‚¬Â¡Ã¯Â¿Â½
	int Nch;							// ÃƒÂ¦Ã‚Â¯Ã¯Â¿Â½ÃƒÂ¤Ã‚Â¸Ã‚ÂªÃƒÂ§Ã‹â€ Ã‚Â¶ÃƒÂ¦Ã…â€œÃ‚Â¬(ÃƒÂ¦Ã‚Â¯Ã¯Â¿Â½ÃƒÂ¦Ã…â€œÃ‚Â¬)ÃƒÂ¤Ã‚ÂºÃ‚Â§ÃƒÂ§Ã¢â‚¬ï¿½Ã…Â¸ÃƒÂ§Ã…Â¡Ã¢â‚¬Å¾ÃƒÂ¥Ã‚Â­Ã¯Â¿Â½ÃƒÂ¤Ã‚Â»Ã‚Â£ÃƒÂ¦Ã¢â‚¬Â¢Ã‚Â°ÃƒÂ©Ã¢â‚¬Â¡Ã¯Â¿Â½
	TIndi* tCurPop;						// ÃƒÂ¥Ã‚Â½Ã¢â‚¬Å“ÃƒÂ¥Ã¢â‚¬Â°Ã¯Â¿Â½ÃƒÂ§Ã‚Â§Ã¯Â¿Â½ÃƒÂ§Ã‚Â¾Ã‚Â¤ÃƒÂ¦Ã‹â€ Ã¯Â¿Â½ÃƒÂ¥Ã¢â‚¬ËœÃ‹Å“
	TIndi tBest;						// ÃƒÂ¥Ã‚Â½Ã¢â‚¬Å“ÃƒÂ¥Ã¢â‚¬Â°Ã¯Â¿Â½ÃƒÂ§Ã‚Â§Ã¯Â¿Â½ÃƒÂ§Ã‚Â¾Ã‚Â¤ÃƒÂ¦Ã…â€œÃ¢â€šÂ¬ÃƒÂ¤Ã‚Â¼Ã‹Å“ÃƒÂ¨Ã‚Â§Ã‚Â£
	int fCurNumOfGen;					// ÃƒÂ¥Ã‚Â½Ã¢â‚¬Å“ÃƒÂ¥Ã¢â‚¬Â°Ã¯Â¿Â½ÃƒÂ§Ã‚Â§Ã¯Â¿Â½ÃƒÂ§Ã‚Â¾Ã‚Â¤ÃƒÂ¤Ã‚Â»Ã‚Â£ÃƒÂ¦Ã¢â‚¬Â¢Ã‚Â°
	long int fAccumurateNumCh;			// ÃƒÂ¥Ã‚Â­Ã¯Â¿Â½ÃƒÂ¤Ã‚Â»Ã‚Â£ÃƒÂ§Ã‚Â´Ã‚Â¯ÃƒÂ¨Ã‚Â®Ã‚Â¡ÃƒÂ¦Ã¢â‚¬Â¢Ã‚Â°ÃƒÂ§Ã¢â‚¬ÂºÃ‚Â®

	int fBestNumOfGen;					// ÃƒÂ¥Ã‚Â½Ã¢â‚¬Å“ÃƒÂ¥Ã¢â‚¬Â°Ã¯Â¿Â½ÃƒÂ¦Ã…â€œÃ¢â€šÂ¬ÃƒÂ¤Ã‚Â¼Ã‹Å“ÃƒÂ¨Ã‚Â§Ã‚Â£ÃƒÂ¦Ã¢â‚¬Â°Ã¢â€šÂ¬ÃƒÂ¥Ã…â€œÃ‚Â¨ÃƒÂ§Ã…Â¡Ã¢â‚¬Å¾ÃƒÂ¤Ã‚Â»Ã‚Â£ÃƒÂ¦Ã¢â‚¬Â¢Ã‚Â°
	long int fBestAccumeratedNumCh;		// ÃƒÂ¥Ã‚Â½Ã¢â‚¬Å“ÃƒÂ¥Ã¢â‚¬Â°Ã¯Â¿Â½ÃƒÂ¦Ã…â€œÃ¢â€šÂ¬ÃƒÂ¤Ã‚Â¼Ã‹Å“ÃƒÂ¨Ã‚Â§Ã‚Â£ÃƒÂ§Ã…Â¡Ã¢â‚¬Å¾ÃƒÂ¥Ã‚Â­Ã¯Â¿Â½ÃƒÂ¤Ã‚Â»Ã‚Â£ÃƒÂ§Ã‚Â´Ã‚Â¯ÃƒÂ¨Ã‚Â®Ã‚Â¡ÃƒÂ¦Ã¢â‚¬Â¢Ã‚Â°ÃƒÂ§Ã¢â‚¬ÂºÃ‚Â®
	int **fEdgeFreq;					// ÃƒÂ§Ã‚Â§Ã¯Â¿Â½ÃƒÂ§Ã‚Â¾Ã‚Â¤ÃƒÂ§Ã…Â¡Ã¢â‚¬Å¾ÃƒÂ¨Ã‚Â¾Ã‚Â¹ÃƒÂ©Ã‚Â¢Ã¢â‚¬ËœÃƒÂ§Ã…Â½Ã¢â‚¬Â¡
	double fAverageValue;				// ÃƒÂ§Ã‚Â§Ã¯Â¿Â½ÃƒÂ§Ã‚Â¾Ã‚Â¤TSPÃƒÂ¨Ã‚Â·Ã‚Â¯ÃƒÂ¥Ã‚Â¾Ã¢â‚¬Å¾ÃƒÂ§Ã…Â¡Ã¢â‚¬Å¾ÃƒÂ¥Ã‚Â¹Ã‚Â³ÃƒÂ¥Ã¯Â¿Â½Ã¢â‚¬Â¡ÃƒÂ©Ã¢â‚¬Â¢Ã‚Â¿ÃƒÂ¥Ã‚ÂºÃ‚Â¦
	double fBestValue;						// ÃƒÂ§Ã‚Â§Ã¯Â¿Â½ÃƒÂ§Ã‚Â¾Ã‚Â¤ÃƒÂ¦Ã…â€œÃ¢â€šÂ¬ÃƒÂ¤Ã‚Â¼Ã‹Å“ÃƒÂ¨Ã‚Â§Ã‚Â£ÃƒÂ§Ã…Â¡Ã¢â‚¬Å¾ÃƒÂ¨Ã‚Â·Ã‚Â¯ÃƒÂ¥Ã‚Â¾Ã¢â‚¬Å¾ÃƒÂ©Ã¢â‚¬Â¢Ã‚Â¿ÃƒÂ¥Ã‚ÂºÃ‚Â¦  //int fBestValue;						// ÃƒÂ§Ã‚Â§Ã¯Â¿Â½ÃƒÂ§Ã‚Â¾Ã‚Â¤ÃƒÂ¦Ã…â€œÃ¢â€šÂ¬ÃƒÂ¤Ã‚Â¼Ã‹Å“ÃƒÂ¨Ã‚Â§Ã‚Â£ÃƒÂ§Ã…Â¡Ã¢â‚¬Å¾ÃƒÂ¨Ã‚Â·Ã‚Â¯ÃƒÂ¥Ã‚Â¾Ã¢â‚¬Å¾ÃƒÂ©Ã¢â‚¬Â¢Ã‚Â¿ÃƒÂ¥Ã‚ÂºÃ‚Â¦
	int fBestIndex;						// ÃƒÂ¦Ã…â€œÃ¢â€šÂ¬ÃƒÂ¤Ã‚Â¼Ã‹Å“ÃƒÂ§Ã‚Â§Ã¯Â¿Â½ÃƒÂ§Ã‚Â¾Ã‚Â¤ÃƒÂ§Ã…Â¡Ã¢â‚¬Å¾ÃƒÂ¤Ã‚Â¸Ã¢â‚¬Â¹ÃƒÂ¦Ã‚Â Ã¢â‚¬Â¡

	int* fIndexForMating;				// ÃƒÂ¤Ã‚ÂºÃ‚Â¤ÃƒÂ¥Ã¯Â¿Â½Ã¢â‚¬Â°ÃƒÂ¥Ã‹â€ Ã¢â‚¬â€�ÃƒÂ¨Ã‚Â¡Ã‚Â¨(r[])
	int fStagBest;						// ÃƒÂ¥Ã‚Â­Ã¯Â¿Â½ÃƒÂ¤Ã‚Â»Ã‚Â£ÃƒÂ¦Ã…â€œÃ¢â€šÂ¬ÃƒÂ¤Ã‚Â¼Ã‹Å“ÃƒÂ¨Ã‚Â§Ã‚Â£ÃƒÂ¦Ã‚Â²Ã‚Â¡ÃƒÂ¦Ã…â€œÃ¢â‚¬Â°ÃƒÂ¦Ã¯Â¿Â½Ã¯Â¿Â½ÃƒÂ¥Ã¯Â¿Â½Ã¢â‚¬Â¡ÃƒÂ§Ã…Â¡Ã¢â‚¬Å¾ÃƒÂ§Ã‚Â´Ã‚Â¯ÃƒÂ¨Ã‚Â®Ã‚Â¡ÃƒÂ¤Ã‚Â»Ã‚Â£ÃƒÂ¦Ã¢â‚¬Â¢Ã‚Â°
	int fFlagC[ 10 ];					// EAXÃƒÂ¦Ã¢â‚¬â€œÃ‚Â¹ÃƒÂ¥Ã‚Â¼Ã¯Â¿Â½ÃƒÂ¤Ã‚Â¸Ã…Â½ÃƒÂ©Ã¢â€šÂ¬Ã¢â‚¬Â°ÃƒÂ¦Ã¢â‚¬Â¹Ã‚Â©ÃƒÂ§Ã‚Â­Ã¢â‚¬â€œÃƒÂ§Ã¢â‚¬Â¢Ã‚Â¥
	int fStage;							// ÃƒÂ¥Ã‚Â½Ã¢â‚¬Å“ÃƒÂ¥Ã¢â‚¬Â°Ã¯Â¿Â½ÃƒÂ©Ã‹Å“Ã‚Â¶ÃƒÂ¦Ã‚Â®Ã‚Âµ
	int fMaxStagBest;					// fStagBest==fMaxStagBestÃƒÂ¦Ã¢â‚¬â€�Ã‚Â¶ÃƒÂ¦Ã¢â‚¬Â°Ã‚Â§ÃƒÂ¨Ã‚Â¡Ã…â€™ÃƒÂ¤Ã‚Â¸Ã¢â‚¬Â¹ÃƒÂ¤Ã‚Â¸Ã¢â€šÂ¬ÃƒÂ©Ã‹Å“Ã‚Â¶ÃƒÂ¦Ã‚Â®Ã‚Âµ
	int fCurNumOfGen1;					// Stage IÃƒÂ§Ã‚Â»Ã¢â‚¬Å“ÃƒÂ¦Ã¯Â¿Â½Ã…Â¸ÃƒÂ¦Ã¢â‚¬â€�Ã‚Â¶ÃƒÂ§Ã…Â¡Ã¢â‚¬Å¾ÃƒÂ§Ã‚Â§Ã¯Â¿Â½ÃƒÂ§Ã‚Â¾Ã‚Â¤ÃƒÂ¤Ã‚Â»Ã‚Â£ÃƒÂ¦Ã¢â‚¬Â¢Ã‚Â°

	clock_t fTimeStart, fTimeInit, fTimeEnd;	// ÃƒÂ¤Ã‚Â¿Ã¯Â¿Â½ÃƒÂ¥Ã‚Â­Ã‹Å“ÃƒÂ¨Ã‚Â®Ã‚Â¡ÃƒÂ§Ã‚Â®Ã¢â‚¬â€�ÃƒÂ¦Ã¢â‚¬â€�Ã‚Â¶ÃƒÂ©Ã¢â‚¬â€�Ã‚Â´
private:
	int no_improve;
	double change;
	int num_nodes;
};

#endif

The file evaluator.cpp contains:
/*
 * evaluator.cpp
 *   created on: April 24, 2013
 * last updated: June 13, 2013
 *       author: liushujia
 */

#ifndef __EVALUATOR__
#include "evaluator.h"
#endif
TEvaluator::TEvaluator(){
	fEdgeDis = NULL;
	fNearCity = NULL;
	Ncity = 0;
	fNearNumMax = 50;
}

TEvaluator::~TEvaluator(){
	for ( int i = 0; i < totalCity; ++i ) delete[] fEdgeDis[ i ];
	delete[] fEdgeDis;

	for ( int i = 0; i < totalCity; ++i ) delete[] fNearCity[ i ];
	delete[] fNearCity;

	delete [] x;
	delete [] y;
}
void TEvaluator::setInstance(int count ,int graph_type){
	totalCity=count;
	graph_t=graph_type;
	x = new double [ totalCity ];
	y = new double [ totalCity ];
	fEdgeDis = new double * [totalCity];
	for( int i = 0; i < totalCity; ++i ) fEdgeDis[ i ] = new double [ totalCity ];//fEdgeDis[ i ] = new int [ Ncity ];
	fNearCity = new int* [ totalCity ];
	for( int i = 0; i < totalCity; ++i ) fNearCity[ i ] = new int [ fNearNumMax+1 ];
}
void TEvaluator::setInstance1( int * given_sol,int count,double *x_coor,double *y_coor){
	Ncity=count;
	int *checkedN = new int[Ncity];// dynamic array with a probe
	for (int i=0;i<Ncity;++i)
	{
		x[i]=x_coor[given_sol[i]];
		y[i]=y_coor[given_sol[i]];
	}
	// calculate the distance matrix
	if (graph_t==1){
		for( int i = 0; i < Ncity ; ++i )
			for( int j = 0; j < Ncity ; ++j )
				fEdgeDis[ i ][ j ]=(sqrt((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j])));
	}
	if (graph_t==2){
		for( int i = 0; i < Ncity ; ++i )
			for( int j = 0; j < Ncity ; ++j ){
				double r = (sqrt(((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j]))/10.0));
				int t = (int)r;
				if( (double)t < r ) {
					fEdgeDis[ i ][ j ] = t+1;
				}
				else {
					fEdgeDis[ i ][ j ] = t;
				}
				//fEdgeDis[ i ][ j ]=ceil(sqrt((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j])));
			}
	}
	if (graph_t==3){
		for( int i = 0; i < Ncity ; ++i )
			for( int j = 0; j < Ncity ; ++j )
				fEdgeDis[ i ][ j ]=ceil(sqrt((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j])));
	}

	if (graph_t==4){
		double q1,q2,q3;
		double RRR = 6378.388;
		double latitude[Ncity];
		double longitude[Ncity];
		double min;
		double deg;
		double PI=3.141592;
		for (int i=0;i<Ncity;i++){
			deg=int(x[i]);
			min=x[i]-deg;
			latitude[i]=PI * (deg + 5.0 * min / 3.0 ) / 180.0;
			deg=int(y[i]);
			min=y[i]-deg;
			longitude[i]=PI * (deg + 5.0 * min / 3.0 ) / 180.0;
		}
		for (int i=0;i<Ncity;i++)
			for (int j=0;j<Ncity;j++){
				q1 = cos( longitude[i] - longitude[j] );
				q2 = cos( latitude[i] - latitude[j] );
				q3 = cos( latitude[i] + latitude[j] );
				fEdgeDis[i][j] = (int) ( RRR * acos( 0.5*((1.0+q1)*q2 - (1.0-q1)*q3) ) + 1.0);
			}
	}


	int ci, j1, j2, j3;
	int cityNum = 0;
	double minDis;
	//int minDis;
	for( ci = 0; ci < Ncity; ++ci ){      // find the neareat nodes for all nodes
		for( j3 = 0; j3 < Ncity; ++j3 ) checkedN[ j3 ] = 0;
		checkedN[ ci ] = 1;
		fNearCity[ ci ][ 0 ] = ci;
		for( j1 = 1; j1 <= fNearNumMax; ++j1 ) {
			minDis = 100000000;
			for( j2 = 0; j2 < Ncity; ++j2 ){
				if( fEdgeDis[ ci ][ j2 ] <= minDis && checkedN[ j2 ] == 0 ){
					cityNum = j2;
					minDis = fEdgeDis[ ci ][ j2 ];
				}
			}
			fNearCity[ ci ][ j1 ] = cityNum;
			checkedN[ cityNum ] = 1;
		}
	}
	delete [] checkedN;
}

void TEvaluator::doIt( TIndi& indi ){
	double d = 0;
	//int d = 0;
	for( int i = 0; i < Ncity; ++i ) d += fEdgeDis[ i ][ indi.fLink[i][0] ] + fEdgeDis[ i ][ indi.fLink[i][1] ];
	indi.fEvaluationValue = d/2;
}

void TEvaluator::writeTo( int * given_sol, TIndi& indi ){
	int *Array=new int[Ncity];
	int curr=0, st=0, count=0, pre=-1, next;
	while( 1 ){
		Array[ count++ ] = curr + 1;
		if( count > Ncity ){
			printf( "Invalid\n" );
			return;
		}
		if( indi.fLink[ curr ][ 0 ] == pre ) next = indi.fLink[ curr ][ 1 ];
		else next = indi.fLink[ curr ][ 0 ];

		pre = curr;
		curr = next;
		if( curr == st ) break;
	}
	if( this->checkValid( Array, indi.fEvaluationValue ) == false )
		printf( "Individual is invalid \n" );
	for( int i = 0; i < indi.fN; ++i )
		given_sol[i]=Array[i];
	delete [] Array;
}

bool TEvaluator::checkValid( int* array, double value ){
	int *check=new int[Ncity];
	for( int i = 0; i < Ncity; ++i ) check[ i ] = 0;
	for( int i = 0; i < Ncity; ++i ) ++check[ array[ i ]-1 ];
	for( int i = 0; i < Ncity; ++i )
		if( check[ i ] != 1 ) return false;
	double distance = 0;
	for( int i = 0; i < Ncity-1; ++i )
		distance += fEdgeDis[ array[ i ]-1 ][ array[ i+1 ]-1 ];

	distance += fEdgeDis[ array[ Ncity-1 ]-1 ][ array[ 0 ]-1 ];

	delete [] check;
	if( abs(distance - value)>1.0e-7 ) return false;
	//if( distance != value ) return false;
	return true;
}


The file evaluator.h contains:
/*
 * evaluator.h
 *   created on: April 24, 2013
 * last updated: June 13, 2013
 *       author: liushujia
 */

#ifndef __EVALUATOR__
#define __EVALUATOR__

#ifndef __INDI__
#include "indi.h"
#endif

#include <string.h>
#include <assert.h>

class TEvaluator{
public:
	TEvaluator();
	~TEvaluator();
	void setInstance(int count,int graph_type);		// è®¾ç½®å�˜é‡�
	void setInstance1( int * given_sol,int count,double *x_coor,double *y_coor);		// è®¾ç½®å�˜é‡�
	//void setInstance( char filename[] );		// è®¾ç½®å�˜é‡�
	void doIt( TIndi& indi );					// è®¾ç½®indi.fEvaluationValue
	void writeTo( int * given_sol, TIndi& indi );		// è¾“å‡ºTSPè·¯å¾„
	bool checkValid( int* array, double value );	// æ£€æŸ¥TSPè·¯å¾„å�ˆæ³•æ€§

	int fNearNumMax;	// è¿‘é‚»ç‚¹æ•°ç›®çš„æœ€å¤§å€¼
	int **fNearCity;	// NearCity[i][k]è¡¨ç¤ºè·�ç¦»iæœ€è¿‘çš„ç¬¬kä¸ªåŸŽå¸‚
	double **fEdgeDis;		// EdgeDis[i][j]è¡¨ç¤ºåŸŽå¸‚iåˆ°jçš„è·�ç¦»
	int Ncity;			// åŸŽå¸‚æ•°ç›®
	int totalCity;
	double *x;			// x[i]è¡¨ç¤ºç¬¬iä¸ªåŸŽå¸‚çš„xå��æ ‡
	double *y;			// y[i]è¡¨ç¤ºç¬¬iä¸ªåŸŽå¸‚çš„yå��æ ‡

	int graph_t;
//	int *Array;			// æœ€ä¼˜è§£çš„èŠ‚ç‚¹æ ‡å�·
};

#endif

The file HSNR.rar contains:
Rar! ϐs         _t . $  ^  ֒DXQ3     Individual.cppՁt8=i3PF{M5#yaӘ٠Aݍd<N83~YRVvfy<EғRI }IC?bzfLh%͸Si c),x+@`=_[{af-V*u Ws/kyޚiXV`x	yui7|[
΅8fqG\sY%S{znrFXMA|/P+QGU?eW7exa}SKd[ƵX@DCt ,      3'DXQ3     Individual.h	|Bqe+
Ro]hJ	&vn()Rtźg/XS_

4sRoznԄ<.b--iie.RzЎ3S{9R\kbϡy9li[n0@뉎`zv
Htr5wSY7  ԑ/]v<,d?>ua,]73ÜB(QDwzt .     ܸDXQ3     initialsol.cpp['͔}QIJ(F6mImڈFgDDA'syfsH8= bP=aܹH7 @8FXA΄3Hq@=ڒu07D'lcMP(>-.ƝR	Q
#4>aAusl70l{y~Ni*J2JrJm!zZDpvKؚ6ejCpGH3uLv1- [`LJƎ]mE둪bI0x+-bt`x6TRT#SY:q/	fc43"5}VN:ihbK{P5ć.SjZΤIvd_M/vJtX,Ԭ]>Nvh2]02wpxW^1iYO67QQnvB~qIo DRݹg9N0u-q~|¨yW>&J"QZ3
i79zU4SQF\bwHһ(6}H#@9HN}[`bґFƏy9+DBu[8[XKh5ag`⢄W8m[V@Eq=g;:M31/SR/,5̑!:?^_ŝ|lǾf,]emԱ@oj*_c+"D8/dYhn&[~)Bn?gȕHO<ڒ>Lv'S/IL"-+>ͧg.~[t</9aFu70;{AI/Yz4nuѧm@͸t ,      >DXQ3     initialsol.h	PՁu|Wl]Lj[BQ@ĠT-B~NP_Z9ӽάΜfmG8F	RZSRh @bٌ%׹䦺W7B٭go6M
:(x)%bL#|'`')߁'uA
U|(CSKRpא 4_P-W"~U@Hx=4Wa--;-$5ߤs]t (   xJ  ejMDXQ3     kopt.cpp<ٽ@߃^ym$W\ۺ/ltY;}/aԑoco]}n'6W1wz4J+y|(JXP(Q')f="ɖo%O
L~Xsan{zYϗɏ ɘŇ<p0=͏ w._kwgqxxd-csrON-i*OJl^wmj%՝EO0yXÈwز_2~V_ȖJ	%$Hr	lf( DJfD,siKF.%#Юض
(jH仕%=HX{7ҿŅyP|ٯCpڲ)
W	B1OөNb۸XnPS@)d'p / `eT!a-!@FmW;ӓ-T[\C9is [-$;^L8"KǗ<K%k{T{&ajcKs0;ዬu>+Z:_Ѱk@&:aooeTDo&wXW>?U,͈&;< Vԏnͷ^/}0!k)<e2`K(3"5nJ"yn5ƛ͠^&2)`2%`	*-vWK(чQP(n9F41{UN
&#4xX8xЊFr-]o]
>e!ҚY,tac棨PK֞f	/1q+W9>TψFHՋr~ں75nlp,tُmlwTh
2rιCZ<FL}ħq~,(YKDl1Q@4DM\&IC&|B7Bg,ޛLzqoZ.K4	Lr/62!2IjQح&%wJH	/t3aVM*ҴZԄU #dm.e0w<Oz[V쨫g&(X#a6;Kz=?d,[tJZu+cɀGۋwjEH俤b3mTEEA U>IE_3-b[(~.>A0-ѝzGJ?b U^/J߆|	P_P9:ᾤ"Vr_KT *$7փi`KjicJpqK^ʛUf5'C#+*C{r7B2ք.&Eu#lt2a)w8CO??}$	i1zr<d&C;cx\?*(]?!Wzy0pHXfÅ2XqTҌl]R\;5A+*G3S#@6yG <YNQ7tH.¢L>ԟZ#%1hc^RmLxRa:贂yo> +>aD2ȕUS.f܇أM ZB#vC؊M/E6`#h#S)E1e9FK.b>
z.wD7#/#:g*vM`!E-Lqr\Hͅӓͩ(iFN0+#{\Ts+wOh4C&yOm#dnx3QN*&1m/"Ar8J^0զ2xpA\%ZR\z_Y-MYY_C$X(DթPхT;قC'oD.J
3I+A+rh(IL`KڻYhDLJ]wm
w02D!Vr6IV<*[+YZ5+뫿@w{:e9`R3l"`EJSW@+R\"vꢼC4Iۯm=JAAH%4^	TxW"b
D_ƊPڡ+BSp	-;|$4%@\нhjjU6>1Ey\֣3bA(.KL1JB\MhxqLO۪RvQ.4Aa`K]Cr4oAsmrR2YxEak5b>jjDl3HtC4N $ 1@% (@
AT2~
iH=Ċ#ťA=vEb̻~6BłQ!A[C(4OƙK+YjB朅Ǌ<F|b~5g'P\0We)jmA\⤩9Ã|-j<=[keQ70=@{]/aICbH|eCZgDÝx" of~
poFo}΍BIv	C@%ރkL.[Cڂb[xLpUhzY.-$)cGҪs7ԧfs+@8l9!PƜ!$yx~(&a3B-y.n/p2ocmU,ƈg,o0>e1.d u&QC(^1  &.1Q%CL`D>G@w~(>iW],!eXAS[xg,(s cf1F${}k9`*ĉŠ<4+ܚQt;pThvbzjG 늲ygvc{^d}Z#MtHX@z7lΠ6q|"LXPXS=MM-f?J5{{@;W/#0|4jRbCD(,f /HQ.yh2Nw`5kE8bද3&ʛSõl|'ݡݧ6=4G{Exrh 
n/^q=6|`O1L*R4}Zr5C9R7EpiCF*ǐz>f_h0eG0NR  Ȳn z˱k {ق]16QXs+(=(
eY* c[FSQ6)ŁG1L&mZq֝w6<Ir~ni©^;t|F+!5V^eKDN;ص2rTh"XiۀyՏCb]_KasLݡp q
K0~]aD_@vfu:gƂ^&UQq͖ӠvZVo^&LO)+N:F#n8wIQj͵~`m=W_
5Л-fF&jȢnOȓ=TMˈ	d85Uh;`d$0dR`=1ԩt &     ]DXQ3     kopt.h!̣<بC	BH|8.|h B<	!%A'<B	ֶ呹Qsnfno7w7{Y7x*=OTEpב^MXEA
㕁j0"FcAm
	|1LoQ],FUT
͟m TVH^[.bQ1hpQH,C0z
	:i֯>/4CGJ/m@F{[Yt:*~ Wczύ	: IO]x܋!G"*3}"Jd	3tPCY#Hha)Rk.oO㓗ϛ-^p2B^юlwB>\ENr~Qѹ޴6ve%VV!SПWA
oKafn*v	o|UbvmEȥ͘Xtl>L:;Ń1縜9<}7&OkSr&x>MlenlYZeIy>r#S$,Hʹ/e"dEjꙜ v
bdLWucvVH|s9%5[2*%Vbcs<6p'zy߽tt +   w  &mQ3     LS.cpp {S][@3fiDnstD	7fhBi[M%g'CƚYu}Uvl)ǒsn9>%_
躻D	={~yQft/ٞg'֟fM}k{xKM=2=)?;Z%՟ۛ6yڶjt}ͼ~_ߗ]ӧC\nOL}? 1-巿=k.M׀ї[l]iie˼Vo]z}'7$kc||aoqm}Gwc6FCn<.DDѶlcǋ|Qg}_dOC0V@Xo _|v %LzԔ)֞JޤH) q7L8߿}ҝD
~YcdέN6Itw<\w1=eѰݧ	W}'@F7a`L
>%ŜHP?rG)5cʽ!=dayA|
$ا6Swj<?=<zda,^pi7%5+@F. RW\8;:y8>
|qtW( -Fݚ^/Iٲi2/v.+'˷4=Dk0{$S2@>3 q0]F!UH_Bq5*#iϟ'9:}!LLy|K/n?ׁ;>a23p{P{}إ1ύHzC=M2<	T>\ ˫rhʂk-v{9SKGϧ>QbؐfpOExLO1(3gVlPa]B"Dh}o'{OGgFNs>+6oleDnrW`\{<z >s#$8;It$^9YN.euRՊGP8*dBvC9j\Y& Nh!+1ҮӌK2!qfq,$p(o Wɰ>(BYpB9H#mL0й=̿C Rjan1zB7 :KRKq\!2BLg@+!}+b)*",xcӐ4,&"B<TtRzòSY	+=F $ca"ǀ "Y5-2lnU?=p'@oR?PӦF7ڰHXau)}	4xQMN%Hղ@jg\M^aIVv\Od( ASE&	FB"G B/
HfE&5:qq(mt8?A!2R`qO	h[Ie,&_;A6 ]^bħn9NSho;@H4_D-]%퉭6Ko2e2bR pq-wuîU-BlQww@	K3FȻs6RswH%*]/ $*d;;Rx_Q˿40G"9q`΍y~/QBcoܙ4IP[,V+PF6	BJb4ʈY@xjW\G3LA[@@;
>=Y947C1a	߆u)鮞\
ۙuFAi=_.uĵhk#?(~ᛚO&=),~0O)X fM"s705I]ʤ6>EE;k`%j** &1s=~Q\~?/O?ncRRvuJ).ڇaA[NX~bPb.ooTK칷U5<M㑛߫ qf2p"
,BXщԎW8Kf(_d(VOA|(fj P(13[ia;vȫK@Z06(+$B VkAv}y+qC+[=Ajqg^#b./M˓#ȫŗ܋N4߂owo&&E\D1ѣT!JښR4TR'E)K;0к 5MGt!U537q}̝21H|ݚveNE{Alsx<?)Ogͧ+ODtSqK&R=	$~na|o)'tp.22l]x/`k^n[Oxث]Ĥ2iݼI\pVİK>/gݗ1+܃:4oF*׍B]yR9pWcg*9
`:hʊ29T~(r^WG5jX%rS.<;i!2>1b oh/;U'`?
-L-%y2()vt6x0mK6~txZ0|gYx?1,1gBTK:n%تs	DUKIE	Y!D5c4|EQObEON=5L{SWE0:01]zB몑cw"<0KsBOaH[#i`2)%[E!l5s{p?iPz$H-Q[Yˡ&qЦvKy;E.~JV9Rt#NNVd⓹Tjrco}?nCjY`9xe	uB.il1vy3844<Pd[aiIɗ^ع#P+橌uTo63F<fxye_SDV4?W&=NxYʤj\P`P&Δ747-	Rf1B{}~"4<m!NzIjt#q)!	jdtӳO!}& 9E))#]2asҵe!t:lSsHbt(TW;jFm~.TT:KK۝<̺^f-$N^>v|+ں  f1|  ,@G W*L;.!(k K^V3CeZfk%_3]U4ք>yWŁP<(`tI޹D
Q`Үg꿞N=q0#Ȑ4oRIi̹m&݅>I@@GAXU=aae Z%@ s{8ּ&ͼTOQbR+?wYk6|M%ېnR;S-mJ vM]%>PWahI@
[m^SƤ?w0o8)#q?d.ENMLV|::VPykjkRb?$|g
nC#=K.w1H`pʣh~PWb&,L$xyN硜[JcHRفki"R]sk;XkvZmao7WjWOW?xq:%ΓS
.8cjkK!NÞ0̆VBKbqcn31&!Gʨrdkmt^58{בNj5μ*|d~-Q왊Q?-7CL_VPR{lt<2y;D7ѓYfkEQ2Z4v."07er[U_ǋI]e&$ZnˌG1N/Q?wnJ]!
4i)Z+~%`D M͕׼V/WAfٴui۟œmxE,
]JfE^C3:K>9~x 5d6T=(dKWq! S鞟!2MxI>^%yz;cӈ{?j1h%KBPױ&sƨ҂C2		p#9,I]TU2dLsqW||,J2j~<NUr1uݣ)4ՅUEֵն/W6S>;TGSφJKZ=3uKs`!q0~:kH.0O3B2hFŇ	1+v<VhRyYcj8HȀjάtí]  K!ř*q443?.]ECQ	N	)9eW!|JqL%<))/vC7
p-ׁnk[7jyb}<'P.*쑜s0T)\ej|佲""'@_tunϦ'a@y_cY6MK&wGɯYs	Ml@z^YĈHs<JxW3|J\IM-0kyPC`4m1 ydL~PI\.x/Yz2wD]½I?t|JO6Te/m`4F9n`;Pɩr)v8^.~f]P[Fv-JM	PL-VBZUE;05WrLr$,hVxSd
5
[JsqTH0%n]FQmP
HhUW|Հ4E%\|AɢI{it[kUeXBTɕSklS|lɃ'mFJL~L/!<wRQw|δŅ> ۸k U&ޣ=6s	}bFN	?5S",Z UuUɗ:,ⷿ:j;<pD`ۊ:Is%X6~zM>p}׽<#
n,SWhv+	s<^vt $   #  8DXQ3     LS.h [`7I98m`6]\]l3XۄMݭcHʗ %)"aU?clc5;0ǯL_J3ZѢg<f+no>dc쐯u'3˟1 Yyr]4i@4,E'rA\o<dXunXCf:g Fc4Mdm$ Аn͡oKc=
>PK8 APM@ ~a݌R<??37gns>LH'd913ʃҌ1{ݳyL(& pi˔ Ymky'vDʹË5;Ͳmg 8Sxs$l$}Z$d8amvN xjsD⏇4 G38&g|Ӹuj(R),я#Ws)w;py5䙿G@ Dِ:7b7ܻrxr1n҆Nx5Oh^^_v3dQ2~.Zml_&u!f'F0/AEzYs~H7Kd`j8eOn([yXDdfK#4:g0wҔDAClC3D
9(I8-|nsN@IPh5(Luz6n
{3xg ġMȕ{LӰe{W*!<h)AIGq>HIi9Ifo^bL8M=O%DvAӳ* N~:#L{Dj՞БΒNML'RYQN#Y
F^
pqՃ~{*ڼ`1,MI⬬;ٌd T0|q҉oGnrOpҠl)6M\d:c5G6= T%ނçHrXNKT:VR:czq|7s^b5x`YZY6ْV޶t^ˎ""@FL#Oz*@Ĩ/x`R1ߌyxV&!'uUv>yIao|\(1!s[=/
T@TWV$js[H7E
j`RB1	)!M\r"umCd(
؉@;d-UEYĢǵr]F~Iiqsq;6}ת=FW!f`xXlqZV=!2H^ܹ_M'\Sꍉ_ҡޮ
m/cfh6&V	3] 6?yLi<Oظ
=Wy=J-+A%*ńtKb {˄eq3Y.vPutIhz%)nє;l(ow3q:QO_;p	H>KҬ:W
sKu]z(/="Rމ^TURҙ}udkj8O?gm2[+&
nA֚MqnV#iĘiϘ^ע+x'وX~$5Z3k7>Qs|i;umZMQ)m )Q.%G4
1$b"KZ  4R4k8[M[YOʌ_}n_+r{-V]:E8Tv6ޛo=q"~8 0xK?ǃ'6}XKv,GP
&[{Cߙbװq55t (     . DXQ3     main.cppͽ>px%k5ށQ+K0r8'Ѷ%mu7k
E2KKKMSI?`	`l$v}1vYkA,эǚGj+tR"t7L]B4ADdt	"٫D,NxI6
LOQHG\RG]qRr6Lk;[WC-W+u#);1LwYiIdoamoM?Ǉ˃1 Cb\{z){e?H=0Ж%~_V$ T 2ZPO[!Ib51'*fNqL&T9ŐL)
"f&.<&LtI)Wzk(籭tt (     {`_DXQ3     Makefile}7UP,7t{&+Siި$m܎-CD8</?#4|x>fLeh$:30YOd+.*PS)6èiE)${9.'A&R4IU
*U!'uS*&T]_p4UJH#YSazk2 8F(Q󶝺rzvӶr~/o{[o/8lC ٟe <><I.JXZmU@`kV8͜>U'eӤKoμ[/gC؄w!HL_{:ֺ/t +   0  DXQ3     perturb.cpp̑[5-;ҫL6%U;Rox$fIQ~UfIUR9|c_~&WOsXZd'c_s7EbiD6Nh"|FqBxqqPc[S;;}j#6a]eA_҂X61f'I/gs4Dϓ-h[eg<v	2NS݋@ ZLXQA\&!<c(Ѐ1k7o	PICăLxgybx؁e&8J;zo}|7&x&=T?o@孲h!}Yzfi\%KWgݐAx_/kLaYJv
0Y?WZCrvbP_hPyw%0&[h(͓%'7Luk@0ri+%H}՗ػ0CR6@XnS8a-GV߲&SYsJ6Jh!:LTBYΏ[E8@ToF5H9qKtU=%Iv~gEt;45i2h FZO4,()OlaxջTڝ:5(%' 3%<*jhxFkUXts@\q@W [AԩݞӪ)5@pzyK+o9V)s0^>(Vn:uptj}S*SU5 fbs8=zk%HLxiETs0ќ'b:8Jus/gZr .<ܱvTisV,N$1kwc~2P)$^·lwx欔' U0I蝪=zj8%Vnsg<|1%oBpQ7: &Vl$mk]S9( ^]sXKȋf5lꩦ_ۺc&-}2x Ɯ6m@hk/GhPu20Mk^m[t0[]~\4a1|IKh|eAJ>F!t ) H  A  cRDXQ3	     perturb.h$x>xDH!T7
unBvlbȏۻߏ7qzg-hBs-\9Ś68X?*:Sj>O2Ji'no,d @tT/uQ˜gϤlh|nu)".=cA{ \|rN$6<.Qe}A7-IZq,:դ[d58iPX*2#p~)~nR߀*8?LTۖxFq:\bV54<^7t -   _  "DXQ3     randomize.cppQJiPTd	EHI{	"ڡCn7QЭS79f5s߹G.%K@ہ}ñ6cY-A:Wh:QL͔qy<<C:)"&Q2Y{:XǘqBP_쓘5#kphav7#._.%'M_xMsCLQK&.2PXqck	fqʓQbJ"YYZҺ5'_P9jFmtA\VXl}I-Xhlls?z{56-g~10"duku^M[:UF>v|U.xh[yi#f1@ԙg}}F~8Bx3K {3Fpo_^r*;<l5T@Ş&8!G-˽fT4Leީ,)PKSLɤ!~FxFhh8~./YL*:^XiGa@iil#0:us]Q&><['H8kϗ	;Oka]}շ (>
$B#W@o#lBޫL>UfC7vF]1A+%%	K#O-Ϗp9/%V޻=f	Z*"s.Oӊiw _fo>+ml෯t +   p  v!DXQ3     randomize.h{h#0BQ-8%vcɌY1<lPG	D@(Hŧ瀞
"f,>/.Z뫪vn녫fqC b<(a8I7O|1+rͫNg,x?`aU'yvD5uttФ2
^6t+cc`Xفpf^@va=2ښkq
m90udB#ఆ\%ʥL+Fu}PiPuKgrgPUrf(Ä$ǭQXr*ŧLTM2?%r]UXz'ğƚ>~M;Hɷ>7x;L;X#nRT{U=G~ILNu!S|T<P|cԞ|>4%G.EQ~2SC.x%;o^u!t - 
  )  B MDXQ3     read_data.cpp{ 5Mbe7:4	 @@)	ZK\h4uU|쒋y33hU5ݕApUF=87}6w⿛0 ihfh,=(!Fͼ'WHӼ~w 8 ddG$q|zV,Ra qr9<6DNCs^7=6Az"_Pi/̶
a7j"`Ճ혖T|1CFcz=Q蓥PeѰȮ|XdWH((ẗdHnߊ9(-(0ib؜>C?`1_fy71+\-^1ȣŭi
uk:N24xέ޽M6wY:7NtLXJK8œ,N2hf&l"~CJK|R$/6)hN?>d0I_OS[M4mT`Ra{?2NWsx4'=
k7T)03"(} %ŎH)S<3m4+cQtՂem.A6ͼҖ94]7x[̯FWERA^\_x-M[wnd74DjL%[;<|lugT|?Oұ{㗮3`&ĬƔYqK@O&~`gұk))9v9t@/5pWiCDƀݳ?_$7j|D,%ۗ3(Sl~hJ[&Sګi
䳍foW%yi[2bN1P?7a[->=QsǤ3g 񂋍+.5v^c0's:M:1@5S6c|9KLVK%l=(zL-_K 9T/d/:rwery)$h?iZ==7?&pxf[m`O_"~PCRFv}6!ʤ[,qTN3սsIUmwK;"9D!g,8ʪ0^ufrNU}TjWI8^iʨaq\hjeU,&oJIuOkT1c`|M?oS{Mg B̈eee4Lϖa%yrdM_'rֹ-g"׎KH'-BvhKhB=EO2Hsa5{"xy8pOKڜQY#deiˁ="tL#-rro"H
cUe"{+f1=~yrEtz=%{
'\?m6j<lT6$BjȭM^THy{3Rdp
Ik%pKGk8:?eoҙfi2a=iuMܾ/ddўz&⼀wۓ؍b: >78lNM;h)ܫOdpB	86 cd1p]cb3%<0E-OZG?'[@Cr{pz7H'A73Z5wsy\xJц+>姬ѿ#03Y6Ѻ6EZ^Зۮ\o30<\gRBHյ31ݸ0s"~ %9OQW;Vc="i{h/'"Xm%	Ձ#	h=Y|Q ͔|u+,6*SmEbBϷTl㦙]Ngv[g1ԅT0[c8|9J1CiIULn&.!E EHyǖ&9gHwfNݿ9uW4tqsNyB[;͆r*N,x;@iij]/"+V,T/5*gTds\.1>}}Bx.b^E}	3ptTS]Aj +$B6ZI!>h:CcPu>9hv iFW+%
=|fgLDLDjߕ4AY6pKᰰx7Z0P+Ud/V^3b!^;kIj^:,%(D,1s~QK4\$_~_ڔ[dLU"`~JURxf'&X$YF4	s5ʁD03Pox]T,)8X<c\r9Ff-G3.LT>C,.KM=$A(&"Ehz` DISRH)[  մ~uo,BtHk(>ҔTo;CP:vfT*=b%H:Awe"_05g~s0,^O2aZ~hq08a7?=9!"#w {JE<LG
fyTߝ7p>+87'\ݽ^a 2&z{[X6Ep0A6f{hZgO@4t +   "  ¸DXQ3     read_data.hLwJt%#LLAciVө'`cFL<t]Ctqz(s?//G4Rz{c!OA=hDX4[&J>GPO2%COGIzt}t^"'Z$Ӹ>"^:LFjY%?;J=hw'.pI^H8=ĵV]s^fu[}MlolxmY"[Ի<Jy/ldw <M$gӰ/c(5p&ؾpbD.1Qin;	а(3u8Ǚ:Æl47,)>w˴L@cf}r?jh0k\,5*θ!Յ&J{RV1hW:c
2/z@]bZ*j;x߂4uZkd$s{L0FB-u4BG&"3~r? gY@bN=ں1D>wl2~F?!`/*s0kKj{r-4^CМZtov=M>}H˹numn:oiD(7PIFsԕ?$͏;5K-17.Z$iFCÇғ4]it * N   Q   HDXQ3
     readme.txt	XҒ QmMR6C|?;*b0I}Q\ѼT|4Cyt ,     N>
DXQ3     solution.cppM͝W;ܛ"mP }6[`P ښH/ɻ2s$z$8pa9<d?s9-&"}#q@d焬V+Nh!'g暙߇+م*GN[e%܌\YmaUAmVc!.C::<)$9;'"|o_'W7VWx	z˘VXsd[C)jtlB_O@.a/5"ـO-Q<*{d,@¢ο"voiS'&td"o5`֦[3N2=&4&T÷8yLcuiM;ehcEiF؟iZW{CSfF܈b1F܄5c/Lx:K4:YnI
' R皽M=uVMCwfYk/a-J$;>W%ᫎ/ǅKd)p_g[[P)NTb4<E2M# :pĕ6Vak<β r.mo뎮t3ʅhM)2S\@}AIxi(ma(P<y?KkɤpphX ZD.Z?{mUEc09EqH_	*f7auM&J2:1ՏUhFnd|p~,Q/*tXl$u	j6Qbٖ+%$Jw~w	^bBpKu? L%_ U 0rN
uJcjZZu.TnWJ@m.m/PJ:g(Ң\(EQf=$`yMLᕸA7\'-T4XY43FMw4qJ݌ֶ!) |%`tE׾gT_¸oOY%DU4ٜ.Kg
a'4,
8S*,!EAm(2<gRx4IL:Y}EQءܗ #ץS^JpzuEk,~mp9ح3_oո]h-hUNb܉)6CY(G֕؊]e3T%٭6kյ(%hjS<A"Hۑ	7D{ #~}cչ/ؚvDn@B%Xkjn绁(YoLJV[ّe3gy;*t9zP}#ɫ>cЛt * :    	DYDXQ3
     solution.h́:xυIxkQ@h( aԑXL$ݣEhKlm8Ri#d/0ߎ%$~`@gZ\G+BǑ<PFEs.g.K~4>i%u~nש&'!u~9, <=m<DGm:d}@#(itBN9T::+2J4
9XaxD?HBUx8%ѰCSE3y0Zei 3=%#&cfJT8M#2p]h 7o	g=Ӫj.VIގꦻ>])ÒF] Ch 	0b5]L߸'l>W{~ܽ*	$@Qm QE"lY8oQtc 37z7~zFYԷRmy\ݛBRv5۠d<0:5ZV/6{l-SpiPK))TmUs,1nMUl;]`bn`_Ǔ:rGdpA ^'x<z*)A>'ɪXY>;aFW/vX8hJ]R'̋<$[QkFoүs7V_=f6/0jkW%+eS&b& g!%2H.qzjǶBahĨ-qقaTd,^8Kjяu6y)2D$_x8CZKͬB)zWw~J֪ru%2u| t ( N    6DXQ3     sort.cppQAs)M!"AD(h&&ǘBqDI<&kP4MD$ڞ"xXlcx:?Jar.?uUB\V뤯LNLBVXj.Y*RTc(uY2bY7UP)mw`1Fڧks7Zk@W3MIKH:>F8+|Ʉ2M<$WxA'śP`¢Lk"LAY8+pXuݼytWOT8N-F%lrqd)fN	T\^$ҁUJJ 4<8rT%!=FH`'.lv	l²evy~*s:'c J$.Vd6TȬOQyOț{H06}ֵY߳v}85?{f0d(F{G6};MSg]հ<'Kd_7oy245)R @-$\8w^BN!L4c+)_B0OܷԺ$odkzYԠF|x˴e fX-`4Е4]>}Fy
*ІJgP`u$s>"w3(^ =3y}ɨedɋ>H9bs,vhXK-AHλعQ<=@؍pۓ@2	/hС	s=۪ A{WX/m _lɝXK?q1[t &     )cDXQ3     sort.h{:r9%98#Q"6R##	y	e; ;@a|q6%7n	g	zÃիW93NGἾ9oy@eZMT	2%pM60ma#uJF$1$J@
tQy2&C};#MbA N{+
V	ESAe8H+ebq@*iTĠ6G	i˕;"-p$Ĩc:F0\jd]s]ߧ:@Wzl+64`Hǖfu'Fub78Ӗ0[|t]sH㻋b#.\sg~spsV$>eg̗w6$Å`i[#3'ny@Qs>2VXe/ I`C)ߡE!3|Q(!J3%^P`t ,     DXQ3     Tstwoopt.cppM_HH(`Ao 05a~Idj"blԓdŉ&{hk{V`=$#ss~s?tkzā7c@k-ޟsiIx!=%z>}>3:o:Vu7pNl/$>ާbۓu2Үy(菋u>TђSj˱UB{5y=cȔi*{1k2wWyv8ZZ9{ѐ`fN1oKi>P=|d#bЌ{wz}rO6VyQb\ؾwýٶv;Nhwe_v:wV N5A;f,/A
pjĮ,Q)c݌8e=pFxCϼM]Th:Ѽ@s$	 $Bw;KjVf|+<1!Zޗv+)SXDlc J5m:ǔ37ğS^ZvJ'B(#ȥ/DWq#wZ&R%.TDDOvK0ZrЊ]ƅ-Jѵa AP	4,3zpγ~iOQ"sXVIi>|9 uKQ3ʝٓY!)6lBq.t3ȍyZ\V78~wr@YpoNƹמZen,jķXVmT0@,nB|B!,tƻ/ːXn3٪åF@`xF0A1YxKp=tao0RED'myQ#jrd}7ɡqb
# wN}GJDmq	<e& k33`)0v;QzDh%'[hF=&}Uc].,!wxB(x(Lv6E*o &<$+׏gq?h"VX`;+RLׂ[{H+MūQQ*_d~ZŷlS˭nB8kxe<ޟIbYb^BJB_nE̔D=eo+k	.$Ir<MbY8q}mUYv	u-_|n;buN&	vԸsov>x	Oڰwy+c46ٽaKa,jLV]U`R*FvT:_\-3ԞՓ%gy+'AN֭{Z^_o+7u9P#tcTiO@k"&'W8(	Us(\.-WA&n3b|}	K_KJb,獰223A/̽OAwħj.Zt * V    DXQ3
     Tstwoopt.hLɽw|$x;V.fk)Hj#4Qe-ȖU2L4=A-e2|}q4}m6.6r :iWDΙEzCP}6ԫcZBje)8~͜.v#~Lc`F-_RYd $g׬{J(O?ۋ;Y?SjdrN׭2]flDT`D*əcY/Qw+Z$ԷSD5ѰY}
j]Kgbͮ`.fRTԵmum vX+j<!~SnsNCg"?}lt '   L  !=DXQ3     basic.h	L_àt^ݍ6;$NGu]\KI>.$M3_ף>`ȃA덿w

D< {6wz8UnRc=<K7hw{bժHIhmXɈ-Dw5	-RM){
{"V	7!Q9 ].!ͯ|ϛ'=TjeJyIL%XT<&7֞daa-oz\U*!ҳSnzy(fўHCۈV<d|qb~ǚBx]rBޡ)~+i0`V*|ddl9-|DCZ:DзjGc~aH	$*:-<Rt㛎P5.ܸf-7j&46nE;Vp,?ΪslU^3Ä)mk]t )     &DXQ3	     cross.cppO][hrc1ڽYvG\7V<JX32gBAxI~	=''IyQw[IY4hi6nu h5_kKXcZÄ$l/Ê)#zl\y	-,_.\X1L\zQ]nppmq\1Ⱦ/,g.t`ur}|[^h@!}m_?Pn&] s_O6	"a/0	>{.!0?[J H`*L#*̖2=bRs
1'$7&dǕ9o^9vSZk鈛r\5"@7.fm`V%>V,2;n}}5bȌ/`jtwz5>9(}q_~M!{ ΂N
DW|!ӚSho̭pQ/m-Eݨ
`Aj)PF74`pRS3y<-[668B/ۖn|rP`*7F==Ϙ-|p޹ooj*N~w/L|-rG9]O濹vY7{ҡӡ}ݑdz,F/Iá* 8QG-F5!{zWߎCϥ@ri^i=	o"']COvpѝf훹<zij|FҒN4}ESpz}:',F9QϽ<r w]AnSU2N=Yps
rٔ|Ɯ<	J$Wɻ@P3~ojV0ie#BS}0/<b{l5$ag;9O!۝R>^痕1z̰쥨mg PC&\@[e¹N--םeHFye$U`*~>WQMge_LFa 5VOs?qlcȐA EABJ%*TӉ@nNVyc~w ͕0bJc-kI71͒+jttl<M j8Gǅb+0nCeM栗_PEX sW	]k^/@;Oxv<^l&Nr'q&X@eQLW=i=R<F_96 
+FabohOQ#[`, HzX:$]}OOYF5gC=ψ$sCذa^	gDQuT=13Ofy(,Ms7,\@#cGa{]FdSmR.< mnM uV|gH]G|MCz'㧘M84}yĘ5Yf]SQSMdMl&CɌoh.Io*-g4oocqM*kf:K2;Zy)8Ї &B(YT1boQ2V-	ţ8Q:N~xĶEDs;QZqS( UKGf5Vkiy]V0 C~'`juҋ9ɩfYC`{9j"XAT^t3Э`4	|Y/%QRv6satRDNM1(?N4Oc`qlsgF'nBe4h79F<A/D8h8:OprS%탇HzSe6E\)9$:_ޤdL0+l3Yu ׽!!qU-ĎUD2=M(
!%M,X]"-S;ݰ-'@$$jڏWLFFufg88\eed*
G:̶=8v}:/)OAZ-2Zp05-ICUϬ(۫lf|(rnXnc#u(kSά,3怸t6]h 9<f#.͎Ow}i7*+BBeGCc?+6;|ҚqlvDqHF8/s\jt[y!dϬ%g_ *4RYӮjð>j@}@oK/<尲3Y]xʊJqGJ_c*%RעٱUG+娔jy\Т/T@7BH$CugWbo%Ţ9tHȁy5󑘯Lnz~FbwpNŧT]Jc?S:gNq,_L)ir)RJG1$ibќ1h(&u~~NWF{ͫŏ,HpEU}vmRshz:ƨ̹j4zS<
-AF
w`vM7)hL&J5M`_EW"Go48OXCO6 
F)"ԤUOiÍ=pZD跆@l%kڼ=ϰMv-uu}t"K%Wfi8B0os#JFvi0OzvD%#}V@+i$yBؑB	 G5@)ndbnFYB3|lF@^+"/4&KD9W,)i=S+g>LSOZdv>)m,gvnǴ9bP?|"))'")sdgا3C)Vg^\;Jq'96ոh"U7Fce0[p~,>3mh@o萼EكeMA)T5-FmǿTV7C<wLo,vc-G&͏-Ip/ 1e;'0
"lWذ#\8TlM"\ Ѕ>6"FqZv#6+\\51ol.,%TA`S74xh'uj^\0\{k1'MwF̴ǆ;\eaJ%`L #! /v3x"qkt(uSW4DP:{r˓qazib_ghJr8ݚbLAvb	AT>w*5llzQE^oq;ü6ͅTs{Y-*D=s'Ԝݸڍ!XYP/ L.4>-{>e<ri@ʫ)s<tRSfIF;g`ؖ>	0.x#̳<4w;ZQy6n4ىr<I\U-K{(ޣavc*y/lxWD9{䟜Xk 	'}侵~qAH188b3Z	nIP)Of&X07(8-;dAHԃQhTY`&F;qr'Ts{z|S"ҿ608];R*4UpIWhaJ+ALvf(XEq6cКu2ⅱ#.c+uԢ]:
ܯR\b~Y @k6fDF|j#%^j	gݙ!NW&U't|l	koomQo"?UOb/dUVQ.3<RH^cC*<)C{Ij4D5A.)ڊ*ىIjBwYQYTZ5Gh."~,O+r=>IXЬVK7lm,rnIA o+]+.b+3EYJ5%+N5z
PBSF3Y(8l&6`+Fk~E*oJUV%!۪n2r}_Z(/nhF$y8.ƫ		

k,WzQ@ZD"m)+C̠Wm3iZhEO2Hnjui:dWÍ.l	AIm>ɝgv'M/6=>(@Ywbb(Yz䑄NQ $=]TEɘPz\j3sCTx}؟XDYhctNX3ui^yu>QŎ e?ŋO](wxzuĐٺ14XlnG[0-~Uf6AJ
XkYG#@tmU	 WgF*C1(ŋؽǑI..~,B5NN7|0-L;Pw?'6"UL7zEdB9Dsm,pzִXh`=6hfEz8V>poDroɓKttWC*(u3}340%!*?*͚?I-πܚ?HkKf}%|O@V7aGJe䝻Ɣ;t'4# g?ܴ>,N4Y`ɿ)qc(hMz@5W'jwB}$lOPxَ(n2x]7</2Y@</a	*%%d}QHjѳ2ҐahSvMzi:'a3k3FYJ8r͎o//*e/ǞKݯ?='~~k~*Ú>}Xb_?'|f4K&#K|W5 MЀIte|ZY5k~GonS	Ȅ6ayڣ<1YTv)O숧pKC89tfC	~(\?mJZ@z%PRgJZP[$uST%ؤrB"zΉ@MK(gQ$w5э؛ir%Pr?T1n({:4YP$tNx^BDP-FN^HQ>1o0SuJ"T^.o
&NU劍8jSz&~.	ر<ݝBhh?'fd({MR]d%.A=#"4G'Y,`*4G'r[`^ 1&^H0/<{`]vs~BBbyQ\>d᱖E9t'W@qkYwD\teጻ,2DO3y,ӱ;yJqnx*.<1ϸN%{yHґzH^xLN
-\WƲ5]*]Bڝ	RPє9tHQDW%kD='0t?y٨ĈD4i_Hm
ѕ#(k?1SѩJi.@%B2D,_SDZ+=B<t`%;[<]+c7]osgO*[ Q|Zb̊UR&-Fɪa-2.!>te|F+O`t}S[ܹ2́5YWmpݿ~R~lo6yu`	|t`f3CS6z&̗c,kd%<t";T|m[E3kdA40}cuUx??-̔{Mç0bJ1~A(7^=xgm]cU:۸9ӊkY-/H;4c&6i.k0[g=nN~T ӭOjHhުQ-{HiѭBzmѪԮ( +"%+LkЯoq\a#Y\?(/ #oèJ?%]gb;p_Y[Mzur$&<LH8,d0Ox b>GZ=04=槡
^7;ݼ}/ԁ5LVk>4~ֈ,MIO<Zx/!o	yݐ7B]Lt ' {    `DXQ3     cross.hAW'(JC1@)4v8'm,)$u:ݢNEN
	1\`$'C%E<<:JN[{=?%g{>pnpXz"4sk@"e"4Uqv>Gg&tZmQt|2D.i{_:<YKʤY=:#]?RgkQJ'MY_%:@&*A_Ӡ}͂:ȖvUsf	(LQtINV&pG#HU197kRHUtнbMo)X K.Rfwf*怟4h'/ڳ2vUm	uQ졑Cet+X ^&>:};~p|w<%Kgv¼ۄr <%ueҜUJ7V'=1wv⹰$[33cÔ){mN­=zb$})jӋ-pNYJ<tߒgCsGĩ]6kLN1Pa]vѬbnSl[hW;'DKᔅQjp.\$`.w~A'ZLYvwdawDԱU0dKޚQjtˇCz#]|8nV#{I_lZK!yq$FfN<M!zQ6Ucv(ac7u15'B)l _Yu?I#C_?֮_,a,dub<Ѧ;Ѽ^z$Еj+H=t*jcnQ;jnTOinTCם& QU[-`e4ǦZ|n?~9&vO099&OF)_-wcB4]׍Vl.zdT^^DBJMJr4XLBYufBE:NK~i1F)r7M,5_)\pkhhⶁz2Pq\/"Ya#3ddMpBVC9R`"溎3* ̎eKaW04Ǫ#գYk^b󶓚aM#$@٦rʳ3a![+qro)	G5XgL4_s%'PvM6fbGe
N8vʦ(U=
OU[)pnwpő&A"QHm?<4g;e!+TOJgRK紩0# ot ' 	    ͚DXQ3     EAX.cpp	Q{	;қ{P,+iBF9Ij쵓ZFO7RMd97ǳs?}c/gt`@']˟ÿ?ΏF#zBHSG~7גe4ǔ9SI*nohpRĞd.F?TXҲ]+3/,# 8DA.*OB~T4m_n<uaKptJ^M  QfB@XU!g.4J0ig%-)}hsi|b1P悥*{ϏuSzm+juZg	
W)XqUzs44f/Q׸Cb@rи%OEbi%"򏫎ln\wNX_UNzU_n
D\B_ڭ!f=xŀ~Rstͮ||pjU!dZ]R٦z\09~t %    (  
DXQ3     EAX.h	PՁ|	;D2nQ+!5֓mQ'qEtdӜa3{:txDːC·[EIH?iuخЊS,iBG6@*8d+Zke!a&5	tD^m汆?RTVEt𸍁\L' nhUt / 	  b  %	6DXQ3     environment.cpp!{>WDiCm@$z67,Z-a|KF,l{-n%ݻ% (=<-G\a%a)'&/\&s3?Lgs 90gNu~?Nq-mQK)mTVtYS%m6K>#ܴNvY^V.lѼr?uWUbViv}{ޭ:q&Q轌Ѿ+Suuypa;zCP)a&-_jj>עp/{J=F,C1ήy\?Q;cM[wό|XU9i R1x֪E W.ҵйocM09a?/zvِ4~GTXb,g7>}Itk+Ӷi}+t }M5sY,j1rB	=$źͧ5V+J*D"-KI1VXf5&٬\G.W7>%`|ȭ_N`U;}ed!p1MPgZZBcQ0aض6+7ʨ$zdfOozn5s4'>^3=p%|R&]bĞD1:K9՘恏l,@չe8Ix#wiypb"k쪣 ̧l*0]K]%}lt9951^?:FFp~(H(\+8%,iET.BګlTU,j~ÂLx)M|)ߟ$oNX}Gw~3cb!$IQLпFtEvB[pfHuƕ#!0=+[y.[?]lJ95MZϼ jRjXNSpp>H{İY*eJOc>]Ia~B/|)6+">{u9̯,7YTPNan :q,HքfAeFt<~D/L'T<Zh7;!2T&$Q:-:xVΪM=HA19t4,hX,yƉ2eɐƕ)I0^_gws$=;.ϸ)}KwNcτx<!N}~rYKj_t;f7\o_|wN5ho ߘxN@tUS-
M],|oEDt8陵H?.!hxԩ$I |_o488"f)dǋ	*E+.cQ{?_	jPf,"NB4QgM<#ɏ'QɬMAHۗ)PI6@?ehw7fw忂MbM2uiEelQv,5$J<P+Z*|üBƉ<HLc,ľݏ^Cjj<Bv(cS>d9D1&/5e /Eb|5(4uO!:o|BGp ~\Iŗ8)w|nK^89_	'(J9/~
P w<HSǁ}3~w|N*!2RmBoc~K7F-J_Kt*-F>hUjo9xo{第Z+pGh/[DE_?wCt7oc xlȃs=uOoM!ʩT2zcqt-#.+XLR->Yjnsfiб>CfދTi*\PR4lP|+8tݣ]^kmT?i*iLXe)#(;T7ًuV9d쓮|!ڥiǷ'v-gdK@FkY#a)y h~fZmą|!6M1hu]JݝmM}pّ "kZڰM1|2lnrz<P[EYȰ^P>wEj6 +mH37">ȻEfڬ"WK H[_nx/@Pt -   %  DXQ3     environment.h!J:\jUed$YPU5wzV_y!PGYztI	[pRJBH>
*q=73ws[٭PQ(<z999n_bs3:3̍PJi-b'3"PREtФ /E&4v0_.)ʭ`/&Z7Y9$/'/'յʷ@yJ3׸`[	'8yAuyE+A?/<̏+3ph[zqgBҤhOgZSqZ"ySۤ+eO5b9a<ԭmͳQ'@,X.VlWyiǓʦi
X}І3StW%gvEVoޯm0B5d(Ζ.#с?fsk5t7{ix*vq_j62o0}a)M
NE'A5k׎[	0c^<
8@IFl`d(wz=xZuN<ْv/lW~R4)Bh} VSr6N\˽W&뒛VX?B7pu
6g@.3*].T+'}I-vyYZ<0ԭ+<()Us&@/gt(0
zhWzȚM
xm҈5v R,w	TYRNZ%F&t/]WˆN^*l,K\`<u15**k`پ.PD q$i6X<OL[
8ppMI_[4c0c$n-/I,OA1warߦvׇmYkhSKs?C!|V~c~rqxs7`QpB`Љc@6vjNUTG6"3Xfe'<9hP؅3'Tjz|Lac	ˣ|GaL>Ԥjayzg^$I?>pSY5/*H ]/38_kbu<FPHOɕfjP#0j-z:aR?t!FOUIe<j.zcG2'G>7/{Kewcu]!La}2p,N_h$>0V%`ZeC^#B9Yn8fD|'CUUv˶#H14?M!vpdͅ,<	Bl(m@ F0 a?l_)3|i:sL3)sww]Bn}CvQD["		1FYbrpx_X<h])̫lMsɑlYjw|>2ҞxcjA5دp?RT;]24bKir`m>U<
Ok IIRl@C3`3G,``Zk&,vCgdۡQa&-^4~N;SQY|n\5i9j׵/B_!|o?t -     'DXQ3     evaluator.cppQ͝W0t	E&*;·CT,%JdB	}ڈSiQ9"KF7%^H|g3sywz}W]l;u@g'$%V4vոB'X!eɄd+T_e{[<64?x!r<<Oߥ3V=ԍ>'὞O媫bakn.+>;za [5 w/;h"cow5G-yNQM@֢j?;P8J@#.YuQ|OCi!_1g#Dhg! #^r^y~΂[`ºdB
;<$ūU%cOi|:f1+홳VT*EEϗj])\,/a.]>Khn4liޝBq±a-)edfZ7mHmtDXյor 2Cن74}BVg+!kGatPORT%T,4,GnG.GQԹ%T$|0'^fMjMhdFw0w#5zдeokC@8LRUINSj(eiZ̼WvYMLbtuMGfR:\@@?s׿s~tO"{雪<>x]bj(j@'	5YHa[ԀPZL?
˻I9=}}Gw2qFC[P
B
NFzAkQ [%#|Ta~Hq76IYR]԰.urF	Ν	CKP,YƞT&-ٓ\(]CLRK	:>yB!tQ|kĹE%ަHj+N\sbmfvub-z:~UR+2fv|<8%hRf0`ɯOh%<qkV9K7؁4"ps_Fjujs(=&(⤐_[>޻\^,;g6k(X
fٷkd#; xz/xV/nLI2@Bdi;ۭkSPw\DCJӱ4= ܖs/|>k-a<JЪ#Rhę(T4yi\r X'Qōl~#wu	!MUdƊťCڥH\[,+!eMWCI;Yd
~Š04\z0W'ʗUE3y֤CY/\'pcR3YT_dDʝm\u"d%jX!M ?%TФݒ|KV}uC5As=st +      NDXQ3     evaluator.h	Q́r`=C"F(HE1^5mcF,!!	d&$473gK2*Zm6W8|_WUzo|!IVev;tOx4ĺBM*/odODUT5+KO4TT։6܋ELj
|Y|~35Y32Y=s|ōt&Hw	C*b`nw3!em|!M}>Tχ*WDnՑUr&"̵JE|x呑P]A0:3ٯLp64iv\.=G>nZq9G%XQur:\E	zV"Ĵ;8]}b%攤O!E`jy!0	f#mN zd11ФtR(JPCddOm\n7c{8
_x-7PXyiyx.q@oo{roۛtͭc-_Or7-;Fk/8өg$[ld,nT	Ё/!
Yڤϱg+\ k	/J4@bu|=8ѾSF2St:l+J7MEiψ#P~:z*ew..JEn*zdYkZGJN.rf_,'t (     DXQ3     indi.cpp{JrܖF+oaTkPZRwݨ	Km(wRM$b|'spa^<$8G|I Gf_0xnAIÐ>1 ?Wr@i	"yA>B@6tL@i##q\}Bfت.&uyԪg&Es|l43ϝu5}Е岪"z e IӻZ'BҶ!V2qqU.]F)3F.\Z#+67-ީm,ʱ}aXcDL"!lxGx$hvPi+=ru(A	h+ޥ3m>f,yCDȈC
t:߃c7ym*PvqQ1bM`smv8#^2trpo]YI_3#bߗ;j^qr&s|ߏpwiG,kۧؿ}Tߔ-uTPWͬ/rjPft &   3  61VDXQ3     indi.h	{& AM!65''@'!d#VhMoqccpnspq!r~<x,ԱnԃS|luWYW=WyytUUƊe֧^lJADly__vORAsM	h0,pڏVS-|DhKi+WVĉ""L:4h{%(0\nrgdBH"dPb ج7-u{Z%SŻB;f+a;NAlWյ?.Se9<=YL05:6Lgh/%WE*K=;~{sQ=螟w~9v͐JhvÕ1q^~O'Xa@.гGɑ?6xO)Q88r,Qcǭpѡ#c1y26b)aM}m?"l=nOHS;[+=s@={ @ 
The file indi.cpp contains:
/*
 * indi.cpp
 *   created on: April 24, 2013
 * last updated: June 13, 2013
 *       author: liushujia
 */


#ifndef __INDI__
#include "indi.h"
#endif

TIndi::TIndi(){
	fN = 0;
	fLink = NULL;
	fEvaluationValue = 0;
}

TIndi::~TIndi(){
	for ( int i = 0; i < total_fN; ++i ) delete[] fLink[ i ];
	delete[] fLink;
}
void TIndi::define1( int N ){
	fN = N;
}
void TIndi::define( int N ){
	total_fN=N;
	fLink = new int* [ total_fN ];
	for( int i = 0; i < total_fN; ++i ) fLink[ i ] = new int [ 2 ];
}

TIndi& TIndi::operator = ( const TIndi& src ){
	fN = src.fN;
	for ( int i = 0; i < fN; ++i )
		for ( int j = 0; j < 2; ++j ) fLink[i][j] = src.fLink[i][j];
	fEvaluationValue = src.fEvaluationValue;
	return *this;
}

bool TIndi::operator == ( const TIndi& src ){
	int curr, next, pre, flag_identify;

	if( fN != src.fN ) return false;
	if( fEvaluationValue != src.fEvaluationValue ) return false;

	curr = 0;
	pre = -1;
	for( int i = 0; i < fN; ++i ){
		if( fLink[curr][0] == pre ) next = fLink[curr][1];
		else next = fLink[curr][0];

		if( src.fLink[curr][0] != next && src.fLink[curr][1] != next ) return false;
		pre = curr;
		curr = next;
	}
	return true;
}


The file indi.h contains:
/*
 * indi.h
 *   created on: April 24, 2013
 * last updated: June 13, 2013
 *       author: liushujia
 */

#ifndef __INDI__
#define __INDI__

#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>

class TIndi{
public:
	TIndi();
	~TIndi();
	void define1( int N );
	void define( int N );
	TIndi& operator = ( const TIndi& src );
	bool operator == (  const TIndi& indi2 );	// åˆ¤æ–­ä¸¤è·¯å¾„æ˜¯å�¦ç›¸å�Œ

	int total_fN;
	int fN;						// åŸŽå¸‚æ•°ç›®
	int** fLink;				// fLink[i][]è¡¨ç¤ºè·¯å¾„ä¸­içš„ä¸¤ä¸ªç›¸é‚»çš„åŸŽå¸‚     double linked list
	double fEvaluationValue;		// TSPè·¯å¾„é•¿åº¦
	//int fEvaluationValue;		// TSPè·¯å¾„é•¿åº¦
};

#endif

The file Individual.cpp contains:
/*
 * Indi.cpp
 *
 *  Created on: 18 Apr 2020
 *      Author: Peng
 */

#include "Individual.h"

Individual::Individual() {

}
Individual::~Individual() {
	for (int i=0;i<=v_num-1;i++)
	{
		delete [] sol[i];
		delete [] sol_r[i];
	}
	delete [] sol;
	delete [] sol_r;
	delete [] fit_tour;
}
void Individual::define(int number_nodes,int number_vehicles){
	num_v=number_nodes;
	v_num=number_vehicles;
	sol=new int *[v_num];
	sol_r=new int *[v_num];
	for (int i=0;i<=v_num-1;i++)
	{
		sol[i]=new int [num_v+1];
		sol_r[i]=new int [num_v+1];
	}
	fit_tour=new double [v_num];
}

The file Individual.h contains:
/*
 * Indi.h
 *
 *  Created on: 18 Apr 2020
 *      Author: Peng
 */

#ifndef INDIVIDUAL_H_
#define INDIVIDUAL_H_

class Individual {
public:
	Individual();
	virtual ~Individual();
	void define(int number_nodes,int number_vehicles);
	int ** sol;
	int ** sol_r;
	double * fit_tour;
	int num_v;
	int v_num;
	int num_s;
	double fitness;

};

#endif /* INDI_H_ */

The file initialsol.cpp contains:
/*
 * initialsol.cpp
 *
 *  Created on: 17 Apr 2020
 *      Author: Pengfei He
 */
#include "basic.h"
#include "initialsol.h"
initial_sol::initial_sol() {
}

initial_sol::~initial_sol() {
	//
}
void initial_sol::greedy_fun(){
	for (int i=0;i<=I_data->v_num-1;i++){
		for (int j=0;j<=I_data->num_v;j++)
			s->sol[i][j]=-1;
		s->sol[i][0]=0;
		s->fit_tour[i]=0;
	}
	vector <  int > node;
	for (int i=1;i<=I_data->num_v;i++)
		node.push_back(i);
	random_shuffle(node.begin(), node.end());
	for (int i=0;i<=I_data->v_num-1;i++){
		s->sol[i][0]=node[i];
		s->sol[i][node[i]]=0;
		s->fit_tour[i]+=2*I_data->Distance[0][node[i]];
	}
	int pointer,tem;
	int row,pos;double delta,delta_tem;
	int size_node=node.size();
	for (int i=I_data->v_num;i<=size_node-1;i++){
		delta=Max;
		row=0;
		for (int j=1;j<=I_data->v_num-1;j++)
			if (s->fit_tour[row]>s->fit_tour[j])
				row=j;
		pointer=0;
		while (1){
			delta_tem=I_data->Distance[node[i]][pointer]+I_data->Distance[node[i]][s->sol[row][pointer]]-
				I_data->Distance[pointer][s->sol[row][pointer]];
			if (delta>delta_tem){
				pos=pointer;
				delta=delta_tem;
			}
			pointer=s->sol[row][pointer];
			if (pointer==0)break;
		}
		tem=s->sol[row][pos];
		s->sol[row][pos]=node[i];
		s->sol[row][node[i]]=tem;
		s->fit_tour[row]+=delta;
	}
	s->fitness=0;
	for (int i=0;i<=I_data->v_num-1;i++){
		if (s->fitness<s->fit_tour[i])
			s->fitness=s->fit_tour[i];
	}
	// check the solution
	double check_fit=0;
	double fit_route;

	for (int i=0;i<=I_data->v_num-1;i++){
		pointer=0;
		fit_route=0;
		while(1){
			fit_route+=I_data->Distance[pointer][s->sol[i][pointer]];
			pointer=s->sol[i][pointer];
			if (pointer==0)break;
		}
		if (fit_route+1.0e-07> s->fit_tour[i] && fit_route-1.0e-07<s->fit_tour[i])
//			cout<<"  rignht "<<endl;
		if (check_fit<fit_route)
			check_fit=fit_route;
	}
	if (check_fit+1.0e-07> s->fitness && check_fit-1.0e-07<s->fitness)
		cout<<"the solution is right"<<endl;
	else
		cout<<"the initial solution is wrong"<<endl;

	int count=0;
	for (int i=0;i<=I_data->v_num-1;i++){
		pointer=0;
		while(1){
			pointer=s->sol[i][pointer];
			if (pointer>0)count++;
			else break;
		}
	}
	if (!(count==I_data->num_v)){
		cout<<"initial solution is wrong"<<endl;
		exit(0);
	}
}
void initial_sol::rand_fun(){
	for (int i=0;i<=I_data->v_num-1;i++){
		for (int j=0;j<=I_data->num_v;j++)
			s->sol[i][j]=-1;
		//s->sol[i][0]=0;
		s->fit_tour[i]=0;
	}
	vector <  int > node;
	for (int i=1;i<=I_data->num_v;i++)
		node.push_back(i);
	random_shuffle(node.begin(), node.end());
	int point[I_data->v_num];
	for (int i=0;i<=I_data->v_num-1;i++){
		s->sol[i][0]=node[i];
		point[i]=node[i];
		//s->sol[i][node[i]]=0;
	}
	int row;
	int size_node=node.size();
	for (int i=I_data->v_num;i<=size_node-1;i++){
		row=rand()%I_data->v_num;
		s->sol[row][point[row]]=node[i];
		point[row]=node[i];
	}
	int pointer;
	for (int i=0;i<=I_data->v_num-1;i++){
		s->sol[i][point[i]]=0;
		pointer=0;
		while(1){
			s->fit_tour[i]+=I_data->Distance[pointer][s->sol[i][pointer]];
			pointer=s->sol[i][pointer];
			if (pointer==0)break;
		}
	}
	s->fitness=0;
	for (int i=0;i<=I_data->v_num-1;i++){
		if (s->fitness<s->fit_tour[i])
			s->fitness=s->fit_tour[i];
	}
	// check the solution
	double check_fit=0;
	double fit_route;

	for (int i=0;i<=I_data->v_num-1;i++){
		pointer=0;
		fit_route=0;
		while(1){
			fit_route+=I_data->Distance[pointer][s->sol[i][pointer]];
			pointer=s->sol[i][pointer];
			if (pointer==0)break;
		}
		if (fit_route+1.0e-07> s->fit_tour[i] && fit_route-1.0e-07<s->fit_tour[i])
//			cout<<"  rignht "<<endl;
		if (check_fit<fit_route)
			check_fit=fit_route;
	}
	if (check_fit+1.0e-07> s->fitness && check_fit-1.0e-07<s->fitness)
		cout<<"the solution is right"<<endl;
	else
		cout<<"the initial solution is wrong"<<endl;

	int count=0;
	for (int i=0;i<=I_data->v_num-1;i++){
		pointer=0;
		while(1){
			pointer=s->sol[i][pointer];
			if (pointer>0)count++;
			else break;
		}
	}
	if (!(count==I_data->num_v)){
		cout<<"initial solution is wrong"<<endl;
		exit(0);
	}
}
void initial_sol::initilization(){
	if (I_data->num_v==199 || I_data->num_v==317 || I_data->num_v==531)
		rand_fun();
	else
		greedy_fun();
}

The file initialsol.h contains:
/*
 * initialsol.h
 *
 *  Created on: 17 Apr 2020
 *      Author: Peng
 */

#ifndef INITIALSOL_H_
#define INITIALSOL_H_
#include "read_data.h"
#include "Individual.h"
class initial_sol {
public:
	initial_sol();
	virtual ~initial_sol();
	void greedy_fun();
	Individual * s;
	read_data * I_data;
	void initilization();
	void rand_fun();


};

#endif /* INITIALSOL_H_ */

The file kopt.cpp contains:
/*
 * kopt.cpp
 *   created on: April 24, 2013
 * last updated: June 13, 2013
 *       author: liushujia
 */



#ifndef __KOPT__
#include "kopt.h"
#endif

TKopt::TKopt( int N ){
	total_fN = N;
	fLink = new int* [ total_fN ];
	for( int i = 0; i < total_fN; ++i ) fLink[ i ] = new int [ 2 ];

	fOrdCity = new int [ total_fN ];
	fOrdSeg = new int [ total_fN ];
	fSegCity = new int [ total_fN ];
	fOrient = new int [ total_fN ];
	fLinkSeg = new int* [ total_fN ];
	for( int i = 0; i < total_fN; ++i ) fLinkSeg[ i ] = new int [ 2 ];

	fSizeSeg = new int [ total_fN ];
	fCitySeg = new int* [ total_fN ];
	for( int i = 0; i < total_fN; ++i ) fCitySeg[ i ] = new int [ 2 ];

	fT = new int [ 5 ];
	fActiveV = new int [ total_fN ];
	fInvNearList = new int* [ total_fN ];
	for( int i = 0; i < total_fN; ++i ) fInvNearList[ i ] = new int [ 500 ];

	fNumOfINL = new int [ total_fN ];
	fArray = new int [ total_fN+2 ];
	fCheckN = new int [ total_fN ];
	fB = new int [ total_fN ];
	fGene = new int [ total_fN ];
}

TKopt::~TKopt(){
	for( int i = 0; i < total_fN; ++i ) delete [] fLink[ i ];
	delete [] fLink;

	for( int i = 0; i < total_fN; ++i ) delete [] fLinkSeg[ i ];
	delete [] fLinkSeg;

	for( int i = 0; i < total_fN; ++i ) delete [] fCitySeg[ i ];
	delete [] fCitySeg;

	for( int i = 0; i < total_fN; ++i ) delete [] fInvNearList[ i ];
	delete [] fInvNearList;

	delete [] fOrdCity;
	delete [] fOrdSeg;
	delete [] fSegCity;
	delete [] fOrient;
	delete [] fSizeSeg;
	delete [] fT;
	delete [] fActiveV;
	delete [] fNumOfINL;
	delete [] fArray;
	delete [] fCheckN;
	delete [] fB;
	delete [] fGene;
//	delete eval;
}
void TKopt::input_data(int N)
{
	fN=N;
}
void TKopt::setInvNearList(){
	for( int i = 0; i < fN; ++i ) fNumOfINL[ i ] = 0;
	int c;
	for( int i = 0; i < fN; ++i ){
		for( int k = 0; k < 50; ++k ){
			c = eval->fNearCity[i][k];
			if( fNumOfINL[c] < 500 ) fInvNearList[ c ][ fNumOfINL[c]++ ] = i;
			else{
				//printf( "Check fNumOfINL[c] < 500 ) in kopt.cpp \n" );
				//fflush( stdout );
			}
		}
	}
}

void TKopt::transIndiToTree( TIndi& indi ){
	int num, size, orient;
	fArray[1] = 0;
	for( int i = 2; i <= fN; ++i ) fArray[i] = indi.fLink[ fArray[i-1] ][ 1 ];

	fArray[0] = fArray[fN];
	fArray[fN+1] = fArray[1];
	num = 1;
	fNumOfSeg = 0;
	while(1){
		orient = 1;
		size = 0;
		fOrient[ fNumOfSeg ] = orient;
		fOrdSeg[ fNumOfSeg ] = fNumOfSeg;

		fLink[ fArray[ num ] ][ 0 ] = -1;
		fLink[ fArray[ num ] ][ 1 ] = fArray[ num+1 ];
		fOrdCity[ fArray[ num ] ] = size;
		fSegCity[ fArray[ num ] ] = fNumOfSeg;
		fCitySeg[ fNumOfSeg ][ this->turn(orient) ] = fArray[ num ];
		++num;
		++size;
		for( int i = 0; i < (int)sqrt( fN*1.0 )-1; ++i ){
			if( num == fN ) break;
			fLink[ fArray[ num ] ][ 0 ] = fArray[ num-1 ];
			fLink[ fArray[ num ] ][ 1 ] = fArray[ num+1 ];
			fOrdCity[ fArray[ num ] ] = size;
			fSegCity[ fArray[ num ] ] = fNumOfSeg;
			++num;
			++size;
		}
		if( num == fN-1 ){
			fLink[ fArray[ num ] ][ 0 ] = fArray[ num-1 ];
			fLink[ fArray[ num ] ][ 1 ] = fArray[ num+1 ];
			fOrdCity[ fArray[ num ] ] = size;
			fSegCity[ fArray[ num ] ] = fNumOfSeg;
			++num;
			++size;
		}
		fLink[ fArray[ num ] ][ 0 ] = fArray[ num-1 ];
		fLink[ fArray[ num ] ][ 1 ] = -1;
		fOrdCity[ fArray[ num ] ] = size;
		fSegCity[ fArray[ num ] ] = fNumOfSeg;
		fCitySeg[ fNumOfSeg ][ orient ] = fArray[ num ];
		++num;
		++size;
		fSizeSeg[ fNumOfSeg ] = size;
		++fNumOfSeg;
		if( num == fN+1 ) break;
	}
	for( int s = 1; s < fNumOfSeg-1; ++s ){
		fLinkSeg[ s ][ 0 ] = s-1;
		fLinkSeg[ s ][ 1 ] = s+1;
	}
	fLinkSeg[ 0 ][ 0 ] = fNumOfSeg-1;
	fLinkSeg[ 0 ][ 1 ] = 1;
	fLinkSeg[ fNumOfSeg-1 ][ 0 ] = fNumOfSeg-2;
	fLinkSeg[ fNumOfSeg-1 ][ 1 ] = 0;
	fTourLength = indi.fEvaluationValue;
	fFixNumOfSeg = fNumOfSeg;
}

void TKopt::transTreeToIndi( TIndi& indi ){
	int t_p, t_n;
	for( int t = 0; t < fN; ++t ){
		t_p = this->getPrev( t );
		t_n = this->getNext( t );
		indi.fLink[ t ][ 0 ] = t_p;
		indi.fLink[ t ][ 1 ] = t_n;
	}
	eval->doIt( indi );
}

void TKopt::doIt( TIndi& tIndi ){
	this->transIndiToTree( tIndi );
	this->sub();
	this->transTreeToIndi( tIndi );
}

void TKopt::sub(){
	int t1_st;
	double dis1, dis2;
	//int dis1, dis2;
	for( int t = 0; t < fN; ++t ) fActiveV[ t ] = 1;
BEGIN:
	t1_st = rand()%fN;// select a node randomly
	fT[1] = t1_st;
	//t1's loop
	while(1){
		fT[1] = this->getNext( fT[1] );
		if( fActiveV[ fT[1] ] == 0 ) goto RETURN;
		fFlagRev = 0;
		fT[2] = this->getPrev( fT[1] );
		for( int num1 = 1; num1 < 50; ++num1 ){
			fT[4] = eval->fNearCity[ fT[1] ][ num1 ];
			fT[3] = this->getPrev( fT[4] );
			dis1 = eval->fEdgeDis[fT[1]][fT[2]] - eval->fEdgeDis[fT[1]][fT[4]];
			if( dis1 > 1.0e-7 ){
				dis2 = dis1 + eval->fEdgeDis[fT[3]][fT[4]] - eval->fEdgeDis[fT[3]][fT[2]];
				if( dis2 > 1.0e-7 ){
					this->incrementImp( fFlagRev );// implement swap
					for( int a = 1; a <= 4; ++a )
						for( int k = 0; k < fNumOfINL[fT[a]]; ++k )
							fActiveV[ this->fInvNearList[fT[a]][k] ] = 1;
					goto BEGIN;
				}
			}
			else break;
		}
		fFlagRev = 1;
		fT[2] = this->getNext( fT[1] );
		for( int num1 = 1; num1 < 50; ++num1 ){
			fT[4] = eval->fNearCity[ fT[1] ][ num1 ];
			fT[3] = this->getNext( fT[4] );
			dis1 = eval->fEdgeDis[fT[1]][fT[2]] - eval->fEdgeDis[fT[1]][fT[4]];
			if( dis1 > 1.0e-7 ){
				dis2 = dis1 + eval->fEdgeDis[fT[3]][fT[4]] - eval->fEdgeDis[fT[3]][fT[2]];
				if( dis2 > 1.0e-7 ){
					this->incrementImp( fFlagRev );
					for( int a = 1; a <= 4; ++a )
						for( int k = 0; k < fNumOfINL[fT[a]]; ++k )
							fActiveV[ this->fInvNearList[fT[a]][k] ] = 1;
					goto BEGIN;
				}
			}
			else break;
		}
		fActiveV[ fT[1] ] = 0;
RETURN:
		if( fT[1] == t1_st ) break;
	}
}

int TKopt::getNext( int t ){
	int t_n, seg, orient;
	seg = fSegCity[ t ];
	orient = fOrient[ seg ];
	t_n = fLink[ t ][ orient ];
	if( t_n == -1 ){
		seg = fLinkSeg[ seg ][ orient ];
		orient = turn( fOrient[ seg ] );
		t_n = fCitySeg[ seg ][ orient ];
	}
	return t_n;
}

int TKopt::getPrev( int t ){
	int t_p, seg, orient;
	seg = fSegCity[ t ];
	orient = fOrient[ seg ];
	t_p = fLink[ t ][ this->turn( orient ) ];
	if( t_p == -1 ){
		seg = fLinkSeg[ seg ][ turn(orient) ];
		orient = fOrient[ seg ];
		t_p = fCitySeg[ seg ][ orient ];
	}
	return t_p;
}

void TKopt::swap(int &x, int &y){
	int s=x;
	x=y;
	y=s;
}

int TKopt::turn( int &orient ){
	return 1-orient;
}

void TKopt::incrementImp( int flagRev ){
	int t1_s, t1_e, t2_s, t2_e;
	int seg_t1_s, seg_t1_e, seg_t2_s, seg_t2_e;
	int ordSeg_t1_s, ordSeg_t1_e, ordSeg_t2_s, ordSeg_t2_e;
	int orient_t1_s, orient_t1_e, orient_t2_s, orient_t2_e;
	int numOfSeg1, numOfSeg2;
	int curr;
	int ord;

	int flag_t2e_t1s;
	int flag_t2s_t1e;
	int length_t1s_seg;
	int length_t1e_seg;
	int seg;

	if( fFlagRev == 0 ){
		t1_s = fT[1];
		t1_e = fT[3];
		t2_s = fT[4];
		t2_e = fT[2];
	}
	else if( fFlagRev == 1 ){
		t1_s = fT[2];
		t1_e = fT[4];
		t2_s = fT[3];
		t2_e = fT[1];
	}

	seg_t1_s = fSegCity[ t1_s ];
	ordSeg_t1_s = fOrdSeg[ seg_t1_s ];
	orient_t1_s = fOrient[ seg_t1_s ];
	seg_t1_e = fSegCity[ t1_e ];
	ordSeg_t1_e = fOrdSeg[ seg_t1_e ];
	orient_t1_e = fOrient[ seg_t1_e ];
	seg_t2_s = fSegCity[ t2_s ];
	ordSeg_t2_s = fOrdSeg[ seg_t2_s ];
	orient_t2_s = fOrient[ seg_t2_s ];
	seg_t2_e = fSegCity[ t2_e ];
	ordSeg_t2_e = fOrdSeg[ seg_t2_e ];
	orient_t2_e = fOrient[ seg_t2_e ];

	//////////////////// Type1 ////////////////////////
	if( ( seg_t1_s == seg_t1_e ) && ( seg_t1_s == seg_t2_s ) && ( seg_t1_s == seg_t2_e ) ){
		if( (fOrient[seg_t1_s] == 1 && (fOrdCity[ t1_s ] > fOrdCity[ t1_e ])) ||
			(fOrient[seg_t1_s] == 0 && (fOrdCity[ t1_s ] < fOrdCity[ t1_e ]))){
			this->swap( t1_s, t2_s );
			this->swap( t1_e, t2_e );
			this->swap( seg_t1_s, seg_t2_s );
			this->swap( seg_t1_e, seg_t2_e );
			this->swap( ordSeg_t1_s, ordSeg_t2_s );
			this->swap( ordSeg_t1_e, ordSeg_t2_e );
			this->swap( orient_t1_s, orient_t2_s );
			this->swap( orient_t1_e, orient_t2_e );
		}
		curr = t1_s;
		ord = fOrdCity[ t1_e ];
		while(1){
			this->swap( fLink[curr][0], fLink[curr][1] );
			fOrdCity[ curr ] = ord;
			if( curr == t1_e ) break;
			curr = fLink[curr][turn(orient_t1_s)];
			if( orient_t1_s == 0 ) ++ord;
			else --ord;
		}

		fLink[t2_e][orient_t1_s] = t1_e;
		fLink[t2_s][turn(orient_t1_s)] = t1_s;
		fLink[t1_s][orient_t1_s] = t2_s;
		fLink[t1_e][turn(orient_t1_s)] = t2_e;

		return;
	}
	//////////////////// Type1 ///////////////////////


	if( ordSeg_t1_e >= ordSeg_t1_s )	numOfSeg1 = ordSeg_t1_e - ordSeg_t1_s + 1;
	else								numOfSeg1 = ordSeg_t1_e - ordSeg_t1_s + 1 + fNumOfSeg;
	if( ordSeg_t2_e >= ordSeg_t2_s )	numOfSeg2 = ordSeg_t2_e - ordSeg_t2_s + 1;
	else								numOfSeg2 = ordSeg_t2_e - ordSeg_t2_s + 1 + fNumOfSeg;

	if( numOfSeg1 > numOfSeg2 ){
		this->swap( numOfSeg1, numOfSeg2 );
		this->swap( t1_s, t2_s );
		this->swap( t1_e, t2_e );
		this->swap( seg_t1_s, seg_t2_s );
		this->swap( seg_t1_e, seg_t2_e );
		this->swap( ordSeg_t1_s, ordSeg_t2_s );
		this->swap( ordSeg_t1_e, ordSeg_t2_e );
		this->swap( orient_t1_s, orient_t2_s );
		this->swap( orient_t1_e, orient_t2_e );
	}
	if( fLink[ t2_e ][ orient_t2_e ] == -1 ) flag_t2e_t1s = 1;
	else flag_t2e_t1s = 0;

	if( fLink[ t2_s ][ this->turn(orient_t2_s) ] == -1 ) flag_t2s_t1e = 1;
	else flag_t2s_t1e = 0;

	length_t1s_seg = abs( fOrdCity[ t2_e ] - fOrdCity[ fCitySeg[ seg_t2_e ][ orient_t2_e ] ] );
	length_t1e_seg = abs( fOrdCity[ t2_s ] - fOrdCity[ fCitySeg[ seg_t2_s ][ this->turn(orient_t2_s) ] ] );

	///////////////////// Type2 /////////////////
	if( seg_t1_s == seg_t1_e ){
		if( flag_t2e_t1s == 1 && flag_t2s_t1e == 1 ){
			orient_t1_s = turn( fOrient[ seg_t1_s ] );
			fOrient[ seg_t1_s ] = orient_t1_s;
			fCitySeg[ seg_t1_s ][ orient_t1_s ] = t1_s;
			fCitySeg[ seg_t1_s ][ turn(orient_t1_s) ] = t1_e;
			fLinkSeg[ seg_t1_s ][ orient_t1_s ] = seg_t2_s;
			fLinkSeg[ seg_t1_s ][ turn(orient_t1_s) ] = seg_t2_e;
			return;
		}
		if( flag_t2e_t1s == 0 && flag_t2s_t1e == 1 ){
			curr = t1_e;
			ord = fOrdCity[ t1_s ];
			while(1){
				this->swap( fLink[curr][0], fLink[curr][1] );
				fOrdCity[ curr ] = ord;
				if( curr == t1_s ) break;

				curr = fLink[curr][orient_t2_e];
				if( orient_t2_e == 0 ) --ord;
				else ++ord;
			}
			fLink[t2_e][orient_t2_e] = t1_e;
			fLink[t1_s][orient_t2_e] = -1;
			fLink[t1_e][turn(orient_t2_e)] = t2_e;
			fCitySeg[seg_t2_e][orient_t2_e] = t1_s;
			return;
		}
		if( flag_t2e_t1s == 1 && flag_t2s_t1e == 0 ){
			curr = t1_s;
			ord = fOrdCity[ t1_e ];
			while(1){
				this->swap( fLink[curr][0], fLink[curr][1] );
				fOrdCity[ curr ] = ord;
				if( curr == t1_e ) break;

				curr = fLink[curr][turn(orient_t2_s)];
				if( orient_t2_s == 0 ) ++ord;
				else --ord;
			}
			fLink[t2_s][turn(orient_t2_s)] = t1_s;
			fLink[t1_e][turn(orient_t2_s)] = -1;
			fLink[t1_s][orient_t2_s] = t2_s;
			fCitySeg[seg_t2_s][turn(orient_t2_s)] = t1_e;
			return;
		}
	}

	///////////////////// Type3 /////////////////

	if( flag_t2e_t1s == 1 ) fLinkSeg[seg_t1_s][turn(orient_t1_s)] = seg_t2_s;
	else{
		seg_t1_s = fNumOfSeg++;
		orient_t1_s = orient_t2_e;
		fLink[ t1_s ][turn(orient_t1_s)] = -1;
		fLink[ fCitySeg[seg_t2_e][orient_t2_e]][orient_t1_s] = -1;
		fOrient[seg_t1_s] = orient_t1_s;
		fSizeSeg[seg_t1_s] = length_t1s_seg;
		fCitySeg[seg_t1_s][turn(orient_t1_s)] = t1_s;
		fCitySeg[seg_t1_s][orient_t1_s] = fCitySeg[seg_t2_e][orient_t2_e];
		fLinkSeg[seg_t1_s][turn(orient_t1_s)] = seg_t2_s;
		fLinkSeg[seg_t1_s][orient_t1_s] = fLinkSeg[seg_t2_e][orient_t2_e];
		seg = fLinkSeg[seg_t2_e][orient_t2_e];
		fLinkSeg[seg][turn(fOrient[seg])] = seg_t1_s;
	}

	if( flag_t2s_t1e == 1 ) fLinkSeg[seg_t1_e][orient_t1_e] = seg_t2_e;
	else{
		seg_t1_e = fNumOfSeg++;
		orient_t1_e = orient_t2_s;
		fLink[ t1_e ][orient_t1_e] = -1;
		fLink[ fCitySeg[seg_t2_s][turn(orient_t2_s)] ][turn(orient_t1_e)] = -1;
		fOrient[seg_t1_e] = orient_t1_e;
		fSizeSeg[seg_t1_e] = length_t1e_seg;
		fCitySeg[seg_t1_e][orient_t1_e] = t1_e;
		fCitySeg[seg_t1_e][turn(orient_t1_e)] = fCitySeg[seg_t2_s][turn(orient_t2_s)];
		fLinkSeg[seg_t1_e][orient_t1_e] = seg_t2_e;
		fLinkSeg[seg_t1_e][turn(orient_t1_e)] = fLinkSeg[seg_t2_s][turn(orient_t2_s)];
		seg = fLinkSeg[seg_t2_s][turn(orient_t2_s)];
		fLinkSeg[seg][fOrient[seg]] = seg_t1_e;
	}

	fLink[t2_e][orient_t2_e] = -1;
	fSizeSeg[seg_t2_e] -= length_t1s_seg;
	fCitySeg[seg_t2_e][orient_t2_e] = t2_e;
	fLinkSeg[seg_t2_e][orient_t2_e] = seg_t1_e;
	fLink[t2_s][turn(orient_t2_s)] = -1;
	fSizeSeg[seg_t2_s] -= length_t1e_seg;
	fCitySeg[seg_t2_s][turn(orient_t2_s)] = t2_s;
	fLinkSeg[seg_t2_s][turn(orient_t2_s)] = seg_t1_s;

	seg = seg_t1_e;
	while(1){
		fOrient[seg] = turn(fOrient[seg]);
		if( seg == seg_t1_s ) break;
		seg = fLinkSeg[seg][fOrient[seg]];
	}

	if( fSizeSeg[seg_t2_e] < length_t1s_seg ){
		seg = fLinkSeg[seg_t2_e][turn(fOrient[seg_t2_e])];
		fLinkSeg[seg][fOrient[seg]] = seg_t1_s;
		seg = fLinkSeg[seg_t2_e][fOrient[seg_t2_e]];
		fLinkSeg[seg][turn(fOrient[seg])] = seg_t1_s;
		seg = fLinkSeg[seg_t1_s][turn(fOrient[seg_t1_s])];
		fLinkSeg[seg][fOrient[seg]] = seg_t2_e;
		seg = fLinkSeg[seg_t1_s][fOrient[seg_t1_s]];
		fLinkSeg[seg][turn(fOrient[seg])] = seg_t2_e;

		this->swap( fOrient[seg_t2_e], fOrient[seg_t1_s] );
		this->swap( fSizeSeg[seg_t2_e], fSizeSeg[seg_t1_s] );
		this->swap( fCitySeg[seg_t2_e][0], fCitySeg[seg_t1_s][0] );
		this->swap( fCitySeg[seg_t2_e][1], fCitySeg[seg_t1_s][1] );
		this->swap( fLinkSeg[seg_t2_e][0], fLinkSeg[seg_t1_s][0] );
		this->swap( fLinkSeg[seg_t2_e][1], fLinkSeg[seg_t1_s][1] );
		this->swap( seg_t2_e, seg_t1_s );
	}

	if( fSizeSeg[seg_t2_s] < length_t1e_seg ){
		seg = fLinkSeg[seg_t2_s][turn(fOrient[seg_t2_s])];
		fLinkSeg[seg][fOrient[seg]] = seg_t1_e;
		seg = fLinkSeg[seg_t2_s][fOrient[seg_t2_s]];
		fLinkSeg[seg][turn(fOrient[seg])] = seg_t1_e;
		seg = fLinkSeg[seg_t1_e][turn(fOrient[seg_t1_e])];
		fLinkSeg[seg][fOrient[seg]] = seg_t2_s;
		seg = fLinkSeg[seg_t1_e][fOrient[seg_t1_e]];
		fLinkSeg[seg][turn(fOrient[seg])] = seg_t2_s;

		this->swap( fOrient[seg_t2_s], fOrient[seg_t1_e] );
		this->swap( fSizeSeg[seg_t2_s], fSizeSeg[seg_t1_e] );
		this->swap( fCitySeg[seg_t2_s][0], fCitySeg[seg_t1_e][0] );
		this->swap( fCitySeg[seg_t2_s][1], fCitySeg[seg_t1_e][1] );
		this->swap( fLinkSeg[seg_t2_s][0], fLinkSeg[seg_t1_e][0] );
		this->swap( fLinkSeg[seg_t2_s][1], fLinkSeg[seg_t1_e][1] );
		this->swap( seg_t2_s, seg_t1_e );
	}

	while( fNumOfSeg > fFixNumOfSeg ){
	if( fSizeSeg[ fLinkSeg[fNumOfSeg-1][0] ] <
		fSizeSeg[ fLinkSeg[fNumOfSeg-1][1] ] )
		this->combineSeg( fLinkSeg[fNumOfSeg-1][0], fNumOfSeg-1 );
	else
		this->combineSeg( fLinkSeg[fNumOfSeg-1][1], fNumOfSeg-1 );
	}
	int ordSeg = 0;
	seg = 0;
	while(1){
		fOrdSeg[seg] = ordSeg;
		++ordSeg;
		seg = fLinkSeg[seg][ fOrient[seg] ];
		if( seg == 0 ) break;
	}
  return;
}

void TKopt::combineSeg( int segL, int segS ){
	int seg;
	int t_s, t_e, direction; t_s = 0; t_e = 0; direction = 0;
	int ord; ord = 0;
	int increment; increment = 0;
	int curr, next;

	if( fLinkSeg[segL][fOrient[segL]] == segS ){
		fLink[fCitySeg[segL][fOrient[segL]]][fOrient[segL]] = fCitySeg[segS][turn(fOrient[segS])];
		fLink[fCitySeg[segS][turn(fOrient[segS])]][turn(fOrient[segS])] = fCitySeg[segL][fOrient[segL]];
		ord = fOrdCity[fCitySeg[segL][fOrient[segL]]];

		fCitySeg[segL][fOrient[segL]] = fCitySeg[segS][fOrient[segS]];
		fLinkSeg[segL][fOrient[segL]] = fLinkSeg[segS][fOrient[segS]];
		seg = fLinkSeg[segS][fOrient[segS]];
		fLinkSeg[seg][turn(fOrient[seg])] = segL;

		t_s = fCitySeg[segS][turn(fOrient[segS])];
		t_e = fCitySeg[segS][fOrient[segS]];
		direction = fOrient[segS];

		if( fOrient[segL] == 1 ) increment = 1;
		else increment = -1;
	}
	else if( fLinkSeg[segL][turn(fOrient[segL])] == segS ){
		fLink[fCitySeg[segL][turn(fOrient[segL])]][turn(fOrient[segL])] = fCitySeg[segS][fOrient[segS]];
		fLink[fCitySeg[segS][fOrient[segS]]][fOrient[segS]] = fCitySeg[segL][turn(fOrient[segL])];
		ord = fOrdCity[fCitySeg[segL][turn(fOrient[segL])]];

		fCitySeg[segL][turn(fOrient[segL])] = fCitySeg[segS][turn(fOrient[segS])];
		fLinkSeg[segL][turn(fOrient[segL])] = fLinkSeg[segS][turn(fOrient[segS])];
		seg = fLinkSeg[segS][turn(fOrient[segS])];
		fLinkSeg[seg][fOrient[seg]] = segL;

		t_s = fCitySeg[segS][fOrient[segS]];
		t_e = fCitySeg[segS][turn(fOrient[segS])];
		direction = turn(fOrient[segS]);

		if( fOrient[segL] == 1 ) increment = -1;
		else increment = 1;
	}
	curr = t_s;
	ord = ord + increment;
	while(1){
		fSegCity[curr] = segL;
		fOrdCity[curr] = ord;

		next = fLink[curr][direction];
		if( fOrient[segL] != fOrient[segS] ) this->swap( fLink[curr][0], fLink[curr][1] );

		if( curr == t_e ) break;
		curr = next;
		ord += increment;
	}
	fSizeSeg[segL] += fSizeSeg[segS];
	--fNumOfSeg;
}

void TKopt::checkDetail(){
	int seg, seg_p, seg_n;
	int ord, ord_p, ord_n;
	int orient;
	int curr;

	seg = 0;
	for( int s = 0; s < fNumOfSeg; ++s ){
		seg = s;
		orient = fOrient[ seg ];
		seg_p = fLinkSeg[ seg ][ this->turn(orient) ];
		seg_n = fLinkSeg[ seg ][ orient ];

		ord = fOrdSeg[ seg ];
		ord_p = ord - 1 ;
		if( ord_p < 0 ) ord_p = fNumOfSeg - 1;

		ord_n = ord + 1;
		if( ord_n >= fNumOfSeg ) ord_n = 0;

		curr = fCitySeg[ s ][ 0 ];
		int count = 0;

		while(1){
			++count;
			if( curr == fCitySeg[ s ][1] ) break;
			curr = fLink[curr][1];
		}
	}
	int t, t_n, t_p, t_s, t_e;
	for( t = 0; t < fN; ++t ){
		seg = fSegCity[ t ];
		orient = fOrient[ seg ];
		t_s = fCitySeg[ seg ][ 0 ];
		t_e = fCitySeg[ seg ][ 1 ];

		t_p = fLink[ t ][ 0 ];
		t_n = fLink[ t ][ 1 ];
	}
}

void TKopt::checkValid(){
	int t_st, t_c, t_n, count, seg, orient, Invalid = 0;
	for( int i = 0; i < fN; ++i ) fCheckN[ i ] = 0;

	t_st = rand() % fN;
	t_n = t_st;
	count = 0;
	while(1){
		t_c = t_n;
		fCheckN[ t_c ] = 1;
		++count;

		seg = fSegCity[ t_c ];
		orient = fOrient[ seg ];
		t_n = this->getNext( t_c );

		if( t_n == t_st ) break;

		if( count == fN+1 ){
			Invalid = 1;
			break;
		}
	}
	for( int i = 0; i < fN; ++i )
		if( fCheckN[ i ] == 0 ) Invalid = 1;

	if( Invalid == 1 ) printf( "Invalid \n" ); fflush( stdout );

}

void TKopt::makeRandSol( TIndi& indi ){
	for( int j = 0; j < fN; ++j ) fB[j] = j;
	int r;
	for( int i = 0; i < fN; ++i ){
		r = rand() % (fN-i);
		fGene[i] = fB[r];
		fB[r] = fB[fN-i-1];
	}

	for( int j2 = 1 ; j2 < fN-1; ++j2 ){
		indi.fLink[fGene[j2]][0] = fGene[j2-1];
		indi.fLink[fGene[j2]][1] = fGene[j2+1];
	}
	indi.fLink[fGene[0]][0] = fGene[fN-1];
	indi.fLink[fGene[0]][1] = fGene[1];
	indi.fLink[fGene[fN-1]][0] = fGene[fN-2];
	indi.fLink[fGene[fN-1]][1] = fGene[0];

	eval->doIt( indi );
}


The file kopt.h contains:
/*
 * kopt.h
 *   created on: April 24, 2013
 * last updated: June 13, 2013
 *       author: liushujia
 */

#ifndef __KOPT__
#define __KOPT__

#ifndef __RAND__
#include "randomize.h"
#endif

#ifndef __Sort__
#include "sort.h"
#endif

#ifndef __INDI__
#include "indi.h"
#endif

#ifndef __EVALUATOR__
#include "evaluator.h"
#endif

#include <stdio.h>
#include <stdlib.h>
#include <assert.h>

class TKopt{
public:
	TKopt( int N );
	~TKopt();
	void input_data(int N);
	void setInvNearList();
	void transIndiToTree( TIndi& indi );
	void transTreeToIndi( TIndi& indi );
	void doIt( TIndi& tIndi );			// å±€éƒ¨æ�œç´¢(2-opt neighborhood)

	int getNext( int t );
	int getPrev( int t );
	int turn( int &orient );

	void sub();
	void incrementImp( int flagRev );
	void combineSeg( int segL, int segS );

	void checkDetail();
	void checkValid();
	void swap(int &x, int &y);
	void makeRandSol( TIndi& indi );		// è®¾ç½®éš�æœºè·¯ç¨‹

	TEvaluator* eval;

private:
	int fN;
	int total_fN;
	int fFixNumOfSeg;
	int fNumOfSeg;
	int fFlagRev;
	double fTourLength;
	//int fTourLength;

	int **fLink;
	int **fLinkSeg;
	int **fCitySeg;
	int **fInvNearList;

	int *fT;
	int *fB;
	int *fSegCity;
	int *fOrdCity;
	int *fOrdSeg;
	int *fOrient;
	int *fSizeSeg;
	int *fActiveV;
	int *fNumOfINL;
	int *fArray;
	int *fCheckN;
	int *fGene;
};

#endif

The file LS.cpp contains:
/*
 * LS.cpp
 *
 *  Created on: 18 Apr 2020
 *      Author: Peng
 */

#include "LS.h"
#include "basic.h"
#include "Tstwoopt.h"
#include "EAX.h"
#include "environment.h"
#include "Individual.h"
LS::LS(read_data * data) {
	num_v=data->num_v;
	v_num=data->v_num;
	tem=new Individual();
	tem->define(num_v,v_num);
	each_route=new Tstwoopt (data);
	each_route->I_data=data;
	record_table=new int [v_num];
	s_t=new int [num_v+1];
	cand_str1=new int *[length_s*length_s];
	cand_str2=new int *[length_s*length_s];
	for (int i=0;i<=length_s*length_s-1;i++){
		cand_str1[i]=new int [length_s];
		cand_str2[i]=new int [length_s];
	}
	cand_fit=new double [length_s*length_s];
	near_cand1=new int *[num_near_nodes+100];
	for (int i=0;i<=num_near_nodes+100-1;i++)
		near_cand1[i]=new int [6];
	near_fit=new double [num_near_nodes+100];
	rever_list=new int [length_s*length_s];
	// tabu search variables
	tabu_table=new int *[v_num];
	tabu_table_c=new int *[v_num];
	for (int i=0;i<=v_num-1;i++){
		tabu_table[i]=new int [num_v+1];
		tabu_table_c[i]=new int [num_v+1];
	}
	t_t_swap=new int *[num_v+1];
	for (int i=0;i<=num_v;i++)
		t_t_swap[i]=new int [num_v+1];
	for (int i=0;i<=num_v;i++)
		for (int j=0;j<=num_v;j++)
			t_t_swap[i][j]=0;
	iteration=0;
}
LS::~LS() {
	delete tem;
	delete each_route;
	delete [] record_table;
	delete [] s_t;
	for (int i=0;i<=length_s*length_s-1;i++){
		delete [] cand_str1[i];
		delete [] cand_str2[i];
	}
	delete [] cand_str1;
	delete [] cand_str2;
	delete [] cand_fit;
	for (int i=0;i<=num_near_nodes+100-1;i++)
		delete [] near_cand1[i];
	delete [] near_cand1;
	delete [] near_fit;
	delete [] rever_list;
	for (int i=0;i<=v_num-1;i++){
		delete [] tabu_table[i];
		delete [] tabu_table_c[i];
	}
	delete [] tabu_table;
	delete [] tabu_table_c;
	for (int i=0;i<=num_v;i++)
		delete [] t_t_swap[i];
	delete [] t_t_swap;
}
void LS::update_best_solution(){
	if (s->fitness < b_s->fitness){
		for (int i=0;i<=v_num-1;i++){
			for (int j=0;j<=num_v;j++){
				b_s->sol[i][j]=s->sol[i][j];
				b_s->sol_r[i][j]=s->sol_r[i][j];
			}
			b_s->fit_tour[i]=s->fit_tour[i];
		}
		b_s->fitness=s->fitness;
	}
}
void LS::supply_edge(){
	int p;
	for (int i=0;i<v_num;i++){
		p=0;
		while(1){
			I_data->edge[p][b_s->sol[i][p]]=1;
			p=b_s->sol[i][p];
			if (p==0)break;
		}
	}
}
void LS::reverse_fun(){// get value for sol_r;
	int pointer;
	vector<int >tour;
	for (int i=0;i<=v_num-1;i++)	{
		pointer=s->sol[i][0];
		while (pointer!=0)		{
			tour.push_back(pointer);
			pointer=s->sol[i][pointer];
		}
		s->sol_r[i][0]=tour.back();
		tour.pop_back();
		pointer=s->sol_r[i][0];
		while (tour.size())		{
			s->sol_r[i][pointer]=tour.back();
			pointer=s->sol_r[i][pointer];
			tour.pop_back();
		}
		s->sol_r[i][pointer]=0;
	}
}
int LS::replace_fun_insert(double min_delta,int row_out,int city_out,int row_in,int city_in){
	double delta1=0;
	double delta2=0;
	delta1+=I_data->Distance[s->sol_r[row_out][city_out]][s->sol[row_out][city_out]];
	delta1=delta1-I_data->Distance[s->sol_r[row_out][city_out]][city_out]-I_data->Distance[s->sol[row_out][city_out]][city_out];
	//
	delta2+=I_data->Distance[city_in][city_out]+I_data->Distance[city_out][s->sol[row_in][city_in]];
	delta2=delta2-I_data->Distance[city_in][s->sol[row_in][city_in]];
	//
	s->fit_tour[row_out]=s->fit_tour[row_out]+delta1;
	s->fit_tour[row_in]=s->fit_tour[row_in]+delta2;
	int longest_tour=0;
	for (int i=1;i<=v_num-1;i++)
		if (s->fit_tour[i]>s->fit_tour[longest_tour])
			longest_tour=i;
	s->fitness=s->fit_tour[longest_tour];
	//
	int p_p,n_p;
	p_p=s->sol_r[row_out][city_out];
	n_p=s->sol[row_out][city_out];
	s->sol[row_out][p_p]=n_p;
	s->sol[row_out][city_out]=-1;
	s->sol_r[row_out][n_p]=p_p;
	s->sol_r[row_out][city_out]=-1;
	//
	n_p=s->sol[row_in][city_in];
	s->sol[row_in][city_in]=city_out;
	s->sol[row_in][city_out]=n_p;
	s->sol_r[row_in][n_p]=city_out;
	s->sol_r[row_in][city_out]=city_in;
	return 	longest_tour;
}
double LS::calculate_fit_insert(int row_out,int city_out,int row_in,int city_in,int longest_third){
	double delta1=0;
	double delta2=0;
	delta1+=I_data->Distance[s->sol_r[row_out][city_out]][s->sol[row_out][city_out]];
	delta1=delta1-I_data->Distance[s->sol_r[row_out][city_out]][city_out]-I_data->Distance[s->sol[row_out][city_out]][city_out];
	//
	delta2+=I_data->Distance[city_in][city_out]+I_data->Distance[city_out][s->sol[row_in][city_in]];
	delta2=delta2-I_data->Distance[city_in][s->sol[row_in][city_in]];
	//
	delta1=s->fit_tour[row_out]+delta1;
	delta2=s->fit_tour[row_in]+delta2;
	double delta=delta1;
	if (delta<delta2)
		delta=delta2;
	if (delta<s->fit_tour[longest_third])
		delta=s->fit_tour[longest_third];
	delta=delta-s->fitness;
	return delta;
}

void LS::calculate_fit(int st1,int end1,int st2,int end2,int k, int reverse){
	double fit1=0;double fit2=0;
	int pointer;double tem_fit=0;double tem_fit2=0;
	if (k==0 && reverse==1){//
		pointer=st2;
		while (pointer!=end2){
			tem_fit+=I_data->Distance[pointer][s->sol[s_t[pointer]][pointer]];
			pointer=s->sol[s_t[pointer]][pointer];
		}
		fit1+=tem_fit+I_data->Distance[st1][st2]+I_data->Distance[end2][s->sol[s_t[st1]][st1]]-I_data->Distance[st1][s->sol[s_t[st1]][st1]];
		fit2+=I_data->Distance[s->sol_r[s_t[st2]][st2]][s->sol[s_t[end2]][end2]]-I_data->Distance[s->sol_r[s_t[st2]][st2]][st2]-
				I_data->Distance[s->sol[s_t[st2]][end2]][end2];
		fit2=fit2-tem_fit;
	}
	if (k==0 && reverse==0){//
		pointer=st2;
		while (pointer!=end2){
			tem_fit+=I_data->Distance[pointer][s->sol_r[s_t[pointer]][pointer]];
			pointer=s->sol_r[s_t[pointer]][pointer];
		}
		fit1+=tem_fit+I_data->Distance[st1][st2]+I_data->Distance[end2][s->sol[s_t[st1]][st1]]-I_data->Distance[st1][s->sol[s_t[st1]][st1]];
		fit2+=I_data->Distance[s->sol[s_t[st2]][st2]][s->sol_r[s_t[end2]][end2]]-
			I_data->Distance[st2][s->sol[s_t[st2]][st2]]-I_data->Distance[end2][s->sol_r[s_t[end2]][end2]];
		fit2=fit2-tem_fit;
	}
	if (k!=0 && reverse==1){
		pointer=s->sol[s_t[end1]][st1];
		while (pointer!=end1){
			tem_fit+=I_data->Distance[pointer][s->sol[s_t[pointer]][pointer]];
			pointer=s->sol[s_t[pointer]][pointer];
		}
		pointer=st2;
		while (pointer!=end2){
			tem_fit2+=I_data->Distance[pointer][s->sol[s_t[pointer]][pointer]];
			pointer=s->sol[s_t[pointer]][pointer];
		}
		fit1+=tem_fit2+I_data->Distance[st1][st2]+I_data->Distance[end2][s->sol[s_t[end1]][end1]]-
			tem_fit-I_data->Distance[st1][s->sol[s_t[end1]][st1]]-I_data->Distance[end1][s->sol[s_t[end1]][end1]];
		fit2+=tem_fit+I_data->Distance[s->sol_r[s_t[st2]][st2]][s->sol[s_t[end1]][st1]]+I_data->Distance[s->sol[s_t[end2]][end2]][end1]-
			tem_fit2-I_data->Distance[st2][s->sol_r[s_t[st2]][st2]]-I_data->Distance[end2][s->sol[s_t[end2]][end2]];
	}
	if (k!=0 && reverse==0){
		pointer=s->sol[s_t[end1]][st1];
		while (pointer!=end1){
			tem_fit+=I_data->Distance[pointer][s->sol[s_t[pointer]][pointer]];
			pointer=s->sol[s_t[pointer]][pointer];
		}
		pointer=st2;
		while (pointer!=end2){
			tem_fit2+=I_data->Distance[pointer][s->sol_r[s_t[pointer]][pointer]];
			pointer=s->sol_r[s_t[pointer]][pointer];
		}
		fit1+=tem_fit2+I_data->Distance[st1][st2]+I_data->Distance[end2][s->sol[s_t[end1]][end1]]-
			tem_fit-I_data->Distance[st1][s->sol[s_t[st1]][st1]]-I_data->Distance[end1][s->sol[s_t[end1]][end1]];
		fit2+=tem_fit+I_data->Distance[s->sol[s_t[st2]][st2]][s->sol[s_t[st1]][st1]]+I_data->Distance[s->sol_r[s_t[end2]][end2]][end1]
			-tem_fit2-I_data->Distance[st2][s->sol[s_t[st2]][st2]]-I_data->Distance[end2][s->sol_r[s_t[end2]][end2]];
	}
	s->fit_tour[s_t[end1]]=fit1+s->fit_tour[s_t[end1]];
	s->fit_tour[s_t[st2]]=fit2+s->fit_tour[s_t[st2]];
	s->fitness=0;
	for(int i=0;i<=v_num-1;i++)
		if (s->fit_tour[i]>s->fitness){
			s->fitness=s->fit_tour[i];
			ot=i;
		}
}
void LS::replace_fun(int *move){
	int string1[length_s];
	int string2[length_s];
	for (int i=0;i<=length_s-1;i++){
		string1[i]=-1;
		string2[i]=-1;
	}
	int count1=0;int row1=s_t[move[1]];int row2=s_t[move[2]];
	while(1){
		if (move[0]!=move[1]){
			string1[count1]=move[0];
			count1++;
			move[0]=s->sol[row1][move[0]];
		}
		else{
			string1[count1]=move[1];count1++;
			break;
		}
	}
	int count2=0;
	while (1){
		if (move[2]!=move[3]){
			string2[count2]=move[2];
			count2++;
			if (move[4]==1)
				move[2]=s->sol[row2][move[2]];
			else
				move[2]=s->sol_r[row2][move[2]];
		}
		else{
			string2[count2]=move[3];count2++;
			break;
		}
	}
	// calculating move gains
	double fit1=0;
	double fit2=0;
	for (int i=2;i<=count1-1;i++){
		fit1+=I_data->Distance[string1[i-1]][string1[i]];
	}
	for (int i=1;i<=count2-1;i++){
		fit2+=I_data->Distance[string2[i-1]][string2[i]];
	}
	calculate_fit(string1[0],string1[count1-1],string2[0],string2[count2-1],count1-1, move[4]);
	I_data->use_frequency[count1-1][count2-1]=I_data->use_frequency[count1-1][count2-1]+1;
	for (int i=1;i<=count1-1;i++)
		s_t[string1[i]]=row2;
	for (int i=0;i<=count2-1;i++)
		s_t[string2[i]]=row1;
	if (cross_exchange_identify==2){
		for (int i=1;i<=count1-1;i++)
			tabu_table[s_t[string1[i]]][string1[i]]=iteration + tabu_l+rand()%tabu_l;// tabu
		for (int i=0;i<=count2-1;i++)
			tabu_table[s_t[string2[i]]][string2[i]]=iteration + tabu_l+rand()%tabu_l;// tabu
	}
	int start1=string1[0];
	int start11=start1;
	int end1=s->sol[row1][string1[count1-1]];
	int end11=end1;
	int start2,end2,start22;
	if (move[4]==1){//whether reverse 1 is not and 0 is true
		start2=s->sol_r[row2][string2[0]];
		end2=s->sol[row2][string2[count2-1]];
		start22=start2;
		for (int i=1;i<=count1-1;i++){
			s->sol[row1][string1[i]]=-1;
			s->sol_r[row1][string1[i]]=-1;
		}
		for (int i=0;i<=count2-1;i++){
			s->sol[row2][string2[i]]=-1;
			s->sol_r[row2][string2[i]]=-1;
		}
		for (int i=0;i<=count2-1;i++){
			s->sol[row1][start1]=string2[i];
			start1=string2[i];
		}
		s->sol[row1][start1]=end11;
		for(int i=1;i<=count1-1;i++){
			s->sol[row2][start2]=string1[i];
			start2=string1[i];
		}
		s->sol[row2][start2]=end2;
		// for sol_r
		for (int i=count2-1;i>=0;i--){
			s->sol_r[row1][end1]=string2[i];
			end1=string2[i];
		}
		s->sol_r[row1][end1]=start11;
		for (int i=count1-1;i>=1;i--){
			s->sol_r[row2][end2]=string1[i];
			end2=string1[i];
		}
		s->sol_r[row2][end2]=start22;
	}
	else{
		start2=s->sol[row2][string2[0]];
		end2=s->sol_r[row2][string2[count2-1]];
		start22=start2;
		for (int i=1;i<=count1-1;i++){
			s->sol[row1][string1[i]]=-1;
			s->sol_r[row1][string1[i]]=-1;
		}
		for (int i=0;i<=count2-1;i++){
			s->sol[row2][string2[i]]=-1;
			s->sol_r[row2][string2[i]]=-1;
		}
		for (int i=0;i<=count2-1;i++){
			s->sol[row1][start1]=string2[i];
			start1=string2[i];
		}
		s->sol[row1][start1]=end11;
		for(int i=1;i<=count1-1;i++){
			s->sol_r[row2][start2]=string1[i];
			start2=string1[i];
		}
		s->sol_r[row2][start2]=end2;
		// for sol_r
		for (int i=count2-1;i>=0;i--){
			s->sol_r[row1][end1]=string2[i];
			end1=string2[i];
		}
		s->sol_r[row1][end1]=start11;
		for (int i=count1-1;i>=1;i--){
			s->sol[row2][end2]=string1[i];
			end2=string1[i];
		}
		s->sol[row2][end2]=start22;
	}
}
void LS::intra_route_optimization(){// this method will include many methods to optimize each route, such as 2-opt, Lk and EAX.
	tem->fitness=s->fitness;
	int pointer;
	for (int i=0;i<=v_num-1;i++)
		for (int j=0;j<=num_v;j++){
			tem->sol[i][j]=s->sol[i][j];
			tem->sol_r[i][j]=s->sol_r[i][j];
		}
	int number_routes[v_num];
	int route[num_v+1];
	for (int i=0;i<=v_num-1;i++){
		if (record_table[i]==1){
			record_table[i]=0;
			pointer=s->sol[i][0];number_routes[i]=0;
			route[number_routes[i]]=0;number_routes[i]++;
			while (1){
				if (pointer==0)
					break;
				else{
					route[number_routes[i]]=pointer;
					number_routes[i]++;
					pointer=s->sol[i][pointer];
				}
			}
			int sub_route[number_routes[i]];
			for (int j=0;j<=number_routes[i]-1;j++)
				sub_route[j]=route[j];
//			for (int j=0;j<=number_routes[i]-1;j++)
//				cout<<sub_route[j]<<"  ";
//			cout<<endl;
			// here are many intra-route optimization operators.
			if (intra_opt==1)
				each_route->twoopt(sub_route,number_routes[i]);
			if (intra_opt==3){
				if (number_routes[i]>4)
					EAX(gEnv, sub_route,number_routes[i],I_data->x,I_data->y);
				else
					if (number_routes[i]==4)
						each_route->twoopt(sub_route,number_routes[i]);
			}
			// insert results to sol;
			pointer=0;
			for (int j=1;j<=number_routes[i]-1;j++){
				tem->sol[i][pointer]=sub_route[j];
				pointer=tem->sol[i][pointer];
			}
			tem->sol[i][pointer]=0;
			pointer=0;
			for (int j=number_routes[i]-1;j>=1;j--){
				tem->sol_r[i][pointer]=sub_route[j];
				pointer=tem->sol_r[i][pointer];
			}
			tem->sol_r[i][pointer]=0;
		}
		else
			continue;
	}
	double current_cost=0;
	for (int i=0;i<=v_num-1;i++){
		pointer=0;tem->fit_tour[i]=0;
		while (1){
			tem->fit_tour[i]+=I_data->Distance[pointer][tem->sol[i][pointer]];
			if (tem->sol[i][pointer]==0)
				break;
			else
				pointer=tem->sol[i][pointer];
		}
	}
	for (int i=0;i<=v_num-1;i++){
		if (tem->fit_tour[i]>current_cost)
			current_cost=tem->fit_tour[i];
	}
	if (current_cost<s->fitness){
		s->fitness=current_cost;
		for (int i=0;i<=v_num-1;i++){
			for (int j=0;j<=num_v;j++){
				s->sol[i][j]=tem->sol[i][j];
				s->sol_r[i][j]=tem->sol_r[i][j];
			}
			s->fit_tour[i]=tem->fit_tour[i];
		}
	}
	//update_best_solution();
}
double LS::gain_fun(int st1,int end1,int st2,int end2,int k, int reverse,int longest_third){
	double fit1=0;double fit2=0;
	//double opt_fit=s->fit_tour[ot];
	int pointer;double tem_fit=0;double tem_fit2=0;
	if (k==0 && reverse==1){//
		pointer=st2;
		while (pointer!=end2){
			tem_fit+=I_data->Distance[pointer][s->sol[s_t[pointer]][pointer]];
			pointer=s->sol[s_t[pointer]][pointer];
		}
		fit1+=tem_fit+I_data->Distance[st1][st2]+I_data->Distance[end2][s->sol[s_t[st1]][st1]]-I_data->Distance[st1][s->sol[s_t[st1]][st1]];
		fit2+=I_data->Distance[s->sol_r[s_t[st2]][st2]][s->sol[s_t[end2]][end2]]-I_data->Distance[s->sol_r[s_t[st2]][st2]][st2]-
				I_data->Distance[s->sol[s_t[st2]][end2]][end2];
		fit2=fit2-tem_fit;
	}
	if (k==0 && reverse==0){//
		pointer=st2;
		while (pointer!=end2){
			tem_fit+=I_data->Distance[pointer][s->sol_r[s_t[pointer]][pointer]];
			pointer=s->sol_r[s_t[pointer]][pointer];
		}
		fit1+=tem_fit+I_data->Distance[st1][st2]+I_data->Distance[end2][s->sol[s_t[st1]][st1]]-I_data->Distance[st1][s->sol[s_t[st1]][st1]];
		fit2+=I_data->Distance[s->sol[s_t[st2]][st2]][s->sol_r[s_t[end2]][end2]]-
			I_data->Distance[st2][s->sol[s_t[st2]][st2]]-I_data->Distance[end2][s->sol_r[s_t[end2]][end2]];
		fit2=fit2-tem_fit;
	}
	if (k!=0 && reverse==1){
		pointer=s->sol[s_t[end1]][st1];
		while (pointer!=end1){
			tem_fit+=I_data->Distance[pointer][s->sol[s_t[pointer]][pointer]];
			pointer=s->sol[s_t[pointer]][pointer];
		}
		pointer=st2;
		while (pointer!=end2){
			tem_fit2+=I_data->Distance[pointer][s->sol[s_t[pointer]][pointer]];
			pointer=s->sol[s_t[pointer]][pointer];
		}
		fit1+=tem_fit2+I_data->Distance[st1][st2]+I_data->Distance[end2][s->sol[s_t[end1]][end1]]-
			tem_fit-I_data->Distance[st1][s->sol[s_t[end1]][st1]]-I_data->Distance[end1][s->sol[s_t[end1]][end1]];
		fit2+=tem_fit+I_data->Distance[s->sol_r[s_t[st2]][st2]][s->sol[s_t[end1]][st1]]+I_data->Distance[s->sol[s_t[end2]][end2]][end1]-
			tem_fit2-I_data->Distance[st2][s->sol_r[s_t[st2]][st2]]-I_data->Distance[end2][s->sol[s_t[end2]][end2]];
	}
	if (k!=0 && reverse==0){
		pointer=s->sol[s_t[st1]][st1];
		while (pointer!=end1){
			tem_fit+=I_data->Distance[pointer][s->sol[s_t[pointer]][pointer]];
			pointer=s->sol[s_t[pointer]][pointer];
		}
		pointer=st2;
		while (pointer!=end2){
			tem_fit2+=I_data->Distance[pointer][s->sol_r[s_t[pointer]][pointer]];
			pointer=s->sol_r[s_t[pointer]][pointer];
		}
		fit1+=tem_fit2+I_data->Distance[st1][st2]+I_data->Distance[end2][s->sol[s_t[end1]][end1]]-
			tem_fit-I_data->Distance[st1][s->sol[s_t[st1]][st1]]-I_data->Distance[end1][s->sol[s_t[end1]][end1]];
		fit2+=tem_fit+I_data->Distance[s->sol[s_t[st2]][st2]][s->sol[s_t[st1]][st1]]+I_data->Distance[s->sol_r[s_t[end2]][end2]][end1]
			-tem_fit2-I_data->Distance[st2][s->sol[s_t[st2]][st2]]-I_data->Distance[end2][s->sol_r[s_t[end2]][end2]];
	}
	double result1=fit1+s->fit_tour[s_t[end1]];
	double result2=fit2+s->fit_tour[s_t[st2]];
	double delta=result1;;
	if (delta<result2)
		delta=result2;
	if (delta<s->fit_tour[longest_third])
		delta=s->fit_tour[longest_third];
	delta=delta-s->fitness;
	return delta;
}
void LS:: cross_exchange_1(){
	int pointer;
	for (int i=0;i<=v_num-1;i++){
		pointer=s->sol[i][0];
		while (pointer!=0){
			s_t[pointer]=i;
			pointer=s->sol[i][pointer];
		}
	}
	double delta;int in_num;
	int end2,end1;int count;double tem;int iden1,iden2;
	int better_move[6];double better_fit;
	int reverse;
	int step=0;
	double max_fitness;	int pt;int j;int longest_third;
	while (1){
		max_fitness=0;
		for (int i=0;i<=v_num-1;i++)
			if (s->fit_tour[i]>max_fitness){
				max_fitness=s->fit_tour[i];
				ot=i;
			}
		better_fit=0;step++;
		for (int i=0;i<=v_num-1;i++){
			if (i==ot)continue;// do not exchange substring in the same route
			pointer=s->sol[i][0];

			longest_third=-1;
			for (int j=0;j<=v_num-1;j++){
				if (j!=ot && j!=i && longest_third==-1)
					longest_third=j;
				if (longest_third>-1 && j!=ot && j!=i && s->fit_tour[longest_third]<s->fit_tour[j])
					longest_third=j;
			}
			while(1){
				if (pointer==0)break;
				else{
					pt=0;
					j=0;
					while(1){
						in_num=-1;
						pt=s->sol[ot][pt];
						if (pt==0)break;
						if (I_data->edge[pt][pointer]==0)
							continue;
						in_num=pt;
						if (in_num==-1)continue;
						count=0;
						if (1){// case 1
							iden1=0;end1=pointer;
							for (int k=0;k<=length_s-1;k++){// carry the out row
								reverse=1;
								if (k>0){
									end1=s->sol[i][end1];
								}
								if (end1==0 || iden1==1)break;//
								iden2=0;
								end2=in_num;
								for (int n=0;n<=length_s-1;n++){////////////////////////////////////////////////////
									if (n==1){// determine the right or left
										if (s->sol[s_t[in_num]][in_num]==0)reverse=0;//
										if (s->sol_r[s_t[in_num]][in_num]==0)reverse=1;//
										if (s->sol_r[s_t[in_num]][in_num]!=0 && s->sol[s_t[in_num]][in_num]!=0){
											if (gain_fun(pointer,end1,in_num,s->sol[s_t[in_num]][in_num],k,1,longest_third)<
												gain_fun(pointer,end1,in_num,s->sol_r[s_t[in_num]][in_num],k,0,longest_third))
												reverse=1;
											else
												reverse=0;
										}
									}
									if (reverse==1 && n!=0){
										end2=s->sol[s_t[end2]][end2];
									}
									if (reverse==0 && n!=0){
										end2=s->sol_r[s_t[end2]][end2];
									}
									if (end2==0 || iden2==1)break;
									delta=gain_fun(pointer,end1,in_num,end2,k,reverse,longest_third);
									if (delta<0){
										count++;
										cand_str1[count-1][0]=pointer;
										cand_str1[count-1][1]=end1;
										cand_str2[count-1][0]=in_num;
										cand_str2[count-1][1]=end2;
										rever_list[count-1]=reverse;
										cand_fit[count-1]=delta;
									}
								}
							}
						}
						if (count==0){continue;}
						tem=0;
						for (int k=0;k<=count-1;k++)
							if (tem>cand_fit[k]){
								near_cand1[j][0]=cand_str1[k][0];
								near_cand1[j][1]=cand_str1[k][1];
								near_cand1[j][2]=cand_str2[k][0];
								near_cand1[j][3]=cand_str2[k][1];
								near_cand1[j][4]=rever_list[k];
								near_fit[j]=cand_fit[k];
								tem=cand_fit[k];/////////////////////////////////////////////////////////////////////////////////////////////////////
							}
						j++;
					}
					for (int k=0;k<=j-1;k++){
						if (better_fit>near_fit[k]){
							better_fit=near_fit[k];
							better_move[0]=near_cand1[k][0];
							better_move[1]=near_cand1[k][1];
							better_move[2]=near_cand1[k][2];
							better_move[3]=near_cand1[k][3];
							better_move[4]=near_cand1[k][4];
						}
					}
				}
				pointer=s->sol[i][pointer];
			}
		}
		if (better_fit>-1.0e-7)
			break;
		record_table[s_t[better_move[0]]]=1;
		record_table[s_t[better_move[2]]]=1;
		replace_fun(better_move);
	}
//	update_best_solution();
}


void LS::insert(){
	int pointer;
	int pointer_2;
	int longest_tour=0;
	int longest_third;
	double delta,min_delta;
	int row_out,city_out,row_in,city_in;
	for (int i=1;i<=v_num-1;i++){// determine the longest tour;
		if (s->fit_tour[longest_tour]<s->fit_tour[i])
			longest_tour=i;
	}
	while(1){
		min_delta=Max;
		pointer=0;
		while(1){// loop for the longest tour
			pointer=s->sol[longest_tour][pointer];// this is the first city in longest tour;
			if (pointer==0)break;
			for (int i=0;i<=v_num-1;i++){
				if (i==longest_tour)continue;// not overlap
				//
				longest_third=-1;
				for (int j=0;j<=v_num-1;j++){
					if (j!=longest_tour && j!=i && longest_third==-1)
						longest_third=j;
					if (longest_third>-1 && j!=longest_tour && j!=i && s->fit_tour[longest_third]<s->fit_tour[j])
						longest_third=j;
				}
				pointer_2=0;
				while(1){
					/////////////////////////////////////////////////////////////////
					if (I_data->edge[pointer][pointer_2]!=1){
						pointer_2=s->sol[i][pointer_2];
						if (pointer_2==0)break;
						else continue;
					}
					///////////////////////////////////////////////////////////////////
					delta=calculate_fit_insert(longest_tour,pointer,i,pointer_2,longest_third);
					if (delta<min_delta){
						min_delta=delta;
						row_out=longest_tour;
						city_out=pointer;
						row_in=i;
						city_in=pointer_2;
					}
					pointer_2=s->sol[i][pointer_2];
					if (pointer_2==0)break;
				}
			}
		}
		if (min_delta+1.0e-7>0)break;
		longest_tour=replace_fun_insert(min_delta,row_out,city_out,row_in,city_in);
		record_table[row_out]=1;
		record_table[row_in]=1;
//		cout<<min_delta<<endl;
	}
}

void LS::inter_route_optimization(){
		insert();
	//	swap();
		cross_exchange_1();
}
void LS::local_search(){
	reverse_fun();// get value for sol_r;
	// to iterate all steps
	for (int i=0;i<=v_num-1;i++)
		record_table[i]=1;
	double local_optima;
	inter_route_optimization();
//	intra_route_optimization();
	local_optima=s->fitness;
	while (1){
		inter_route_optimization();
		if (local_optima-1.0e-7<s->fitness && local_optima+1.0e-7>s->fitness)
			break;
		else{
			local_optima=s->fitness;
			intra_route_optimization();
		}
		if(ceil((clock() - I_data->start)/static_cast<double>(CLOCKS_PER_SEC))>=time_length)
			break;
	}
	for (int i=0;i<=v_num-1;i++){
		for (int j=0;j<=num_v;j++){
			b_s->sol[i][j]=s->sol[i][j];
			b_s->sol_r[i][j]=s->sol_r[i][j];
		}
		b_s->fit_tour[i]=s->fit_tour[i];
	}
	b_s->fitness=s->fitness;
}













































///////////////////////////////////////////////////////////////////////weak perturbation





void LS:: cross_exchange_tabu(){
	int pointer;improve=0;
	for (int i=0;i<=v_num-1;i++){
		pointer=s->sol[i][0];
		while (pointer!=0){
			s_t[pointer]=i;
			pointer=s->sol[i][pointer];
		}
	}
	double delta;int in_num;int rand_order;
	int end2,end1;int iden1,iden2;
	int better_move[6];
	int reverse;
	double max_fitness;	int pt;int longest_third;

	double min_delta,min_tabu_delta;
	int can_node[100][6];
	int can_tabu_node[100][6];
	int num_best;
	int num_tabu_best;
	while (1){
		max_fitness=0;
		for (int i=0;i<=v_num-1;i++)
			if (s->fit_tour[i]>max_fitness){
				max_fitness=s->fit_tour[i];
				ot=i;
			}
		min_delta=Max;
		min_tabu_delta=Max;
		num_best=0;
		num_tabu_best=0;
		for (int i=0;i<=v_num-1;i++){
			if (ot==i)continue;
			pointer=s->sol[i][0];
			longest_third=-1;
			for (int j=0;j<=v_num-1;j++){
				if (j!=ot && j!=i && longest_third==-1)
					longest_third=j;
				if (longest_third>-1 && j!=ot && j!=i && s->fit_tour[longest_third]<s->fit_tour[j])
					longest_third=j;
			}
			while(1){
				if (pointer==0 )break;
				else{
					pt=0;
					while(1){
						in_num=-1;
						pt=s->sol[ot][pt];
						if (pt==0)break;
						if (I_data->edge[pt][pointer]==0)
							continue;
						in_num=pt;
						if (in_num==-1)continue;
						if (1){// case 1
							iden1=0;end1=pointer;
							for (int k=0;k<=length_s-1;k++){// carry the out row
								reverse=1;
								if (k>0){
									end1=s->sol[i][end1];
								}
								if (end1==0 || iden1==1)break;//
								iden2=0;
								end2=in_num;
								if (s->sol_r[s_t[in_num]][in_num]==0 && end2==in_num && s->sol[s_t[in_num]][in_num]==0)
									break;
								for (int n=0;n<=length_s-1;n++){////////////////////////////////////////////////////
									if (n==1){// determine the right or left
										if (s->sol[s_t[in_num]][in_num]==0)reverse=0;//
										if (s->sol_r[s_t[in_num]][in_num]==0)reverse=1;//
										if (s->sol_r[s_t[in_num]][in_num]!=0 && s->sol[s_t[in_num]][in_num]!=0){
											if (gain_fun(pointer,end1,in_num,s->sol[s_t[in_num]][in_num],k,1,longest_third)<
												gain_fun(pointer,end1,in_num,s->sol_r[s_t[in_num]][in_num],k,0,longest_third))
												reverse=1;
											else
												reverse=0;
										}
									}
									if (reverse==1 && n!=0){
										end2=s->sol[s_t[end2]][end2];
									}
									if (reverse==0 && n!=0){
										end2=s->sol_r[s_t[end2]][end2];
									}



									if (end2==0 || iden2==1 )break;
									if ((reverse==1 && s->sol[s_t[end2]][end2]==0 && s->sol_r[s_t[end2]][in_num]==0))
										break;
									if (reverse==0 && s->sol_r[s_t[end2]][end2]==0 && s->sol[s_t[end2]][in_num]==0)
										break;




									delta=gain_fun(pointer,end1,in_num,end2,k,reverse,longest_third);

									if ((end1==0 && tabu_table[i][end2]<=iteration)
										|| (tabu_table[i][end2]<=iteration && tabu_table[s_t[end2]][end1]<=iteration)){
										if (delta<min_delta){
											min_delta=delta;
											can_node[0][0]=pointer;
											can_node[0][1]=end1;
											can_node[0][2]=in_num;
											can_node[0][3]=end2;
											can_node[0][4]=reverse;
											can_node[0][5]=i;
											num_best=1;
										}
										else if (min_delta+1.0e-7>delta && min_delta-1.0e-7<delta && num_best<100){
											can_node[num_best][0]=pointer;
											can_node[num_best][1]=end1;
											can_node[num_best][2]=in_num;
											can_node[num_best][3]=end2;
											can_node[num_best][4]=reverse;
											can_node[num_best][5]=i;
											num_best++;
										}
									}
									else{
										if (min_tabu_delta>delta){
											min_tabu_delta=delta;
											can_tabu_node[0][0]=pointer;
											can_tabu_node[0][1]=end1;
											can_tabu_node[0][2]=in_num;
											can_tabu_node[0][3]=end2;
											can_tabu_node[0][4]=reverse;
											can_tabu_node[0][5]=i;
											num_tabu_best=1;
										}
										else if (min_tabu_delta+1.0e-7>delta && min_tabu_delta-1.0e-7<delta && num_tabu_best<100){
											min_tabu_delta=delta;
											can_tabu_node[num_tabu_best][0]=pointer;
											can_tabu_node[num_tabu_best][1]=end1;
											can_tabu_node[num_tabu_best][2]=in_num;
											can_tabu_node[num_tabu_best][3]=end2;
											can_tabu_node[num_tabu_best][4]=reverse;
											can_tabu_node[num_tabu_best][5]=i;
											num_tabu_best++;
										}
									}
								}
							}
						}
					}
				}
				pointer=s->sol[i][pointer];
				if (pointer==0)break;
			}
		}
		if (num_tabu_best==0 && num_best==0)
			break;
		if ((num_tabu_best>0 && min_tabu_delta+1.0e-7>min_delta && (s->fitness-min_tabu_delta - 1.0e-7 <b_s->fitness)) || num_best==0){
//			s->fitness=s->fitness-min_tabu_delta;
			rand_order=rand()%num_tabu_best;
			better_move[0]=can_tabu_node[rand_order][0];
			better_move[1]=can_tabu_node[rand_order][1];
			better_move[2]=can_tabu_node[rand_order][2];
			better_move[3]=can_tabu_node[rand_order][3];
			better_move[4]=can_tabu_node[rand_order][4];
			better_move[5]=can_tabu_node[rand_order][5];
		}
		else{
//			s->fitness=s->fitness-min_delta;
			rand_order=rand()%num_best;
			better_move[0]=can_node[rand_order][0];
			better_move[1]=can_node[rand_order][1];
			better_move[2]=can_node[rand_order][2];
			better_move[3]=can_node[rand_order][3];
			better_move[4]=can_node[rand_order][4];
			better_move[5]=can_node[rand_order][5];
		}
		record_table[better_move[5]]=1;
		record_table[s_t[better_move[2]]]=1;
		replace_fun(better_move);
		double costtt=b_s->fitness;
		if (s->fitness+1.0e-7<b_s->fitness){
			update_best_solution();
			improve=0;iteration_c=iteration;
			supply_edge();
		}
		else
			improve++;
		if (improve>threshold)
			break;
		iteration++;
		double fitness=0; double fitness_tem;
		for (int i=0;i<=v_num-1;i++){
			pointer=0;
			fitness_tem=0;
			while(1){
				fitness_tem+=I_data->Distance[pointer][s->sol[i][pointer]];
				pointer=s->sol[i][pointer];
				if (pointer==0)
					break;
			}
			if (fitness<fitness_tem)
				fitness=fitness_tem;
		}
		if(ceil((clock() - I_data->start)/static_cast<double>(CLOCKS_PER_SEC))>=time_length)
			break;
	}
//	for (int i=0;i<=v_num-1;i++){
//		for (int j=0;j<=num_v;j++){
//			s->sol[i][j]=b_s->sol[i][j];
//			s->sol_r[i][j]=b_s->sol_r[i][j];
//		}
//		s->fit_tour[i]=b_s->fit_tour[i];
//	}
//	s->fitness=b_s->fitness;
}



void LS::insert_tabu(){
	int pointer;improve=0;
	int pointer_2;
	int longest_tour=0;
	int longest_third;
	double delta;
	int row_out,city_out,row_in,city_in;
	int can_node[100][4];
	int can_tabu_node[100][4];
	double min_delta,min_tabu_delta;
	int num_best,num_tabu_best;
	for (int i=1;i<=v_num-1;i++){// determine the longest tour;
		if (s->fit_tour[longest_tour]<s->fit_tour[i])
			longest_tour=i;
	}
	while(1){
		min_delta=Max;min_tabu_delta=Max;num_best=0;num_tabu_best=0;
		pointer=0;
		if (s->sol[longest_tour][s->sol[longest_tour][pointer]]==0){
			I_data->determing_longest=1;
			return;
		}
		while(1){// loop for the longest tour
			pointer=s->sol[longest_tour][pointer];// this is the first city in longest tour;
			if (pointer==0)break;
			for (int i=0;i<=v_num-1;i++){
				if (i==longest_tour)continue;// not overlap
				//
				longest_third=-1;
				for (int j=0;j<=v_num-1;j++){
					if (j!=longest_tour && j!=i && longest_third==-1)
						longest_third=j;
					if (longest_third>-1 && j!=longest_tour && j!=i && s->fit_tour[longest_third]<s->fit_tour[j])
						longest_third=j;
				}
				pointer_2=0;
				while(1){
					/////////////////////////////////////////////////////////////////
					if (I_data->edge[pointer][pointer_2]!=1){
						pointer_2=s->sol[i][pointer_2];
						if (pointer_2==0)break;
						else continue;
					}
					///////////////////////////////////////////////////////////////////
					delta=calculate_fit_insert(longest_tour,pointer,i,pointer_2,longest_third);
					if (tabu_table[i][pointer]<iteration){
						if (delta<min_delta){
							min_delta=delta;
							can_node[0][0]=longest_tour;
							can_node[0][1]=pointer;
							can_node[0][2]=i;
							can_node[0][3]=pointer_2;
							num_best=1;
						}
						else if (min_delta+1.0e-7>delta && min_delta-1.0e-7<delta && num_best<100){
							can_node[num_best][0]=longest_tour;
							can_node[num_best][1]=pointer;
							can_node[num_best][2]=i;
							can_node[num_best][3]=pointer_2;
							num_best++;
						}
					}
					else{
						if (min_tabu_delta>delta){
							min_tabu_delta=delta;
							can_tabu_node[0][0]=longest_tour;
							can_tabu_node[0][1]=pointer;
							can_tabu_node[0][2]=i;
							can_tabu_node[0][3]=pointer_2;
							num_tabu_best=1;
						}
						else if (min_tabu_delta+1.0e-7>delta && min_tabu_delta-1.0e-7<delta && num_tabu_best<100)
						{
							can_tabu_node[num_tabu_best][0]=longest_tour;
							can_tabu_node[num_tabu_best][1]=pointer;
							can_tabu_node[num_tabu_best][2]=i;
							can_tabu_node[num_tabu_best][3]=pointer_2;
							num_tabu_best++;
						}
					}
					pointer_2=s->sol[i][pointer_2];
					if (pointer_2==0)break;
				}
			}
		}
		int rand_order;double delta_tabu;
		if ((num_tabu_best>0 && min_tabu_delta+1.0e-7<min_delta && (s->fitness+min_tabu_delta+1.0e-7 <b_s->fitness))|| num_best==0){
			rand_order=rand()%num_tabu_best;
			delta_tabu=min_tabu_delta;
			row_out=can_tabu_node[rand_order][0];
			city_out=can_tabu_node[rand_order][1];
			row_in=can_tabu_node[rand_order][2];
			city_in=can_tabu_node[rand_order][3];
		}
		else{
			rand_order=rand()%num_best;
			delta_tabu=min_delta;
			row_out=can_node[rand_order][0];
			city_out=can_node[rand_order][1];
			row_in=can_node[rand_order][2];
			city_in=can_node[rand_order][3];
		}
		tabu_table[row_out][city_out]=iteration + tabu_l+rand()%tabu_l;
		longest_tour=replace_fun_insert(delta_tabu,row_out,city_out,row_in,city_in);
		record_table[row_out]=1;
		record_table[row_in]=1;
		double costtt=b_s->fitness;
		if (s->fitness+1.0e-7<b_s->fitness){
			update_best_solution();
			supply_edge();
			improve=0;iteration_c=iteration;
		}
		else
			improve++;

		if (improve>threshold)
			break;
		iteration++;

		if(ceil((clock() - I_data->start)/static_cast<double>(CLOCKS_PER_SEC))>=time_length)
			break;
	}
}


void LS:: weak_perturb(){
	reverse_fun();// get value for sol_r;
	for (int i=0;i<=v_num-1;i++)
		for (int j=0;j<=num_v;j++)
			if (tabu_table[i][j]>0)
				tabu_table[i][j]=0;
	iteration=1;
	double local_optima=s->fitness;
	int no_imrpove=0;
	int step=0;
	while(1){
		if(ceil((clock() - I_data->start)/static_cast<double>(CLOCKS_PER_SEC))>=time_length)
			break;

		insert_tabu();
		iteration+=tabu_l*2;
		cross_exchange_tabu();

		iteration+=tabu_l*2;
//		for (int i=0;i<=v_num-1;i++)
//			record_table[i]=1;
		intra_route_optimization();


		if (s->fitness+1.0e-7<b_s->fitness)
			update_best_solution();


		if (local_optima+1.0e-7>b_s->fitness && local_optima-1.0e-7<b_s->fitness)
			no_imrpove++;
		else{
			local_optima=b_s->fitness;no_imrpove=0;
		}
		step++;
//		if (no_imrpove>50)break;
		cout<<step<<"   "<<b_s->fitness<<"   "<<s->fitness<<"    "<<no_imrpove<<endl;
		if (step==200)
			cout<<ceil((clock() - I_data->start)/static_cast<double>(CLOCKS_PER_SEC))<<endl;
	}
}

The file LS.h contains:
/*
 * LS.h
 *
 *  Created on: 18 Apr 2020
 *      Author: Peng
 */

#ifndef LS_H_
#define LS_H_
#include "Individual.h"
#include "read_data.h"
#include "Tstwoopt.h"
#include "environment.h"
class LS {
public:
	// methods
	LS(read_data * data);
	virtual ~LS();
	void local_search();
	void weak_perturb();
	// variables
	Individual* s;
	Individual*b_s;
	Individual * tem;
	read_data * I_data;
	Tstwoopt * each_route;
	TEnvironment * gEnv;
	int time_length;

private:
	void update_best_solution();
	void reverse_fun();
	void intra_route_optimization();
	void inter_route_optimization();
	// the methods for inter-routing methods 3
	double gain_fun(int st1,int end1,int st2,int end2,int k, int reverse,int longest_third);
	void replace_fun(int *move);
	void cross_exchange_1();
	void cross_exchange_tabu();
//	void swap();
//	void swap_tabu();
	void calculate_fit(int st1,int end1,int st2,int end2,int k, int reverse);
	void insert_tabu();
	void insert();
	int replace_fun_insert(double min_delta,int row_out,int city_out,int row_in,int city_in);
	double calculate_fit_insert(int row_out,int city_out,int row_in,int city_in,int longest_third);
	void supply_edge();
//	double calculate_fit_swap(int row_out,int city_out,int row_in,int city_in,int longest_third);
//	int replace_fun_swap(double min_delta,int row_out,int city_out,int row_in,int city_in);






	// general variables
	int num_v;
	int v_num;
	int* record_table;
	int * s_t;// this variable is used to record cities are belonged to which routes during in searching
	// variables for inter-routing methods 3
	int ** cand_str1;
	int ** cand_str2;
	double * cand_fit;
	int **near_cand1;
	double *near_fit;
	int *rever_list;
	int ot;// to record the best route;
	// variables for tabu search.
	int iteration;
	int ** tabu_table;
	int **tabu_table_c;
	int iteration_c;
	int improve;
	//
	int **t_t_swap;



};
#endif /* LS_H_ */





/* void LS::swap_tabu(){
	int pointer;improve=0;
	int pointer_2;
	int longest_tour=0;
	int longest_third;
	double delta,delta_tabu;
	int row_out,city_out,row_in,city_in;
	int can_node[100][4];
	int can_tabu_node[100][4];
	double min_delta,min_tabu_delta;
	int num_best,num_tabu_best;
	int rand_order;
	int i,j;
	for ( i=1;i<=v_num-1;i++){// determine the longest tour;
		if (s->fit_tour[longest_tour]<s->fit_tour[i])
			longest_tour=i;
	}
	while (1){
		min_delta=Max;min_tabu_delta=Max;
		pointer=0;
		if (s->sol[longest_tour][s->sol[longest_tour][pointer]]==0){
			I_data->determing_longest=1;
			return;
		}
		while(1){
			pointer=s->sol[longest_tour][pointer];
			if (pointer==0)break;
			for ( i=0;i<=v_num-1;i++){
				if (i==longest_tour)continue;
				longest_third=-1;
				for ( j=0;j<=v_num-1;j++){
					if (j!=longest_tour && j!=i && longest_third==-1)
						longest_third=j;
					if (longest_third>-1 && j!=longest_tour && j!=i && s->fit_tour[longest_third]<s->fit_tour[j])
						longest_third=j;
				}
				pointer_2=s->sol[i][0];
				while(1){
					delta=calculate_fit_swap(longest_tour,pointer,i,pointer_2,longest_third);
					if (tabu_table[i][pointer]<iteration && tabu_table[longest_tour][pointer_2]<iteration){
						if (delta<min_delta){
							min_delta=delta;
							can_node[0][0]=longest_tour;
							can_node[0][1]=pointer;
							can_node[0][2]=i;
							can_node[0][3]=pointer_2;
							num_best=1;
						}
						else if (min_delta+1.0e-7>delta && min_delta-1.0e-7<delta && num_best<100){
							can_node[num_best][0]=longest_tour;
							can_node[num_best][1]=pointer;
							can_node[num_best][2]=i;
							can_node[num_best][3]=pointer_2;
							num_best++;
						}
					}
					else {
						if (min_tabu_delta>delta){
							min_tabu_delta=delta;
							can_tabu_node[0][0]=longest_tour;
							can_tabu_node[0][1]=pointer;
							can_tabu_node[0][2]=i;
							can_tabu_node[0][3]=pointer_2;
							num_tabu_best=1;
						}
						else if (min_tabu_delta+1.0e-7>delta && min_tabu_delta-1.0e-7<delta && num_tabu_best<100)
						{
							can_tabu_node[num_tabu_best][0]=longest_tour;
							can_tabu_node[num_tabu_best][1]=pointer;
							can_tabu_node[num_tabu_best][2]=i;
							can_tabu_node[num_tabu_best][3]=pointer_2;
							num_tabu_best++;
						}
					}
					pointer_2=s->sol[i][pointer_2];
					if (pointer_2==0)break;
				}
			}
		}
		if ((num_tabu_best>0 && min_tabu_delta+1.0e-7<min_delta && (s->fitness+min_tabu_delta+1.0e-7 <b_s->fitness))|| num_best==0){
			rand_order=rand()%num_tabu_best;
			delta_tabu=min_tabu_delta;
			row_out=can_tabu_node[rand_order][0];
			city_out=can_tabu_node[rand_order][1];
			row_in=can_tabu_node[rand_order][2];
			city_in=can_tabu_node[rand_order][3];
		}
		else{
			rand_order=rand()%num_best;
			delta_tabu=min_delta;
			row_out=can_node[rand_order][0];
			city_out=can_node[rand_order][1];
			row_in=can_node[rand_order][2];
			city_in=can_node[rand_order][3];
		}
		tabu_table[row_out][city_out]=iteration+tabu_l+rand()%tabu_l;
		tabu_table[row_in][city_in]=iteration+tabu_l+rand()%tabu_l;
		longest_tour=replace_fun_swap(delta_tabu,row_out,city_out,row_in,city_in);
		record_table[row_out]=1;
		record_table[row_in]=1;
		if (s->fitness+1.0e-7<b_s->fitness){
			update_best_solution();
			improve=0;iteration_c=iteration;
//			return;
		}
		else
			improve++;

		if (improve>threshold)
			return;
		iteration++;
//		cout<<min_delta<<endl;
	}
} */
/* void LS::swap(){
	int pointer;
	int pointer_2;
	int longest_tour=0;
	int longest_third;
	double delta,min_delta;
	int row_out,city_out,row_in,city_in;
	for (int i=1;i<=v_num-1;i++){// determine the longest tour;
		if (s->fit_tour[longest_tour]<s->fit_tour[i])
			longest_tour=i;
	}
	while (1){
		min_delta=Max;
		pointer=0;
		while(1){
			pointer=s->sol[longest_tour][pointer];
			if (pointer==0)break;
			for (int i=0;i<=v_num-1;i++){
				if (i==longest_tour)continue;
				longest_third=-1;
				for (int j=0;j<=v_num-1;j++){
					if (j!=longest_tour && j!=i && longest_third==-1)
						longest_third=j;
					if (longest_third>-1 && j!=longest_tour && j!=i && s->fit_tour[longest_third]<s->fit_tour[j])
						longest_third=j;
				}
				pointer_2=s->sol[i][0];
				while(1){
					delta=calculate_fit_swap(longest_tour,pointer,i,pointer_2,longest_third);
					if (delta<min_delta){
						min_delta=delta;
						row_out=longest_tour;
						city_out=pointer;
						row_in=i;
						city_in=pointer_2;
					}
					pointer_2=s->sol[i][pointer_2];
					if (pointer_2==0)break;
				}
			}
		}
		if (min_delta+1.0e-7>0)break;
		longest_tour=replace_fun_swap(min_delta,row_out,city_out,row_in,city_in);
		record_table[row_out]=1;
		record_table[row_in]=1;
//		cout<<min_delta<<endl;
	}
} */
/* double LS::calculate_fit_swap(int row_out,int city_out,int row_in,int city_in,int longest_third){
	double delta1=0;
	double delta2=0;
	delta1+=I_data->Distance[s->sol_r[row_out][city_out]][city_in]+I_data->Distance[city_in][s->sol[row_out][city_out]];
	delta1=delta1-I_data->Distance[s->sol_r[row_out][city_out]][city_out]-I_data->Distance[city_out][s->sol[row_out][city_out]];
	//
	delta2+=I_data->Distance[s->sol_r[row_in][city_in]][city_out]+I_data->Distance[s->sol[row_in][city_in]][city_out];
	delta2=delta2-I_data->Distance[s->sol_r[row_in][city_in]][city_in]-I_data->Distance[s->sol[row_in][city_in]][city_in];
	//
	delta1=s->fit_tour[row_out]+delta1;
	delta2=s->fit_tour[row_in]+delta2;
	double delta=delta1;
	if (delta<delta2)
		delta=delta2;
	if (delta<s->fit_tour[longest_third])
		delta=s->fit_tour[longest_third];
	delta=delta-s->fitness;
	return delta;
}
int LS::replace_fun_swap(double min_delta,int row_out,int city_out,int row_in,int city_in){
	double delta1=0;
	double delta2=0;
	delta1+=I_data->Distance[s->sol_r[row_out][city_out]][city_in]+I_data->Distance[city_in][s->sol[row_out][city_out]];
	delta1=delta1-I_data->Distance[s->sol_r[row_out][city_out]][city_out]-I_data->Distance[city_out][s->sol[row_out][city_out]];
	//
	delta2+=I_data->Distance[s->sol_r[row_in][city_in]][city_out]+I_data->Distance[s->sol[row_in][city_in]][city_out];
	delta2=delta2-I_data->Distance[s->sol_r[row_in][city_in]][city_in]-I_data->Distance[s->sol[row_in][city_in]][city_in];
	//
	s->fit_tour[row_out]=s->fit_tour[row_out]+delta1;
	s->fit_tour[row_in]=s->fit_tour[row_in]+delta2;
	int longest_tour=0;
	for (int i=1;i<=v_num-1;i++)
		if (s->fit_tour[i]>s->fit_tour[longest_tour])
			longest_tour=i;
	s->fitness=s->fit_tour[longest_tour];
	//
	int p_p,n_p;
	p_p=s->sol_r[row_out][city_out];
	n_p=s->sol[row_out][city_out];
	s->sol[row_out][p_p]=city_in;
	s->sol[row_out][city_in]=n_p;
	s->sol[row_out][city_out]=-1;
	s->sol_r[row_out][n_p]=city_in;
	s->sol_r[row_out][city_in]=p_p;
	s->sol_r[row_out][city_out]=-1;
	//
	p_p=s->sol_r[row_in][city_in];
	n_p=s->sol[row_in][city_in];
	s->sol[row_in][p_p]=city_out;
	s->sol[row_in][city_out]=n_p;
	s->sol[row_in][city_in]=-1;
	s->sol_r[row_in][n_p]=city_out;
	s->sol_r[row_in][city_out]=p_p;
	s->sol_r[row_in][city_in]=-1;
	return longest_tour;
} */

The file perturb.cpp contains:
/*
 * perturb.cpp
 *
 *  Created on: 10 Jul 2020
 *      Author: Peng
 */

#include "perturb.h"
#include "read_data.h"
#include "Individual.h"
#include "basic.h"
perturb::perturb() {
}

perturb::~perturb() {
	delete [] s_t;
}
void perturb::define(){
	s_t=new int [I_data->num_v+1];
}
double perturb::determine_delta(int row,int city,int pointer){
	double delta=0;
	delta=I_data->Distance[pointer][city]+I_data->Distance[city][s->sol[row][pointer]];
	delta=delta-I_data->Distance[pointer][s->sol[row][pointer]];
	return delta;
}
void perturb::insert_fun(int city,int row,int loc,double delta_min){
	int n_p=s->sol[row][loc];
	s->sol[row][loc]=city;
	s->sol[row][city]=n_p;
	s->fit_tour[row]+=delta_min;
}

void perturb::perturb_fun1(){
	int pointer;int n_p,p_p;
	vector<int >node;
	for (int i=0;i<=I_data->v_num-1;i++){
		pointer=s->sol[i][0];
		while (1){
			if (pointer==0)break;
			if (rand()%1000<prob){// a route should include at least a city
				node.push_back(pointer);
				n_p=s->sol[i][pointer];
				p_p=s->sol_r[i][pointer];
				s->sol[i][p_p]=n_p;
				s->sol[i][pointer]=-1;
				s->sol_r[i][n_p]=p_p;
				s->sol_r[i][pointer]=-1;
				pointer=n_p;
			}
			else
				pointer=s->sol[i][pointer];
		}
	}
	for (int i=0;i<=I_data->v_num-1;i++){
		s->fit_tour[i]=0;
		pointer=0;
		while(1){
			s->fit_tour[i]+=I_data->Distance[pointer][s->sol[i][pointer]];
			pointer=s->sol[i][pointer];
			if (pointer==0)break;
		}
	}
	random_shuffle(node.begin(), node.end());
	int node_size=node.size();
	double delta,delta_min;int row,loc;
	for (int i =0;i<=node_size-1;i++){
		delta_min=Max;
		row=0;
		pointer=0;
		for (int j=0;j<=I_data->v_num-1;j++){
			if (s->sol[j][pointer]==0 && pointer==0){
				delta=determine_delta(j,node[i],pointer);
				row=j;
				loc=pointer;
				delta_min=delta;
				continue;
			}
		}
		for (int j=0;j<=I_data->v_num-1;j++)
			if (s->fit_tour[row]>s->fit_tour[j])
				row=j;
		while(1){
			delta=determine_delta(row,node[i],pointer);
			if (delta_min>delta){
				delta_min=delta;
				loc=pointer;
			}
			pointer=s->sol[row][pointer];
			if (pointer==0)
				break;
		}
		insert_fun(node[i],row,loc,delta_min);
	}
	s->fitness=0;
	for (int i=0;i<=I_data->v_num-1;i++){
		if(s->fit_tour[i]>s->fitness)
			s->fitness=s->fit_tour[i];
	}

	// check;
	int count=0;
	for (int i=0;i<=I_data->v_num-1;i++){
		pointer=0;
		while(1){
			pointer=s->sol[i][pointer];
			if (pointer>0)count++;
			else break;
		}
	}
	if (!(count==I_data->num_v)){
		cout<<"initial solution is wrong"<<endl;
		exit(0);
	}
}
void perturb::perturb_fun2(){
	int pointer;int n_p,p_p;
	vector<int >node;
	for (int i=0;i<=I_data->v_num-1;i++){
		pointer=s->sol[i][0];
		while (1){
			if (pointer==0)break;
			if (rand()%1000<prob){// a route should include at least a city
				node.push_back(pointer);
				n_p=s->sol[i][pointer];
				p_p=s->sol_r[i][pointer];
				s->sol[i][p_p]=n_p;
				s->sol[i][pointer]=-1;
				s->sol_r[i][n_p]=p_p;
				s->sol_r[i][pointer]=-1;
				pointer=n_p;
			}
			else
				pointer=s->sol[i][pointer];
		}
	}
	for (int i=0;i<=I_data->v_num-1;i++){
		s->fit_tour[i]=0;
		pointer=0;
		while(1){
			s->fit_tour[i]+=I_data->Distance[pointer][s->sol[i][pointer]];
			pointer=s->sol[i][pointer];
			if (pointer==0)break;
		}
	}
	random_shuffle(node.begin(), node.end());
	for (int i=0;i<=I_data->v_num-1;i++){
		pointer=s->sol[i][0];
		while (pointer!=0){
			s_t[pointer]=i;
			pointer=s->sol[i][pointer];
		}
	}
	int count;
	double delta,delta_min;int row,loc;
	for (int i=0;i<=I_data->v_num-1;i++){
		pointer=0;
		if (s->sol[i][pointer]==0){
			while(1){
				if (s_t[node[count]]!=i){
					delta=determine_delta(i,node[count],pointer);
					row=i;
					loc=pointer;
					delta_min=delta;
					insert_fun(node[count],row,loc,delta_min);
					node.erase(node.begin()+count);
					break;
				}
				else{
					count++;
				}
			}
		}
	}
	int node_size=node.size();
	for (int i =0;i<=node_size-1;i++){
		delta_min=Max;
		row=0;
		pointer=0;
		for (int j=0;j<=I_data->v_num-1;j++)
			if (s->fit_tour[row]>s->fit_tour[j]  && s_t[node[i]]!=j)
				row=j;
		while(1){
			delta=determine_delta(row,node[i],pointer);
			if (delta_min>delta){
				delta_min=delta;
				loc=pointer;
			}
			pointer=s->sol[row][pointer];
			if (pointer==0)
				break;
		}
		insert_fun(node[i],row,loc,delta_min);
	}
	s->fitness=0;
	for (int i=0;i<=I_data->v_num-1;i++){
		if(s->fit_tour[i]>s->fitness)
			s->fitness=s->fit_tour[i];
	}
	// check;
	count=0;
	for (int i=0;i<=I_data->v_num-1;i++){
		pointer=0;
		while(1){
			pointer=s->sol[i][pointer];
			if (pointer>0)count++;
			else break;
		}
	}
	if (!(count==I_data->num_v)){
		cout<<"initial solution is wrong"<<endl;
		exit(0);
	}
}

void perturb:: perturbation(){
	double d = static_cast<double>(no_improve)/control_para;
	double e=pow(2.718,-d);
	prob=(1-e*0.9)*1000;
//	cout<<prob<<"   ";

//	prob=Probability;
	if (perturbation_method==1)
		perturb_fun1();
	if (perturbation_method==2)
		perturb_fun2();
}

The file perturb.h contains:
/*
 * perturb.h
 *
 *  Created on: 10 Jul 2020
 *      Author: Peng
 */

#ifndef PERTURB_H_
#define PERTURB_H_
#include "read_data.h"
#include "Individual.h"
class perturb {
public:
	perturb();
	virtual ~perturb();
	void define();

	Individual * s;
	read_data * I_data;
	void perturbation();
	int no_improve;
private:
	void perturb_fun1();
	double determine_delta(int row,int city,int pointer);
	void insert_fun(int city,int row,int loc,double delta_min);
	void perturb_fun2();
	// variables
	int *s_t;
	double prob;
};

#endif /* PERTURB_H_ */

The file randomize.cpp contains:
/*
 * randomize.cpp
 *   created on: April 24, 2013
 * last updated: June 13, 2013
 *       author: liushujia
 */

#ifndef __RAND__
#include "randomize.h"
#endif

TRandom* tRand = NULL;

void InitURandom(){
	int seed;
	unsigned short seed16v[3];
	seed = 1111;
	seed16v[0] = 100;
	seed16v[1] = 200;
	seed16v[2] = seed;
	tRand = new TRandom();
	srand( seed );
}

void InitURandom( int dd ){
	int seed;
	unsigned short seed16v[3];
	seed = dd;
	seed16v[0] = 100;
	seed16v[1] = 200;
	seed16v[2] = seed;
	tRand = new TRandom();
	srand( seed );
}

TRandom::TRandom(){}
TRandom::~TRandom(){}

int TRandom::Integer( int minNumber, int maxNumber ){
	return minNumber + (rand() % (maxNumber - minNumber + 1));
}

double TRandom::Double( double minNumber, double maxNumber ){
	return minNumber + rand() % (int)(maxNumber - minNumber);
}

void TRandom::permutation( int *array, int numOfElement, int numOfSample ){
	if( numOfElement <= 0 ) return;
	int i, j, k, r;
	int *b = new int[numOfElement];
	for(j=0;j<numOfElement;j++) b[j]=0;
	for(i=0;i<numOfSample;i++){
		r=rand()%(numOfElement-i);
		k=0;
		for(j=0;j<=r;j++){
			while(b[k]==1) ++k;
			k++;
		}
		array[i]=k-1;
		b[k-1]=1;
	}
	delete [] b;
}

double TRandom::normalDistribution( double mu, double sigma ){
	double U1,U2,X;
	double PI = 3.1415926;
	while( 1 ){
		U1 = this->Double( 0.0, 1.0 );
		if( U1 != 0.0 ) break;
	}
	U2 = this->Double( 0.0, 1.0 );
	X = sqrt(-2.0*log(U1)) * cos(2*PI*U2);
	return( mu + sigma*X );
}

void TRandom::shuffle( int *array, int numOfElement ){
	int *a = new int[numOfElement];
	int *b = new int[numOfElement];
	this->permutation( b, numOfElement, numOfElement );
	for( int i = 0; i < numOfElement; ++i ) a[ i ] = array[ i ];
	for( int i = 0; i < numOfElement; ++i ) array[ i ] = a[ b[ i ] ];
	delete [] a;
	delete [] b;
}

The file randomize.h contains:
/*
 * randomize.h
 *   created on: April 24, 2013
 * last updated: June 13, 2013
 *       author: liushujia
 */

#ifndef __RAND__
#define __RAND__

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <time.h>

extern void InitURandom( int );
extern void InitURandom( void );

class TRandom {
public:
	TRandom();
	~TRandom();
	int Integer( int minNumber, int maxNumber );
	double Double( double minNumber, double maxNumber );
	double normalDistribution( double mu, double sigma );
	void permutation( int *array, int numOfelement, int numOfSample );	// éš�æœºäº§ç”Ÿç§�ç¾¤çš„ä¸€ä¸ªæŽ’åˆ—
	void shuffle( int *array, int numOfElement );						// æ ¹æ�®äº§ç”Ÿçš„æŽ’åˆ—è°ƒæ•´ç§�ç¾¤ä¸­çš„ä¸ªä½“ä½�ç½®
};

extern TRandom* tRand;


#endif



The file readme.txt contains:
this code includes that all edges from elite solutions are added into the edge.

The file read_data.cpp contains:
/*
 * readdata.cpp
 *
 *  Created on: 17 Apr 2020
 *      Author: Peng
 */

#include "read_data.h"
#include "basic.h"
#include "Individual.h"
#include <sstream>
read_data::read_data() {

}
read_data::~read_data() {
	for (i=0;i<=num_v;i++){
		delete [] Distance[i];
		delete [] edge[i];
		delete [] record[i];
		delete [] beta[i];
	}
	delete [] Distance;
	delete [] edge;
	delete [] beta;
	delete [] record;
	for (i=0;i<=num_v;i++)
		delete [] near_ns[i];
	delete [] near_ns;
	for ( i=0;i<=num_v;i++)
		delete [] near[i];
	delete [] near;
	for (i=0;i<=length_s-1;i++)
		delete [] use_frequency[i];
	delete [] use_frequency;
	delete [] x;
	delete [] y;
	for (int i=0;i<=num_v;i++)
		delete [] city[i].son;
	delete [] city;
	delete [] low_cost;
	delete [] check_city;
}
void read_data::define(){
	Distance=new double *[num_v+1];
	edge=new int *[num_v+1];
	record=new int *[num_v+1];
	beta=new double *[num_v+1];
	for ( i=0;i<=num_v;i++){
		Distance[i]=new double [num_v+1];
		edge[i]=new int [num_v+1];
		record[i]=new int [num_v+1];
		beta[i]=new double [num_v+1];
	}
	x=new double [num_v+1];
	y=new double [num_v+1];
	near_ns=new int *[num_v+1];
	near= new int *[num_v+1];
	for ( i=0;i<=num_v;i++)
		near[i]=new int	[num_near_nodes];
	for ( i=0;i<=num_v;i++)
		near_ns[i]=new int [num_v+1];
	use_frequency=new int *[length_s];
	for (i=0;i<=length_s-1;i++)
		use_frequency[i]=new int [length_s];
	for (i=0;i<=length_s-1;i++)
		for (j=0;j<=length_s-1;j++)
			use_frequency[i][j]=0;
	/////
	city=new node[num_v+1];
	for (int i=0;i<=num_v;i++)
		city[i].son=new int [num_v+1];
	low_cost=new double [num_v+1];
	check_city=new int [num_v+1];
}
void read_data::read_fun(char* file_name,int number_node){
//	instance_n=file_name;
	ifstream open_file(file_name);
	num_v=number_node;
//	char aa[100];
	char bb[1000];
	open_file>>instance_n;open_file>>bb;
	open_file>>v_num;
	define();
	int c;  //
	for ( i=0;i<=num_v;i++) {
		open_file>>c;open_file>>x[i];open_file>>y[i];//
	}
	open_file.close();
	if ( strcmp( bb, "EUC_2D" ) == 0  ){
		graph_type=1;
		for ( i=0;i<=num_v;i++)
			for ( j=0;j<=num_v;j++)
					Distance[i][j]=sqrt((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j]));
	}
	if ( strcmp( bb, "ATT" ) == 0  ){
		graph_type=2;
		for( int i = 0; i <=num_v; ++i ){
			for( int j = 0; j <=num_v; ++j ) {
				double r = (sqrt(((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j]))/10.0));
				int t = (int)r;
				if( (double)t < r ) {
					Distance[ i ][ j ] = t+1;
				}
				else {
					Distance[ i ][ j ] = t;
				}
			}
		}
	}
	if ( strcmp( bb, "CEIL_2D" ) == 0  ){
		graph_type=3;
		for ( i=0;i<=num_v;i++)
			for ( j=0;j<=num_v;j++)
					Distance[i][j]=ceil(sqrt((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j])));
	}
	// determine nearest nodes
	double min_dis;int check_in[num_v+1];int cityNum;
	for ( i=1;i<=num_v;i++){
		for ( j=0;j<=num_v;j++)
			check_in[j]=0;
		check_in[i]=1;
		near[i][0]=i;// the nearest city is itself.
		for (j=1;j<=num_near_nodes-1;j++){
			min_dis=Max;
			for (k=0;k<=num_v;k++){
				if (Distance[i][k]<=min_dis && check_in[k]==0){
					cityNum=k;
					min_dis=Distance[i][k];
				}
			}
			near[i][j]=cityNum;
			check_in[cityNum]=1;
		}
	}
	for ( i=0;i<=num_v;i++)
		for ( j=0;j<=num_v;j++)
			near_ns[i][j]=0;
	for ( i=1;i<=num_v;i++){
		for ( j=1;j<=num_near_nodes-1;j++)
			near_ns[i][near[i][j]]=1;
	}
	// construct sparse graph
	spanning_tree();
	alpha_sparse_graph();
}

void read_data::spanning_tree(){
	//miniming spanning tree
	for (int i=0;i<=num_v;i++){
		city[i].order=i;
		city[i].father=-1;
		city[i].num_son=0;
		for (int j=0;j<=num_v;j++)
			city[i].son[i]=-1;
		check_city[i]=0;
	}
	// generate minimum spanning tree;
//	double low_cost[num_v];
	int v;int pre_v;
	check_city[1]=1;
	pre_v=1;
	for (int i=2;i<=num_v;i++)
		low_cost[i]=Distance[1][i];
	double min_dis;
	for (int i=2;i<=num_v;i++){
		min_dis=Max;
		v=-1;
		for (int j=1;j<=num_v;j++){
			if (check_city[j]==0 && min_dis>low_cost[j]){
				v=j;
				min_dis=low_cost[j];
			}
		}
		if (v!=-1){
			for (int k=1;k<=num_v;k++)
				if (min_dis+1.0e-7>Distance[k][v] && min_dis-1.0e-7<Distance[k][v] && check_city[k]==1)
					pre_v=k;
			check_city[v]=1;
			city[v].father=pre_v;
			city[pre_v].son[city[pre_v].num_son]=v;
			city[pre_v].num_son++;
			//
			for (int k=1;k<=num_v;k++){
				if (check_city[k]==0 && Distance[k][v]<low_cost[k])
					low_cost[k]=Distance[k][v];
			}
		}
	}
	// visit the spanning tree;
	for (int i=0;i<=num_v;i++)
		for (int j=0;j<=num_v;j++)
			edge[i][j]=0;
	visit_tree(1);
}
void read_data::visit_tree(int root){
	if (city[root].num_son!=0){
		for (int i=0;i<=city[root].num_son-1;i++){
			edge[city[root].order][city[root].son[i]]=1;
			edge[city[root].son[i]][city[root].order]=1;
		//	cout<<"edge "<<city[root].order<<","<<city[root].son[i]<<endl;
			visit_tree(city[root].son[i]);
		}
	}
}
void read_data::post_travel_tree(int root){
	if (city[root].num_son!=0){
		for (int i=0;i<=city[root].num_son-1;i++){
			key=city[root].son[i];
			visit_tree_beta(1);
			post_travel_tree(city[root].son[i]);
		}
	}
}
void read_data::visit_tree_beta(int root){
	if (city[root].num_son!=0){
		for (int i=0;i<=city[root].num_son-1;i++){
			if (key!=city[root].son[i] && edge[key][city[root].son[i]]!=1 && beta[key][city[root].son[i]]<0){
				beta[key][city[root].son[i]]=get_max(beta[key][city[root].order],Distance[city[root].son[i]][city[root].order]);
				beta[city[root].son[i]][key]=beta[key][city[root].son[i]];
			}
			if (edge[key][city[root].son[i]]==1 && key!=city[root].son[i] ){
				beta[key][city[root].son[i]]=Distance[city[root].son[i]][key];
				beta[city[root].son[i]][key]=beta[key][city[root].son[i]];
			}
			visit_tree_beta(city[root].son[i]);
		}
	}
}
double read_data:: get_max(double a,double b){
	if (a>b)return a;
	else return b;
}
void read_data::alpha_sparse_graph(){
	int city_1=1;
	int city_2=2;
	double min_edge=Distance[0][city_1];
	double sub_min_edge=Distance[0][city_2];
	for (int i=3;i<=num_v;i++){
		if (Distance[0][i]<min_edge){
			min_edge=Distance[0][i];
			city_1=i;
		}
		if (Distance[0][i]>min_edge && Distance[0][i]<sub_min_edge){
			sub_min_edge=Distance[0][i];
			city_2=i;
		}
	}
	city[0].son[0]=city_1;
	city[0].son[1]=city_2;
	edge[0][city_1]=1;
	edge[0][city_2]=1;
	edge[city_1][0]=1;
	edge[city_2][0]=1;
	///////////////////////////////////////////////////////////////////////////////////////
	//compute alpha for each node and insert it into graph edge
	for (int i=0;i<=num_v;i++)
		for (int j=0;j<=num_v;j++)
			beta[i][j]=-Max;
	// min_edge,sub_min_edge;
	for (int i=1;i<=num_v;i++){
		if (i==city[0].son[0] || i== city[0].son[1])
			continue;
		beta[0][i]=Distance[0][i]-Distance[0][city[0].son[1]];
		beta[i][0]=beta[0][i];
	}
	// compute for root
	key=1;
	visit_tree_beta(1);
	for (int i=0;i<=num_v;i++)
		for (int j=0;j<=num_v;j++)
			if (edge[i][j]==1)
				beta[i][j]=Distance[i][j];
	// compute for leaf
	post_travel_tree(1);
	// generate sparse graph
	for (int i=1;i<=num_v;i++)
		for (int j=1;j<=num_v;j++)
			beta[i][j]=Distance[i][j]-beta[i][j];
	// in this place, beta is matrix alpha
	// sort all value in beta and construct sparse graph
	for (int i=0;i<=num_v;i++)
		for (int j=0;j<=num_v;j++)
			record[i][j]=j;
	for (int i=0;i<=num_v;i++){
		Qsort(i,0,num_v);
	}
	for (int i=0;i<=num_v;i++)
		for (int j=1;j<=alpha;j++){
			edge[i][record[i][j]]=1;
			edge[record[i][j]][i]=1;
		}
}
void read_data::Qsort(int i,int low, int high){
	if (high<=low)return;
	int m=low;
	int j=high+1;
	int k=beta[i][low];
	while (true){
		while(beta[i][++m]<k)
			if (m==high)
				break;
		while (beta[i][--j]>k)
			if (j==low)
				break;
		if (m>=j)
			break;
		double temp=beta[i][m];
		int tem=record[i][m];
		beta[i][m]=beta[i][j];
		beta[i][j]=temp;
		record[i][m]=record[i][j];
		record[i][j]=tem;
	}
	double temp=beta[i][low];
	int tem=record[i][low];
	beta[i][low]=beta[i][j];
	record[i][low]=record[i][j];
	beta[i][j]=temp;
	record[i][j]=tem;
	Qsort(i,low,j-1);
	Qsort(i,j+1,high);
}
/////////////////////////////////////////////////////////////////////////////////////////////////



































void read_data::output_fun(Individual *g_best_p ,int seed){// this function is used to
	int pointer;
	char name_instance[100]={0};
	strcpy(name_instance, instance_n.c_str());
	int size=strlen (name_instance);
	name_instance[size]='_';
	size=strlen( name_instance);
	char num_vehcile[10];
	sprintf(num_vehcile, "%d", v_num);
	int size_1=strlen(num_vehcile);
	for (int i=0;i<=size_1-1;i++)	{
		name_instance[size]=num_vehcile[i];size++;
	}
	name_instance[size]='_';size++;
	char seed_name[10];
	sprintf(seed_name, "%d", seed);
	size_1=strlen( seed_name);
	for (int i=0;i<=size_1-1;i++)	{
		name_instance[size]=seed_name[i];size++;
	}
	char tx[4]={'.','t','x','t'};
	for (int i=0;i<=3;i++){
		name_instance[size]=tx[i];size++;
	}
	cout<<name_instance<<endl;
	ofstream out (name_instance);

	out<<"the best solution's fitness is "<<endl<<g_best_p->fitness<<endl;

	out<<"the time when getting the optimal solution is "<<endl<<optimal_time<<endl;

	//out<< "the time get the best solution is "<<endl<<optimal_time<<endl;
	out<<"the sequence of best solution is following"<<endl;
	for (int i=0;i<=v_num-1;i++){
		pointer=0;
		while (1){
			out<<pointer<<" ";
			pointer=g_best_p->sol[i][pointer];
			if (pointer==0)
				break;
		}
		out<<endl;
	}
	out<<endl;
		double cost=0;int p;double cost_tem;
		for (int i=0;i<=v_num-1;i++){
			p=0;cost_tem=0;
			while (1){
				cost_tem+=Distance[p][g_best_p->sol[i][p]];
				if (g_best_p->sol[i][p]==0)
					break;
				p=g_best_p->sol[i][p];
			}
			if (cost<cost_tem)
				cost=cost_tem;
		}
		out<<"the actuall costs is "<<cost<<endl;
	if (intra_opt==3){
		out<<"the using frequency of each operators in EAX is following"<<endl;
		double sum=0;
		for (i=0;i<=length_s-1;i++)
			for (j=0;j<=length_s-1;j++)
				sum+=use_frequency[i][j];
		double sum_line1=0;
		for (i=0;i<=length_s-1;i++)
			sum_line1+=use_frequency[0][i];
		out<<"the percentage of or-insert is "<< sum_line1/sum<<endl;
		out<<"the percentage of or-swap is "<< 1-sum_line1/sum<<endl;
		out<<"all percentage of each operator is following "<<endl;
		for (i=0;i<=length_s-1;i++){
			for (j=0;j<=length_s-1;j++)
				out<< double(use_frequency[i][j])/sum <<"  ";
			out<<endl;
		}
	}
	out<<endl<<endl;
}



The file read_data.h contains:
/*
 * readdata.h
 *
 *  Created on: 17 Apr 2020
 *      Author: Peng
 */

#ifndef READ_DATA_H_
#define READ_DATA_H_
#include "Individual.h"
#include <time.h>
#include "basic.h"
class read_data {
public:
	read_data();
	virtual ~read_data();
	void define();
	void read_fun(char* file_name,int number_node);
	void output_fun(Individual *g_best_p ,int seed);// this function is employed to output the optimal results.
	int num_v;
	int v_num;
	int determing_longest;
	double ** Distance;// distance between all cities
	int ** near_ns;// the nearest nodes of each node.
	double *x;
	double *y;
	int ** use_frequency;// this variable is used to record the using frequency of each operators in cross_exchange;
	clock_t start;// start computing time
	int graph_type;
	int optimal_time;// this variable is used to record the time when getting the best solution.
	// for spanning tree
	int **edge;
	int alpha=alpha_num;
	// parameters
private:
	int i;
	int j;
	int k;
	string instance_n;
	int ** near;
	/////////////////////////////////////////////////////////////////////////
	// define node structure
	int *check_city;
	struct node{
		int father;
		int *son;
		int order;
		int num_son;
	};
	node * city;
	double *low_cost;
	double **beta;
	int **record;
	void spanning_tree();
	void visit_tree(int root);
	void alpha_sparse_graph();
	void visit_tree_beta(int root);
	void post_travel_tree(int root);
	double get_max(double a,double b);
	void Qsort(int i,int low, int high);
	int key;
};

#endif /* READ_DATA_H_ */

The file solution.cpp contains:
/*
 * solution.cpp
 *
 *  Created on: 17 Apr 2020
 *      Author: Peng
 */
#include "basic.h"
#include "solution.h"
#include "initialsol.h"
#include "LS.h"
#include "EAX.h"
#include "environment.h"
#include "perturb.h"
solution::solution() {
	sol_data=new read_data();// initilization all starting date
}
solution::~solution(){
	delete sol_data;
	delete Init_sol;
	delete curr;
	delete best_s;
	delete global_s;
	delete ls;
	delete gEnv;
	delete per;
}
void solution::define(char* file_name,int num_v,int time_l){
	sol_data->read_fun(file_name,num_v);
	Init_sol=new initial_sol ();// initial initial solution object;
	Init_sol->I_data=sol_data;// probe is assigned to direct to previous data
	curr=new Individual();
	curr->define(sol_data->num_v,sol_data->v_num);
	best_s=new Individual();
	best_s->define(sol_data->num_v,sol_data->v_num);
	global_s=new Individual();
	global_s->define(sol_data->num_v,sol_data->v_num);
//	Pop=new Individual[num_pop+lambda];
//	for (int i=0;i<=num_pop+lambda-1;i++)Pop[i].define(sol_data->num_v,sol_data->v_num);
	//Init_sol->s=off;// the probe direct the new off.
	ls=new LS(sol_data);// local search phase
	gEnv = new TEnvironment();
	per = new perturb();
	per->I_data=sol_data;
	per->define();
//	ls->s=off;
	ls->b_s=best_s;
	ls->I_data=sol_data;
	ls->gEnv=gEnv;
	ls->time_length=time_l;
	time_length=time_l;
	
}
void solution::initial_pop(){// construct the initial population
	for (int i=0;i<=num_inital-1;i++){
		if(ceil((clock() - sol_data->start)/static_cast<double>(CLOCKS_PER_SEC))>=time_length)
			break;
		curr->fitness=Max;
		Init_sol->s=curr;
		Init_sol->initilization();
		ls->s=curr;
		ls->local_search();
		cout<<i<<"  "<<ls->s->fitness<<endl;
		if (curr->fitness<global_s->fitness){
			sol_data->optimal_time=ceil((clock() - sol_data->start)/static_cast<double>(CLOCKS_PER_SEC));
			update_best_solution();
		}
	}
	for (int i=0;i<=sol_data->v_num-1;i++){
		for (int j=0;j<=sol_data->num_v;j++)
			curr->sol[i][j]=global_s->sol[i][j];
		curr->fit_tour[i]=global_s->fit_tour[i];
	}
	curr->fitness=global_s->fitness;
	cout<<(clock() - sol_data->start)/static_cast<double>(CLOCKS_PER_SEC)<<endl;
}
void solution::update_best_solution(){
	for (int i=0;i<=sol_data->v_num-1;i++){
		for (int j=0;j<=sol_data->num_v;j++)
			global_s->sol[i][j]=curr->sol[i][j];
		global_s->fit_tour[i]=curr->fit_tour[i];
	}
	global_s->fitness=curr->fitness;
}
void solution::main_loop(int seed){
	sol_data->determing_longest=0;
	int pointer;

	gEnv->Npop=100;						// number of items
	gEnv->Nch=30;						// number of offsprings
	gEnv->define(sol_data->num_v+1,sol_data->graph_type);//
	best_s->fitness=Max;
	global_s->fitness=Max;
	sol_data->start = clock();// start running time
	initial_pop();// define the initial solution
	for (int i=0;i<=sol_data->v_num-1;i++){
		for (int j=0;j<=sol_data->num_v;j++)
			best_s->sol[i][j]=curr->sol[i][j];
		best_s->fit_tour[i]=curr->fit_tour[i];
	}
	best_s->fitness=curr->fitness;
	step=0;int no_improve=0;
	while (1){
		if(ceil((clock() - sol_data->start)/static_cast<double>(CLOCKS_PER_SEC))>=time_length)
			break;
		ls->s=curr;
//		ls->local_search();
		ls->b_s=best_s;
		ls->weak_perturb();
		if (best_s->fitness<global_s->fitness){
			sol_data->optimal_time=ceil((clock() - sol_data->start)/static_cast<double>(CLOCKS_PER_SEC));
			for (int i=0;i<=sol_data->v_num-1;i++){
				for (int j=0;j<=sol_data->num_v;j++)
					global_s->sol[i][j]=best_s->sol[i][j];
				global_s->fit_tour[i]=best_s->fit_tour[i];
			}
			global_s->fitness=best_s->fitness;
			no_improve=0;
		}
		else no_improve++;
		cout<<step<<"    "<<best_s->fitness<<"    "<<curr->fitness<<"    "<<global_s->fitness<<endl;
		// enter disturbation phase
		cout<<"454542121"<<endl;
		if (sol_data->determing_longest==1)break;


//		per->s=curr;
//		per->no_improve=no_improve;
//		per->perturbation();

	//	for (int i=0;i<=sol_data->v_num-1;i++){
	//		for (int j=0;j<=sol_data->num_v;j++)
	//			best_s->sol[i][j]=curr->sol[i][j];
	//		best_s->fit_tour[i]=curr->fit_tour[i];
	//	}
	//	best_s->fitness=curr->fitness;

		
		step++;
	}
	sol_data->output_fun(global_s,seed);
}

The file solution.h contains:
/*
 * solution.h
 *
 *  Created on: 17 Apr 2020
 *      Author: Peng
 */

#ifndef SOLUTION_H_
#define SOLUTION_H_
#include"initialsol.h"
#include "read_data.h"
#include "Individual.h"
#include "LS.h"
#include "environment.h"
#include "perturb.h"
class solution {
public:
	solution();
	virtual ~solution();
	void define(char * file_name,int num_v,int time_length);
	void main_loop(int seed);
	read_data * sol_data;
	initial_sol * Init_sol;
	Individual * curr;
	Individual * best_s;
	Individual * global_s;
//	Individual * Pop;
	LS * ls;
	TEnvironment * gEnv;
	perturb * per;

private:
	void update_best_solution();
	void initial_pop();
	int num_ind;// is used to record the number of individuals in iterative process
	int step;
	int time_length;
};

#endif /* SOLUTION_H_ */




/* void solution::pop_diversity(int replace){// this function is used to calculate the
	if (replace==0){
		div_degree[step]=div_degree[step-1];
		return;
	}
	int pointer;int tem;
	double total_distance=0;double edge=0;
	for (int i=0;i<=num_pop-2;i++)
		for (int j=i+1;j<=num_pop-1;j++){
			for (int i=0;i<=sol_data->v_num-1;i++){
				pointer=Pop[j].sol[i][0];
				while (pointer!=0){
					s_t[pointer]=i;
					pointer=Pop[j].sol[i][pointer];
				}
			}
			for (int k=0;k<=sol_data->v_num-1;k++){
				pointer=0;
				while (1){// the edge with two endpoints: pointer, Pop[i].sol[k][pointer].
					tem=Pop[i].sol[k][pointer];
					if (tem>0){
						if (Pop[j].sol[s_t[tem]][tem]==pointer || Pop[j].sol_r[s_t[tem]][tem]==pointer)
							total_distance++;
						else
							edge++;
						pointer=Pop[i].sol[k][pointer];
					}
					if (tem==0){
						if (Pop[j].sol[s_t[pointer]][pointer]==tem || Pop[j].sol_r[s_t[pointer]][pointer]==tem)
							total_distance++;
						else
							edge++;
						break;
					}
				}
			}
		}
	total_distance=(total_distance*2)/(num_pop*(num_pop-1));
	edge=(edge*2)/(num_pop*(num_pop-1));
	div_degree[step]=edge;
} */

The file sort.cpp contains:
/*
 * sort.cpp
 *   created on: April 24, 2013
 * last updated: June 13, 2013
 *       author: liushujia
 */

#ifndef __Sort__
#include "sort.h"
#endif

TSort* tSort = NULL;

void InitSort(){
	tSort = new TSort();
}

void swap(int &x, int &y){
	int s=x;
	x=y;
	y=s;
}

void selectionSort(int* Arg, int l, int r){
	int id;
	for(int i=l;i<r;++i){
		id=i;
		for(int j=i+1;j<=r;++j)
			if(Arg[j]<Arg[id]) id=j;
		swap(Arg[i], Arg[id]);
	}
}

int partition(int* Arg, int l, int r){
	int id=l+rand()%(r-l+1);
	swap(Arg[l], Arg[id]);
	id=l;
	for(int i=l+1;i<=r;++i)
		if(Arg[i]<Arg[l]) swap(Arg[++id], Arg[i]);
	swap(Arg[l], Arg[id]);
	return id;
}

void quickSort(int* Arg, int l, int r){
	if(l<r){
		if(r-l<20){	// Ã¥Â°ï¿½Ã¨Â§â€žÃ¦Â¨Â¡Ã¦â€¢Â°Ã¦ï¿½Â®Ã§â€�Â¨Ã©â‚¬â€°Ã¦â€¹Â©Ã¦Å½â€™Ã¥Âºï¿½Ã©â‚¬Å¸Ã¥ÂºÂ¦Ã¦â€ºÂ´Ã¥Â¿Â«
			selectionSort(Arg, l, r);
			return ;
		}
		int mid=partition(Arg, l, r);
		quickSort(Arg, l, mid-1);
		quickSort(Arg, mid+1, r);
	}
}

TSort::TSort(){}
TSort::~TSort(){}

void TSort::index( double* Arg, int numOfArg, int* indexOrderd, int numOfOrd ){
	int indexBest = 0;
	double valueBest;
	int *checked = new int [ numOfArg ];
	for( int i = 0 ; i < numOfArg ; ++i ) checked[ i ] = 0;
	for( int i = 0; i < numOfOrd; ++i ){
		valueBest = 99999999999.9;
		for( int j = 0; j < numOfArg; ++j ){
			if( ( Arg[j] < valueBest ) && checked[j]==0){
				valueBest = Arg[j];
				indexBest = j;
			}
		}
		indexOrderd[ i ]=indexBest;
		checked[ indexBest ]=1;
	}
	delete [] checked;
}

void TSort::indexB( double* Arg, int numOfArg, int* indexOrderd, int numOfOrd ){
	int indexBest = 0;
	double valueBest;
	int *checked = new int [ numOfArg ];
	for( int i = 0 ; i < numOfArg ; ++i ) checked[ i ] = 0;
	for( int i = 0; i < numOfOrd; ++i ){
		valueBest = -99999999999.9;
		for( int j = 0; j < numOfArg; ++j ){
			if( ( Arg[j] > valueBest ) && checked[j]==0){
				valueBest = Arg[j];
				indexBest = j;
			}
		}
		indexOrderd[ i ]=indexBest;
		checked[ indexBest ]=1;
	}
	delete [] checked;
}

void TSort::index( int* Arg, int numOfArg, int* indexOrderd, int numOfOrd ){
	int indexBest = 0;
	int valueBest;
	int *checked = new int [ numOfArg ];
	for( int i = 0 ; i < numOfArg ; ++i ) checked[ i ] = 0;
	for( int i = 0; i < numOfOrd; ++i ){
		valueBest = 99999999;
		for( int j = 0; j < numOfArg; ++j ){
			if( ( Arg[j] < valueBest ) && checked[j]==0){
				valueBest = Arg[j];
				indexBest = j;
			}
		}
		indexOrderd[ i ]=indexBest;
		checked[ indexBest ]=1;
	}
	delete [] checked;
}

void TSort::indexB( int* Arg, int numOfArg, int* indexOrderd, int numOfOrd ){
	int indexBest = 0;
	int valueBest;
	int *checked = new int [ numOfArg ];
	for( int i = 0 ; i < numOfArg ; ++i ) checked[ i ] = 0;
	for( int i = 0; i < numOfOrd; ++i ){
		valueBest = -999999999;
		for( int j = 0; j < numOfArg; ++j ){
			if( ( Arg[j] > valueBest ) && checked[j]==0){
				valueBest = Arg[j];
				indexBest = j;
			}
		}
		indexOrderd[ i ]=indexBest;
		checked[ indexBest ]=1;
	}
	delete [] checked;
}

void TSort::sort( int* Arg, int numOfArg ){
	//selectionSort(Arg, 0, numOfArg-1);
	quickSort(Arg, 0, numOfArg-1);
}


The file sort.h contains:
/*
 * sort.h
 *   created on: April 24, 2013
 * last updated: June 13, 2013
 *       author: liushujia
 */

#ifndef __SORT__
#define __SORT__

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <assert.h>
#include <algorithm>
using namespace std;

void InitSort();
void swap(int &x, int &y);						// äº¤æ�¢ä¸¤ä¸ªæ•°
void selectionSort(int* Arg, int l, int r);		// é€‰æ‹©æŽ’åº�
int partition(int* Arg, int l, int r);			// å¿«é€ŸæŽ’åº�åˆ†è§£å­�ç¨‹åº�
void quickSort(int* Arg, int l, int r);			// å¿«é€ŸæŽ’åº�

class TSort{
public:
	TSort();
	~TSort();
	void index( double* Arg, int numOfArg, int* indexOrderd, int numOfOrd );
	void index( int* Arg, int numOfArg, int* indexOrderd, int numOfOrd );
	void indexB( double* Arg, int numOfArg, int* indexOrderd, int numOfOrd );
	void indexB( int* Arg, int numOfArg, int* indexOrderd, int numOfOrd );
	void sort( int* Arg, int numOfArg );
};

extern TSort* tSort;

#endif

The file Tstwoopt.cpp contains:
/*
 * Tstwoopt.cpp
 *
 *  Created on: 19 Apr 2020
 *      Author: Peng
 */

#include "Tstwoopt.h"
#include "basic.h"
#include "read_data.h"
using namespace std;
Tstwoopt::Tstwoopt(read_data * data) {
	tabu=new int *[data->num_v+1];
	for (int i=0;i<=data->num_v;i++)
		tabu[i]=new int [data->num_v+1];
	num_v=data->num_v;
}
Tstwoopt::~Tstwoopt() {
	for (int i=0;i<=num_v;i++)
		delete [] tabu[i];
	delete [] tabu;
}
double Tstwoopt::calculat_delta(int u1,int v1,int u2,int v2){
	return(I_data->Distance[u1][u2]+I_data->Distance[v1][v2]-I_data->Distance[u1][v1]-I_data->Distance[u2][v2]);
}

void Tstwoopt::reverse(int * s, int reverse_1,int reverse_2,int n_v){
	int temp;
	while (reverse_2 - reverse_1>0){
		temp=s[reverse_1%n_v];
		s[reverse_1%n_v]=s[reverse_2%n_v];
		s[reverse_2%n_v]=temp;
		reverse_1++;
		reverse_2--;
	}
}
void Tstwoopt::twoopt(int *s, int n_v){// the n is the number of cities in route s.
	int best_s[n_v];
	for (int i=0;i<=n_v-1;i++)
		best_s[i]=s[i];
	int reverse_1,reverse_2;
	double delta_1;
	int v1,v2,u1,u2;
	double min_delta;
	while (1){
		min_delta=Max;min_delta--;
		for (int i=0;i<=n_v-1;i++){
			u1=i;
			v1=(i+1)%n_v;
			for (int j=i+2;(j+1)%n_v!=i;j++){
				u2=j%n_v;
				v2=(j+1)%n_v;
				delta_1=calculat_delta(s[u1],s[v1],s[u2],s[v2]);
				if (min_delta>delta_1){
					min_delta=delta_1;
					reverse_1=i+1;
					reverse_2=j;
				}
			}
		}
		if (min_delta<-1.0e-7)
			reverse(s, reverse_1,reverse_2,n_v);
		else
			break;
	}
	int k;
	for (int i=0;i<=n_v-1;i++)
		best_s[i]=s[i];
	for (int i=0;i<=n_v-1;i++)
		if (best_s[i]==0){
			k=i;break;
			}
	s[0]=0;int c=1;
	for (int j=k+1;best_s[j%n_v]!=0;j++){
		s[c]=best_s[j%n_v];c++;
	}
}
double Tstwoopt::calculate_length_tour(int *s, int n_v){
	double path_length=0;
	for (int i=0;i<=n_v-2;i++)
		path_length+=I_data->Distance[s[i]][s[i+1]];
	path_length+=I_data->Distance[s[n_v-1]][s[0]];
	return path_length;
}
void Tstwoopt::tabu_search(int * s, int n_v)// this code employs 2-opt and tabu search to optimize a traditional TSP
{
	a=0;
	for (int i=0;i<=n_v-1;i++)
		if (s[i]>a)
			a=s[i];
	a++;
	for (int i=0;i<=a-1;i++)
		for (int j=0;j<=a-1;j++)
			tabu[i][j]=0;
//	double delta[num_v][num_v];// it should be noticed becasue the delta value is caltulated by exchanging edges, not nodes
	// in the first step a simple 2-opt algorithm should be employed.
	int best_s[n_v];
	for (int i=0;i<=n_v-1;i++)
		best_s[i]=s[i];
	double path_length=0;
	path_length=calculate_length_tour(s,n_v);
	double best_path=path_length;
	int reverse_1,reverse_2;
	double min_delta,min_tabu_delta;
	int num_best,num_tabu_best;
	double delta_1;
	int step=0;int v1,v2,u1,u2;
	int no_improve=0;
	int tabu_length=ceil (n_v*0.1);
	while (1){
		step++;
		min_delta=Max;min_tabu_delta=Max;num_best=0;num_tabu_best=0;min_delta--;min_tabu_delta--;
		for (int i=0;i<=n_v-1;i++)	{
			u1=i;
			v1=(i+1)%n_v;
			for (int j=i+2;(j+1)%n_v!=i;j++){
				u2=j%n_v;
				v2=(j+1)%n_v;
				delta_1=calculat_delta(s[u1],s[v1],s[u2],s[v2]);
				if (tabu[s[u1]][s[v1]]<=step && tabu[s[u2]][s[v2]]<=step)	{
					if (delta_1<min_delta){
						min_delta=delta_1;
						can_node_1[0]=i+1;
						can_node_2[0]=j;
						num_best=1;
					}
					else if (min_delta==delta_1 && num_best<100){
						can_node_1[num_best]=i+1;
						can_node_2[num_best]=j;
						num_best++;
					}
				}
				else if (tabu[s[u1]][s[v1]]>step || tabu[s[u2]][s[v2]]>step)	{
					if (min_tabu_delta>delta_1)	{
						min_tabu_delta=delta_1;
						can_tabu_node_1[0]=i+1;
						can_tabu_node_2[0]=j;
						num_tabu_best=1;
					}
					else if (min_tabu_delta==delta_1 && num_tabu_best<100)	{
						can_tabu_node_1[num_tabu_best]=i+1;
						can_tabu_node_2[num_tabu_best]=j;
						num_tabu_best++;
					}
				}
			}
		}
		int rand_order;
		if ((num_tabu_best>0 && min_tabu_delta+1.0e-7<min_delta && (path_length + min_tabu_delta+1.0e-7< best_path)) || num_best==0){
			path_length+=min_tabu_delta;
			rand_order=rand()% num_tabu_best;
			reverse_1=can_tabu_node_1[rand_order];
			reverse_2=can_tabu_node_2[rand_order];
			tabu[s[(reverse_1-1)%n_v]][s[reverse_2%n_v]]=step+tabu_length+rand()%tabu_length;
			tabu[s[(reverse_2+1)%n_v]][s[reverse_1%n_v]]=step+tabu_length+rand()%tabu_length;
			reverse(s, reverse_1,reverse_2,n_v);
		}
		else{
			path_length+=min_delta;
			rand_order=rand()%num_best;
			reverse_1=can_node_1[rand_order];
			reverse_2=can_node_2[rand_order];
			tabu[s[(reverse_1-1)%n_v]][s[reverse_2%n_v]]=step+tabu_length+rand()%tabu_length;
			tabu[s[(reverse_2+1)%n_v]][s[reverse_1%n_v]]=step+tabu_length+rand()%tabu_length;
			reverse(s,reverse_1,reverse_2,n_v);
		}
		if (best_path>path_length)	{
			best_path=path_length;
			for (int i=0;i<=n_v-1;i++)
				best_s[i]=s[i];
			no_improve=0;
		}
		else
			no_improve++;
		if (n_v<10){
			if (no_improve>=5)//10
				break;
			if (step>50)
				break;
		}
		else{
			if (no_improve>(n_v))//10   an important parameters
			break;
			if (step>n_v*5*10)
				break;
		}
	}
	int k;
	for (int i=0;i<=n_v-1;i++)
		if (best_s[i]==0)
		{	k=i;break;}
	s[0]=0;int c=1;
	for (int j=k+1;best_s[j%n_v]!=0;j++){
		s[c]=best_s[j%n_v];c++;
	}
}

The file Tstwoopt.h contains:
/*
 * Tstwoopt.h
 *
 *  Created on: 19 Apr 2020
 *      Author: Peng
 */

#ifndef TSTWOOPT_H_
#define TSTWOOPT_H_
#include "read_data.h"
class Tstwoopt {
public:
	Tstwoopt(read_data * data);
	virtual ~Tstwoopt();
	void twoopt(int *s, int n);
	void tabu_search(int *s, int n_v);
	read_data * I_data;

private:
	double calculate_length_tour(int* s,int n_v);
	double calculat_delta(int u1,int v1,int u2,int v2);
	void reverse(int * s, int reverse_1,int reverse_2,int n_v);
	int can_node_1[100];
	int can_node_2[100];
	int can_tabu_node_1[100];
	int can_tabu_node_2[100];
	int ** tabu;
	int num_v;
	int a;
};

#endif /* TSTWOOPT_H_ */

