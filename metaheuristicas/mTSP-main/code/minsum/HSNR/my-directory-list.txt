The file basic.h contains:
/*
 * basic.h
 *
 *  Created on: 18 Apr 2020
 *      Author: Peng
 */

#ifndef BASIC_H_
#define BASIC_H_
#include<algorithm>
#include <vector>
#include<math.h>
#include <iostream>
#include <time.h>
#include <string.h>
#include <fstream>
using namespace std;
///////////////////////////////////////////////////////////////////////////////

#define Max 100000000

#define num_initial 15
#define num_near_nodes 30
#define length_s 4 // the length of each string, the actual value is length_s-1
#define tabu_l  60
#define threshold 10
#define alpha_num 20







#define perturbation_num 80


//#define control_para 300

//#define Probability 400


#define cross_exchange_identify 2

// the parameters to select operators for intra-route and inter-route optimization in local search
#define intra_opt 3                // the number 1, 2 and 3    are 2-opt, tabu search and EAX, respectively
#define inter_opt 3          // the number 1, 2 and 3 are insert operators, solution based tabu search and cross-exchange
#define perturbation_method 1
////////////////////////////////////////////////////////////////

#endif /* BASIC_H_ */

The file cross.cpp contains:
/*
 * cross.cpp
 *   created on: April 24, 2013
 * last updated: June 13, 2013
 *       author: liushujia
 */

#ifndef __Cross__
#include "cross.h"
#endif

TCross::TCross( int N ){
	fMaxNumOfABcycle = 2000;	// 设置适当的值(2000)
	total_fN = N+100;
//	tBestTmp.define( total_fN );
	nearData = new int* [ total_fN ];
	for ( int j = 0; j < total_fN; ++j ) nearData[j] = new int [ 5 ];

	fABcycle = new int* [ fMaxNumOfABcycle ];
	for ( int j = 0; j < fMaxNumOfABcycle; ++j ) fABcycle[j] = new int [ 2*total_fN + 4 ];

	koritsu = new int [ total_fN ];
	bunki = new int [ total_fN ];
	koriInv = new int [ total_fN ];
	bunInv = new int [ total_fN ];
	checkKoritsu = new int [ total_fN ];
	fRoute = new int [ 2*total_fN + 1 ];
	fPermu = new int [ fMaxNumOfABcycle ];

	fC = new int [ 2*total_fN+4 ];
	fJun = new int[ total_fN+ 1 ];
	fOrd1 = new int [ total_fN ];
	fOrd2 = new int [ total_fN ];

	// Speed Up Start
	fOrder = new int [ total_fN ];
	fInv = new int [ total_fN ];
	fSegment = new int* [ total_fN ];
	for ( int j = 0; j < total_fN; ++j ) fSegment[ j ] = new int [ 2 ];

	fSegUnit = new int [ total_fN ];
	fSegPosiList = new int[ total_fN ];
	LinkAPosi = new int [ total_fN ];
	LinkBPosi = new int* [ total_fN ];
	for ( int j = 0; j < total_fN; ++j ) LinkBPosi[ j ] = new int [ 2 ];

	fPosiSeg = new int [ total_fN ];
	fNumOfElementInUnit = new int [ total_fN ];
	fCenterUnit = new int [ total_fN ];
	for ( int j = 0; j < total_fN; ++j ) fCenterUnit[ j ] = 0;

	fListOfCenterUnit = new int [ total_fN+2 ];
	fSegForCenter = new int [ total_fN ];
	fGainAB = new double [ total_fN ];
	//fGainAB = new int [ fN ];
	fModiEdge = new int* [ total_fN ];
	for ( int j = 0; j < total_fN; ++j ) fModiEdge[ j ] = new int [ 4 ];

	fBestModiEdge = new int* [ total_fN ];
	for ( int j = 0; j < total_fN; ++j ) fBestModiEdge[ j ] = new int [ 4 ];

	fAppliedCylce = new int [ total_fN ];
	fBestAppliedCylce = new int [ total_fN ];
	// Speed Up End

	// Block2
	fNumOfElementINAB = new int [ fMaxNumOfABcycle ];
	fInEffectNode = new int* [ total_fN ];
	for( int i = 0; i < total_fN; ++i ) fInEffectNode[ i ] = new int [ 2 ];

	fWeightRR = new int* [ fMaxNumOfABcycle ];
	for( int i = 0; i < fMaxNumOfABcycle; ++i ) fWeightRR[ i ] = new int [ fMaxNumOfABcycle ];

	fWeightSR = new int [ fMaxNumOfABcycle ];
	fWeightC = new int [ fMaxNumOfABcycle ];
	fUsedAB = new int [ total_fN ];
	fMovedAB = new int [ total_fN ];
	fABcycleInEset = new int [ fMaxNumOfABcycle ];
}

TCross::~TCross()
{
	delete [] koritsu;
	delete [] bunki;
	delete [] koriInv;
	delete [] bunInv;
	delete [] checkKoritsu;
	delete [] fRoute;
	delete [] fPermu;
	for ( int j = 0; j < total_fN; ++j ) delete[] nearData[ j ];

	delete[] nearData;
	for ( int j = 0; j < fMaxNumOfABcycle; ++j ) delete[] fABcycle[ j ];

	delete[] fABcycle;
	delete [] fC;
	delete [] fJun;
	delete [] fOrd1;
	delete [] fOrd2;

	// Speed Up Start
	delete [] fOrder;
	delete [] fInv;

	for ( int j = 0; j < total_fN; ++j ) delete[] fSegment[ j ];

	delete[] fSegment;
	delete[] fSegUnit;
	delete [] fSegPosiList;
	delete [] LinkAPosi;
	for ( int j = 0; j < total_fN; ++j ) delete[] LinkBPosi[ j ];

	delete [] LinkBPosi;
	delete [] fPosiSeg;
	delete [] fNumOfElementInUnit;
	delete [] fCenterUnit;
	delete [] fListOfCenterUnit;
	delete [] fSegForCenter;
	delete [] fGainAB;

	for ( int j = 0; j < total_fN; ++j ) delete[] fModiEdge[ j ];
	delete [] fModiEdge;
	for ( int j = 0; j < total_fN; ++j ) delete[] fBestModiEdge[ j ];
	delete [] fBestModiEdge;

	delete [] fAppliedCylce;
	delete [] fBestAppliedCylce;
	// Speed Up End

	// Block2
	delete [] fNumOfElementINAB;
	for ( int j = 0; j < total_fN; ++j ) delete [] fInEffectNode[ j ];

	delete [] fInEffectNode;
	for( int i = 0; i < fMaxNumOfABcycle; ++i ) delete [] fWeightRR[ i ];
	delete [] fWeightRR;
	
	delete [] fWeightSR;
	delete [] fWeightC;
	delete [] fUsedAB;
	delete [] fMovedAB;
	delete [] fABcycleInEset;
//	delete eval;
}

void TCross::input_data(int N)
{
	fN=N;
}
void TCross::setParents( const TIndi& tPa1, const TIndi& tPa2, int flagC[ 10 ], int numOfKids ){
	this->setABcycle( tPa1, tPa2, flagC, numOfKids );
	fDisAB = 0;
	int curr, next, st, pre;
	st = 0;
	curr=-1;
	next = st;
	for( int i = 0; i < fN; ++i ){
		pre=curr;
		curr=next;
		if( tPa1.fLink[curr][0] != pre ) next = tPa1.fLink[ curr ][ 0 ];
		else next=tPa1.fLink[curr][1];

		if( tPa2.fLink[ curr ][ 0 ] != next && tPa2.fLink[ curr ][ 1 ] != next ) ++fDisAB;
		fOrder[ i ] = curr;
		fInv[ curr ] = i;
	}
	if( flagC[ 1 ] == 2 ){
		fTmax = 10;
		fMaxStag = 20;                 //1:Greedy LS, 20:Tabu Search
		this->setWeight( tPa1, tPa2 );
	}
}

void TCross::doIt( TIndi& tKid, TIndi& tPa2, int numOfKids, int flagP, int flagC[ 10 ], int **fEdgeFreq ){
	int Num;
	int jnum, centerAB;
	//int gain;
	double gain;
	//int BestGain;
	double BestGain;
	double pointMax, point;
	double DLoss;

	fEvalType = flagC[ 0 ];              //1:Greedy, 2:---, 3:Distance, 4:Entropy
	fEsetType = flagC[ 1 ];              //1:Single-AB, 2:Block2

	if ( numOfKids <= fNumOfABcycle ) Num = numOfKids;
	else Num = fNumOfABcycle;

	if( fEsetType == 1 )		// Single-AB
	tRand->permutation( fPermu, fNumOfABcycle, fNumOfABcycle );

	else if( fEsetType == 2 ){  // Block2
		for( int k =0; k< fNumOfABcycle; ++k ) fNumOfElementINAB[ k ] = fABcycle[ k ][ 0 ];
		tSort->indexB( fNumOfElementINAB, fNumOfABcycle, fPermu, fNumOfABcycle );
	}
	fNumOfGeneratedCh = 0;
	pointMax = 0.0;
	BestGain = 0.0;
	fFlagImp = 0;
	for( int j =0; j < Num; ++j ){
		fNumOfABcycleInEset = 0;
		if( fEsetType == 1 ){         //Single-AB
			jnum = fPermu[ j ];
			fABcycleInEset[ fNumOfABcycleInEset++ ] = jnum;
		}
		else if( fEsetType == 2 ){    //Block2
			jnum = fPermu[ j ];
			centerAB = jnum;
			for( int s = 0; s < fNumOfABcycle; ++s ){
				if( s == centerAB ) fABcycleInEset[ fNumOfABcycleInEset++ ] = s;
				else{
					if( fWeightRR[ centerAB ][ s ] > 0 && fABcycle[ s ][ 0 ] < fABcycle[ centerAB ][ 0 ] )
					if( rand() %2 == 0 ) fABcycleInEset[ fNumOfABcycleInEset++ ] = s;
				}
			}
		this->searchEset( centerAB );
		}
		fNumOfSPL = 0;
		gain = 0.0;
		fNumOfAppliedCycle = 0;
		fNumOfModiEdge = 0;

		fNumOfAppliedCycle = fNumOfABcycleInEset;
		for( int k = 0; k < fNumOfAppliedCycle; ++k ){
			fAppliedCylce[ k ] = fABcycleInEset[ k ];
			jnum = fAppliedCylce[ k ];
			this->changeSol( tKid, jnum, flagP );
			gain += fGainAB[ jnum ];
		}

		this->makeUnit();
		this->makeCompleteSol( tKid );
		gain += fGainModi;

		++fNumOfGeneratedCh;

		if( fEvalType == 1 ) DLoss = 1.0;									//Greedy
		else if( fEvalType == 3 ) DLoss = this->calAdpLoss( fEdgeFreq );	// Distance preservation
		else if( fEvalType == 4 ) DLoss = this->calEntLoss( fEdgeFreq );	// Entropy preservation

		if( DLoss <= 0.0 ) DLoss = 0.00000001;

		point = (double)gain / DLoss;
		tKid.fEvaluationValue = tKid.fEvaluationValue - gain;

		if( pointMax < point && (2 * fBestNumE < fDisAB || tKid.fEvaluationValue != tPa2.fEvaluationValue ) ){
			pointMax = point;
			BestGain = gain;
			fFlagImp = 1;

			fNumOfBestAppliedCycle = fNumOfAppliedCycle;
			for( int s = 0; s < fNumOfBestAppliedCycle; ++s ) fBestAppliedCylce[ s ] = fAppliedCylce[ s ];

			fNumOfBestModiEdge = fNumOfModiEdge;
			for( int s = 0; s < fNumOfBestModiEdge; ++s ){
				fBestModiEdge[ s ][ 0 ] = fModiEdge[ s ][ 0 ];
				fBestModiEdge[ s ][ 1 ] = fModiEdge[ s ][ 1 ];
				fBestModiEdge[ s ][ 2 ] = fModiEdge[ s ][ 2 ];
				fBestModiEdge[ s ][ 3 ] = fModiEdge[ s ][ 3 ];
			}

		}
		this->backToPa1( tKid );
		tKid.fEvaluationValue = tKid.fEvaluationValue + gain;
	}
	if( fFlagImp == 1 ){
		this->goToBest( tKid );
		tKid.fEvaluationValue = tKid.fEvaluationValue - BestGain;
		this->incrementEdgeFreq( fEdgeFreq );
	}
}

void TCross::setABcycle( const TIndi& tPa1, const TIndi& tPa2, int flagC[ 10 ], int numOfKids ){
	bunkiMany=0; koritsuMany=0;
	for( int j = 0; j < fN ; ++j ){
		nearData[j][1]=tPa1.fLink[j][0];
		nearData[j][3]=tPa1.fLink[j][1];
		nearData[j][0] = 2;

		koritsu[koritsuMany]=j;
		koritsuMany++;

		nearData[j][2]=tPa2.fLink[j][0];
		nearData[j][4]=tPa2.fLink[j][1];
	}
	for(int j = 0; j < fN; ++j ){
		checkKoritsu[j]=-1;
		koriInv[koritsu[j]]=j;
	}
	fNumOfABcycle=0;
	flagSt=1;
	while(koritsuMany!=0){
		if(flagSt==1){
			fPosiCurr=0;
			r=rand()%koritsuMany;
			st=koritsu[r];
			checkKoritsu[st]=fPosiCurr;
			fRoute[fPosiCurr]=st;
			ci=st;
			prType=2;
		}
		else if(flagSt==0) ci=fRoute[fPosiCurr];

		flagCycle=0;
		while(flagCycle==0){
			fPosiCurr++;
			pr=ci;
			switch(prType){
			case 1:
				ci=nearData[pr][fPosiCurr%2+1];
			break;
			case 2:
				r=rand()%2;
				ci=nearData[pr][fPosiCurr%2+1+2*r];
				if(r==0) this->swap(nearData[pr][fPosiCurr%2+1],nearData[pr][fPosiCurr%2+3]);
			break;
			case 3:
				ci=nearData[pr][fPosiCurr%2+3];
			}
			fRoute[fPosiCurr]=ci;
			if(nearData[ci][0]==2){
				if(ci==st){
					if(checkKoritsu[st]==0){
					if((fPosiCurr-checkKoritsu[st])%2==0){
						if(nearData[st][fPosiCurr%2+1]==pr) this->swap(nearData[ci][fPosiCurr%2+1],nearData[ci][fPosiCurr%2+3]);

						stAppear = 1;
						this->formABcycle();
						if( flagC[ 1 ] == 1 && fNumOfABcycle == numOfKids ) goto RETURN;
						if( fNumOfABcycle == fMaxNumOfABcycle ) goto RETURN;

						flagSt=0;
						flagCycle=1;
						prType=1;
					}
					else{
						this->swap(nearData[ci][fPosiCurr%2+1],nearData[ci][fPosiCurr%2+3]);
						prType=2;
					}
					checkKoritsu[st]=fPosiCurr;
					}
					else{
					stAppear = 2;
					this->formABcycle();
					if( flagC[ 1 ] == 1 && fNumOfABcycle == numOfKids ) goto RETURN;
					if( fNumOfABcycle == fMaxNumOfABcycle ) goto RETURN;

					flagSt=1;
					flagCycle=1;
					}
				}
				else if(checkKoritsu[ci]==-1) {
					checkKoritsu[ci]=fPosiCurr;
					if(nearData[ci][fPosiCurr%2+1]==pr) this->swap(nearData[ci][fPosiCurr%2+1],nearData[ci][fPosiCurr%2+3]);
					prType=2;
				}
				else if(checkKoritsu[ci]>0){
					this->swap(nearData[ci][fPosiCurr%2+1],nearData[ci][fPosiCurr%2+3]);
					if((fPosiCurr-checkKoritsu[ci])%2==0){
						stAppear = 1;
						this->formABcycle();
						if( flagC[ 1 ] == 1 && fNumOfABcycle == numOfKids ) goto RETURN;
						if( fNumOfABcycle == fMaxNumOfABcycle ) goto RETURN;

						flagSt=0;
						flagCycle=1;
						prType=1;
					}
					else{
						this->swap(nearData[ci][(fPosiCurr+1)%2+1],nearData[ci][(fPosiCurr+1)%2+3]);
						prType=3;
					}
				}
			}
			else if(nearData[ci][0]==1){
				if(ci==st){
					stAppear = 1;
					this->formABcycle();
					if( flagC[ 1 ] == 1 && fNumOfABcycle == numOfKids ) goto RETURN;
					if( fNumOfABcycle == fMaxNumOfABcycle ) goto RETURN;
					flagSt=1;
					flagCycle=1;
				}
				else prType=1;
			}
		}
	}
	while(bunkiMany!=0){
		fPosiCurr=0;
		r=rand()%bunkiMany;
		st=bunki[r];
		fRoute[fPosiCurr]=st;
		ci=st;

		flagCycle=0;
		while(flagCycle==0){
			pr=ci;
			fPosiCurr++;
			ci=nearData[pr][fPosiCurr%2+1];
			fRoute[fPosiCurr]=ci;
			if(ci==st){
				stAppear = 1;
				this->formABcycle();
				if( flagC[ 1 ] == 1 && fNumOfABcycle == numOfKids ) goto RETURN;
				if( fNumOfABcycle == fMaxNumOfABcycle ) goto RETURN;

				flagCycle=1;
			}
		}
	}
RETURN:
	if( fNumOfABcycle == fMaxNumOfABcycle ){
		printf( "fMaxNumOfABcycle(%d) must be increased\n", fMaxNumOfABcycle );
		exit( 1 );
	}
}

void TCross::formABcycle(){
	int j;
	int st_count;
	int edge_type;
	int st,ci, stock;
	int cem;
	double diff;
	//int diff;

	if(fPosiCurr%2==0) edge_type=1;
	else edge_type=2;
	st=fRoute[fPosiCurr];
	cem=0;
	fC[cem]=st;

	st_count=0;
	while(1){
		cem++;
		fPosiCurr--;
		ci=fRoute[fPosiCurr];
		if(nearData[ci][0]==2){
			koritsu[koriInv[ci]]=koritsu[koritsuMany-1];
			koriInv[koritsu[koritsuMany-1]]=koriInv[ci];
			koritsuMany--;
			bunki[bunkiMany]=ci;
			bunInv[ci]=bunkiMany;
			bunkiMany++;
		}
		else if(nearData[ci][0]==1){
			bunki[bunInv[ci]]=bunki[bunkiMany-1];
			bunInv[bunki[bunkiMany-1]]=bunInv[ci];
			bunkiMany--;
		}

		nearData[ci][0]--;
		if(ci==st) st_count++;
		if(st_count==stAppear) break;
		fC[cem]=ci;
	}

	if(cem==2) return;

	fABcycle[fNumOfABcycle][0]=cem;

	if(edge_type==2){
		stock=fC[0];
		for( int j=0;j<cem-1;j++) fC[j]=fC[j+1];
		fC[cem-1]=stock;
	}

	for( int j=0;j<cem;j++) fABcycle[fNumOfABcycle][j+2]=fC[j];

	fABcycle[fNumOfABcycle][1]=fC[cem-1];
	fABcycle[fNumOfABcycle][cem+2]=fC[0];
	fABcycle[fNumOfABcycle][cem+3]=fC[1];

	fC[ cem ] = fC[ 0 ];
	fC[ cem+1 ] = fC[ 1 ];
	diff = 0.0;
	for( j = 0; j < cem/2; ++j ) diff = diff + eval->fEdgeDis[fC[2*j]][fC[1+2*j]] - eval->fEdgeDis[fC[1+2*j]][fC[2+2*j]];

	fGainAB[fNumOfABcycle] = diff;
	++fNumOfABcycle;
}

void TCross::swap(int &x, int &y){
	int s=x;
	x=y;
	y=s;
}

void TCross::changeSol( TIndi& tKid, int ABnum, int type ){
	int j;
	int cem, r1, r2, b1, b2;
	int po_r1, po_r2, po_b1, po_b2;

	cem=fABcycle[ABnum][0];
	fC[0]=fABcycle[ABnum][0];

	if(type==2) for(j=0;j<cem+3;j++) fC[cem+3-j]=fABcycle[ABnum][j+1];
	else for(j=1;j<=cem+3;j++) fC[j]=fABcycle[ABnum][j];

	for(j=0;j<cem/2;j++){
		r1=fC[2+2*j];r2=fC[3+2*j];
		b1=fC[1+2*j];b2=fC[4+2*j];

		if(tKid.fLink[r1][0]==r2) tKid.fLink[r1][0]=b1;
		else tKid.fLink[r1][1]=b1;
		if(tKid.fLink[r2][0]==r1) tKid.fLink[r2][0]=b2;
		else tKid.fLink[r2][1]=b2;

		po_r1 = fInv[ r1 ];
		po_r2 = fInv[ r2 ];
		po_b1 = fInv[ b1 ];
		po_b2 = fInv[ b2 ];

		if( po_r1 == 0 && po_r2 == fN-1 ) fSegPosiList[ fNumOfSPL++ ] = po_r1;
		else if( po_r1 == fN-1 && po_r2 == 0 ) fSegPosiList[ fNumOfSPL++ ] = po_r2;
		else if( po_r1 < po_r2 ) fSegPosiList[ fNumOfSPL++ ] = po_r2;
		else if( po_r2 < po_r1 ) fSegPosiList[ fNumOfSPL++ ] = po_r1;

		LinkBPosi[ po_r1 ][ 1 ] = LinkBPosi[ po_r1 ][ 0 ];
		LinkBPosi[ po_r2 ][ 1 ] = LinkBPosi[ po_r2 ][ 0 ];
		LinkBPosi[ po_r1 ][ 0 ] = po_b1;
		LinkBPosi[ po_r2 ][ 0 ] = po_b2;
	}
}

void TCross::makeCompleteSol( TIndi& tKid ){
	int j, j1, j2;
	int st ,pre, curr, next, a, b, c, d, aa, bb, a1, b1;
	int min_unit_city;
	int center_un, select_un;
	double diff, max_diff;
	//int diff, max_diff;
	int near_num, nearMax;

	fGainModi = 0;
	while( fNumOfUnit != 1 ){
		min_unit_city = fN + 12345;
		for( int u = 0; u < fNumOfUnit; ++u )
			if( fNumOfElementInUnit[ u ] < min_unit_city ){
				center_un = u;
				min_unit_city = fNumOfElementInUnit[ u ];
			}


		st = -1;
		fNumOfSegForCenter = 0;
		for( int s = 0; s < fNumOfSeg; ++s )
			if( fSegUnit[ s ] == center_un ){
				int posi = fSegment[ s ][ 0 ];
				st = fOrder[ posi ];
				fSegForCenter[  fNumOfSegForCenter++ ] = s;
			}
		curr = -1;
		next = st;
		fNumOfElementInCU = 0;
		while(1){
			pre = curr;
			curr = next;
			fCenterUnit[ curr ] = 1;
			fListOfCenterUnit[ fNumOfElementInCU ] = curr;
			++fNumOfElementInCU;
			if( tKid.fLink[ curr ][ 0 ] != pre ) next = tKid.fLink[ curr ][ 0 ];
			else next = tKid.fLink[ curr ][ 1 ];
			if( next == st ) break;
		}
		fListOfCenterUnit[ fNumOfElementInCU ] = fListOfCenterUnit[ 0 ];
		fListOfCenterUnit[ fNumOfElementInCU+1 ] = fListOfCenterUnit[ 1 ];

		max_diff = -999999999;
		a1 = -1; b1 = -1;
		nearMax = 10;	// N_near
						// nearMax <= eva->fNearNumMax (kopt.cpp)

	RESTART:
		for( int s = 1; s <= fNumOfElementInCU; ++s ){
			a = fListOfCenterUnit[ s ];

			for( near_num = 1; near_num <= nearMax; ++near_num ){
				c = eval->fNearCity[ a ][ near_num ];
				if( fCenterUnit[ c ] == 0 ){
					for( j1 = 0; j1 < 2; ++j1 ){
						b = fListOfCenterUnit[ s-1+2*j1 ];
						for( j2 = 0; j2 < 2; ++j2 ){
							d = tKid.fLink[ c ][ j2 ];
							diff = eval->fEdgeDis[a][b] + eval->fEdgeDis[c][d] - eval->fEdgeDis[a][c] - eval->fEdgeDis[b][d];
							if( diff > max_diff ){
								aa = a; bb = b; a1 = c; b1 = d;
								max_diff = diff;
							}
							diff = eval->fEdgeDis[a][b] + eval->fEdgeDis[d][c] -
								eval->fEdgeDis[a][d] - eval->fEdgeDis[b][c];
							if( diff > max_diff ){
								aa = a; bb = b; a1 = d; b1 = c;
								max_diff = diff;
							}
						}
					}
				}
			}
		}

		if( a1 == -1 && nearMax == 10 ){
			nearMax = 50;
			goto RESTART;
		}
		else if( a1 == -1 && nearMax == 50  ){
			int r = rand() % ( fNumOfElementInCU - 1 );
			a = fListOfCenterUnit[ r ];
			b = fListOfCenterUnit[ r+1 ];
			for( j = 0; j < fN; ++j ){
				if( fCenterUnit[ j ] == 0 ){
					aa = a; bb = b;
					a1 = j;
					b1 = tKid.fLink[ j ][ 0 ];
					break;
				}
			}
			max_diff = eval->fEdgeDis[aa][bb] + eval->fEdgeDis[a1][b1] - eval->fEdgeDis[a][a1] - eval->fEdgeDis[b][b1];
		}

		if( tKid.fLink[aa][0] == bb ) tKid.fLink[aa][0]=a1;
		else tKid.fLink[aa][1] = a1;
		if( tKid.fLink[bb][0] == aa ) tKid.fLink[bb][0] = b1;
		else tKid.fLink[bb][1] = b1;
		if( tKid.fLink[a1][0] == b1 ) tKid.fLink[a1][0] = aa;
		else tKid.fLink[a1][1] = aa;
		if( tKid.fLink[b1][0] == a1 ) tKid.fLink[b1][0] = bb;
		else tKid.fLink[b1][1] = bb;

		fModiEdge[ fNumOfModiEdge ][ 0 ] = aa;
		fModiEdge[ fNumOfModiEdge ][ 1 ] = bb;
		fModiEdge[ fNumOfModiEdge ][ 2 ] = a1;
		fModiEdge[ fNumOfModiEdge ][ 3 ] = b1;
		++fNumOfModiEdge;

		fGainModi += max_diff;

		int posi_a1 = fInv[ a1 ];
		select_un = -1;
		for( int s = 0; s < fNumOfSeg; ++s )
			if( fSegment[ s ][ 0 ] <= posi_a1 && posi_a1 <=  fSegment[ s ][ 1 ] ){
				select_un = fSegUnit[ s ];
				break;
			}


		for( int s = 0; s < fNumOfSeg; ++s )
			if( fSegUnit[ s ] == select_un ) fSegUnit[ s ] = center_un;

		fNumOfElementInUnit[ center_un ] += fNumOfElementInUnit[ select_un ];

		for( int s = 0; s < fNumOfSeg; ++s )
			if( fSegUnit[ s ] == fNumOfUnit - 1 ) fSegUnit[ s ] = select_un;

		fNumOfElementInUnit[ select_un ] = fNumOfElementInUnit[ fNumOfUnit - 1 ];
		--fNumOfUnit;

		for( int s = 0; s < fNumOfElementInCU; ++s ){
			c = fListOfCenterUnit[ s ];
			fCenterUnit[ c ] = 0;
		}
	}
}

void TCross::makeUnit(){
	int flag = 1;
	for( int s = 0; s < fNumOfSPL; ++s ){
		if( fSegPosiList[ s ] == 0 ){
			flag = 0;
			break;
		}
	}
	if( flag == 1 ){
		fSegPosiList[ fNumOfSPL++ ] = 0;
		LinkBPosi[ fN-1 ][ 1 ]  = LinkBPosi[ fN-1 ][ 0 ];
		LinkBPosi[ 0 ][ 1 ] = LinkBPosi[ 0 ][ 0 ];
		LinkBPosi[ fN-1 ][ 0 ] = 0;
		LinkBPosi[ 0 ][ 0 ] = fN-1;
	}

	tSort->sort( fSegPosiList, fNumOfSPL );
	fNumOfSeg = fNumOfSPL;
	for( int s = 0; s < fNumOfSeg-1; ++s ){
		fSegment[ s ][ 0 ] = fSegPosiList[ s ];
		fSegment[ s ][ 1 ] = fSegPosiList[ s+1 ]-1;
	}

	fSegment[ fNumOfSeg-1 ][ 0 ] = fSegPosiList[ fNumOfSeg-1 ];
	fSegment[ fNumOfSeg-1 ][ 1 ] = fN - 1;

	for( int s = 0; s < fNumOfSeg; ++s ){
		LinkAPosi[ fSegment[ s ][ 0 ] ] = fSegment[ s ][ 1 ];
		LinkAPosi[ fSegment[ s ][ 1 ] ] = fSegment[ s ][ 0 ];
		fPosiSeg[ fSegment[ s ][ 0 ] ] = s;
		fPosiSeg[ fSegment[ s ][ 1 ] ] = s;
	}

	for( int s = 0; s < fNumOfSeg; ++s ) fSegUnit[ s ] = -1;
	fNumOfUnit = 0;

	int p_st, p1, p2, p_next, p_pre;
	int segNum;
	while(1){
		flag = 0;
		for( int s = 0; s < fNumOfSeg; ++s ){
			if( fSegUnit[ s ] == -1 ){
				p_st = fSegment[ s ][ 0 ];
				p_pre = -1;
				p1 = p_st;
				flag = 1;
				break;
			}
		}
		if( flag == 0 ) break;

		while(1){
			segNum = fPosiSeg[ p1 ];
			fSegUnit[ segNum ] = fNumOfUnit;

			p2 = LinkAPosi[ p1 ];
			p_next = LinkBPosi[ p2 ][ 0 ];
			if( p1 == p2 )
				if( p_next == p_pre ) p_next = LinkBPosi[ p2 ][ 1 ];

			if( p_next == p_st ){
				++fNumOfUnit;
				break;
			}

			p_pre = p2;
			p1 = p_next;
		}
	}

	for( int s = 0; s < fNumOfUnit; ++s ) fNumOfElementInUnit[ s ] = 0;

	int unitNum = -1;
	int tmpNumOfSeg = -1;
	for( int s = 0; s < fNumOfSeg; ++s ){
		if( fSegUnit[ s ] != unitNum ){
			++tmpNumOfSeg;
			fSegment[ tmpNumOfSeg ][ 0 ] = fSegment[ s ][ 0 ];
			fSegment[ tmpNumOfSeg ][ 1 ] = fSegment[ s ][ 1 ];
			unitNum = fSegUnit[ s ];
			fSegUnit[ tmpNumOfSeg ] = unitNum;
			fNumOfElementInUnit[ unitNum ] +=
			fSegment[ s ][ 1 ] - fSegment[ s ][ 0 ] + 1;
		}
		else{
			fSegment[ tmpNumOfSeg ][ 1 ] = fSegment[ s ][ 1 ];
			fNumOfElementInUnit[ unitNum ] +=
			fSegment[ s ][ 1 ] - fSegment[ s ][ 0 ] + 1;
		}
	}
	fNumOfSeg = tmpNumOfSeg + 1;
}

void TCross::backToPa1( TIndi& tKid ){
	int aa, bb, a1, b1;
	int jnum;

	for( int s = fNumOfModiEdge -1; s >= 0; --s ){
		aa = fModiEdge[ s ][ 0 ];
		a1 = fModiEdge[ s ][ 1 ];
		bb = fModiEdge[ s ][ 2 ];
		b1 = fModiEdge[ s ][ 3 ];

		if( tKid.fLink[aa][0] == bb ) tKid.fLink[aa][0] = a1;
		else tKid.fLink[aa][1] = a1;
		if( tKid.fLink[b1][0] == a1 ) tKid.fLink[b1][0] = bb;
		else tKid.fLink[b1][1] = bb;
		if( tKid.fLink[bb][0] == aa ) tKid.fLink[bb][0] = b1;
		else tKid.fLink[bb][1] = b1;
		if( tKid.fLink[a1][0] == b1 ) tKid.fLink[a1][0] = aa;
		else tKid.fLink[a1][1] = aa;
	}

	for( int s = 0; s < fNumOfAppliedCycle; ++s ){
		jnum = fAppliedCylce[ s ];
		this->changeSol( tKid, jnum, 2 );
	}
}

void TCross::goToBest( TIndi& tKid ){
	int aa, bb, a1, b1;
	int jnum;

	for( int s = 0; s < fNumOfBestAppliedCycle; ++s ){
		jnum = fBestAppliedCylce[ s ];
		this->changeSol( tKid, jnum, 1 );
	}

	 for( int s = 0; s < fNumOfBestModiEdge; ++s ){
		aa = fBestModiEdge[ s ][ 0 ];
		bb = fBestModiEdge[ s ][ 1 ];
		a1 = fBestModiEdge[ s ][ 2 ];
		b1 = fBestModiEdge[ s ][ 3 ];

		if( tKid.fLink[aa][0] == bb ) tKid.fLink[aa][0]=a1;
		else tKid.fLink[aa][1] = a1;
		if( tKid.fLink[bb][0] == aa ) tKid.fLink[bb][0] = b1;
		else tKid.fLink[bb][1] = b1;
		if( tKid.fLink[a1][0] == b1 ) tKid.fLink[a1][0] = aa;
		else tKid.fLink[a1][1] = aa;
		if( tKid.fLink[b1][0] == a1 ) tKid.fLink[b1][0] = bb;
		else tKid.fLink[b1][1] = bb;
	}
}

void TCross::incrementEdgeFreq( int **fEdgeFreq ){
	int j, jnum, cem;
	int r1, r2, b1, b2;
	int aa, bb, a1;

	for( int s = 0; s < fNumOfBestAppliedCycle; ++s ){
		jnum = fBestAppliedCylce[ s ];

		cem = fABcycle[ jnum ][ 0 ];
		fC[ 0 ] = fABcycle[ jnum ][ 0 ];

		for( j = 1; j <= cem+3; ++j )
			fC[ j ] = fABcycle[ jnum ][ j ];

		for( j = 0; j <cem/2; ++j ){
			r1 = fC[2+2*j]; r2 = fC[3+2*j];
			b1 = fC[1+2*j]; b2 = fC[4+2*j];

			++fEdgeFreq[ r1 ][ b1 ];
			--fEdgeFreq[ r1 ][ r2 ];
			--fEdgeFreq[ r2 ][ r1 ];
			++fEdgeFreq[ r2 ][ b2 ];
		}
	}
	for( int s = 0; s < fNumOfBestModiEdge; ++s ){
		aa = fBestModiEdge[ s ][ 0 ];
		bb = fBestModiEdge[ s ][ 1 ];
		a1 = fBestModiEdge[ s ][ 2 ];
		b1 = fBestModiEdge[ s ][ 3 ];

		--fEdgeFreq[ aa ][ bb ];
		--fEdgeFreq[ a1 ][ b1 ];
		++fEdgeFreq[ aa ][ a1 ];
		++fEdgeFreq[ bb ][ b1 ];
		--fEdgeFreq[ bb ][ aa ];
		--fEdgeFreq[ b1 ][ a1 ];
		++fEdgeFreq[ a1 ][ aa ];
		++fEdgeFreq[ b1 ][ bb ];
	}
}

int TCross::calAdpLoss( int **fEdgeFreq ){
	int j, jnum, cem;
	int r1, r2, b1, b2;
	int aa, bb, a1;
	double DLoss;

	DLoss = 0;
	for( int s = 0; s < fNumOfAppliedCycle; ++s ){
		jnum = fAppliedCylce[ s ];

		cem = fABcycle[ jnum ][ 0 ];
		fC[ 0 ] = fABcycle[ jnum ][ 0 ];

		for( j = 1; j <= cem+3; ++j ) fC[ j ] = fABcycle[ jnum ][ j ];

		for( j = 0; j <cem/2; ++j ){
			r1 = fC[2+2*j]; r2 = fC[3+2*j];
			b1 = fC[1+2*j]; b2 = fC[4+2*j];


			DLoss -= (fEdgeFreq[ r1 ][ r2 ]-1);
			DLoss -= (fEdgeFreq[ r2 ][ r1 ]-1);
			DLoss += fEdgeFreq[ r2 ][ b2 ];
			DLoss += fEdgeFreq[ b2 ][ r2 ];


			--fEdgeFreq[ r1 ][ r2 ];
			--fEdgeFreq[ r2 ][ r1 ];
			++fEdgeFreq[ r2 ][ b2 ];
			++fEdgeFreq[ b2 ][ r2 ];
		}
	}
	for( int s = 0; s < fNumOfModiEdge; ++s ){
		aa = fModiEdge[ s ][ 0 ];
		bb = fModiEdge[ s ][ 1 ];
		a1 = fModiEdge[ s ][ 2 ];
		b1 = fModiEdge[ s ][ 3 ];

		DLoss -= (fEdgeFreq[ aa ][ bb ]-1);
		DLoss -= (fEdgeFreq[ bb ][ aa ]-1);
		DLoss -= (fEdgeFreq[ a1 ][ b1 ]-1);
		DLoss -= (fEdgeFreq[ b1 ][ a1 ]-1);

		DLoss += fEdgeFreq[ aa ][ a1 ];
		DLoss += fEdgeFreq[ a1 ][ aa ];
		DLoss += fEdgeFreq[ bb ][ b1 ];
		DLoss += fEdgeFreq[ b1 ][ bb ];

		--fEdgeFreq[ aa ][ bb ];
		--fEdgeFreq[ bb ][ aa ];
		--fEdgeFreq[ a1 ][ b1 ];
		--fEdgeFreq[ b1 ][ a1 ];

		++fEdgeFreq[ aa ][ a1 ];
		++fEdgeFreq[ a1 ][ aa ];
		++fEdgeFreq[ bb ][ b1 ];
		++fEdgeFreq[ b1 ][ bb ];
	}
	for( int s = 0; s < fNumOfAppliedCycle; ++s ){
		jnum = fAppliedCylce[ s ];
		cem = fABcycle[ jnum ][ 0 ];
		fC[ 0 ] = fABcycle[ jnum ][ 0 ];
		for( j = 1; j <= cem+3; ++j ) fC[ j ] = fABcycle[ jnum ][ j ];

		for( j = 0; j <cem/2; ++j ){
			r1 = fC[2+2*j]; r2 = fC[3+2*j];
			b1 = fC[1+2*j]; b2 = fC[4+2*j];

			++fEdgeFreq[ r1 ][ r2 ];
			++fEdgeFreq[ r2 ][ r1 ];
			--fEdgeFreq[ r2 ][ b2 ];
			--fEdgeFreq[ b2 ][ r2 ];
		}
	}
	for( int s = 0; s < fNumOfModiEdge; ++s ){
		aa = fModiEdge[ s ][ 0 ];
		bb = fModiEdge[ s ][ 1 ];
		a1 = fModiEdge[ s ][ 2 ];
		b1 = fModiEdge[ s ][ 3 ];

		++fEdgeFreq[ aa ][ bb ];
		++fEdgeFreq[ bb ][ aa ];
		++fEdgeFreq[ a1 ][ b1 ];
		++fEdgeFreq[ b1 ][ a1 ];

		--fEdgeFreq[ aa ][ a1 ];
		--fEdgeFreq[ a1 ][ aa ];
		--fEdgeFreq[ bb ][ b1 ];
		--fEdgeFreq[ b1 ][ bb ];
	}
	return int(DLoss / 2);
}

double TCross::calEntLoss( int **fEdgeFreq ){
	int j, jnum, cem;
	int r1, r2, b1, b2;
	int aa, bb, a1;
	double DLoss;
	double h1, h2;

	DLoss = 0;	// AB-cycle
	for( int s = 0; s < fNumOfAppliedCycle; ++s ){
		jnum = fAppliedCylce[ s ];
		cem = fABcycle[ jnum ][ 0 ];
		fC[ 0 ] = fABcycle[ jnum ][ 0 ];

		for( j = 1; j <= cem+3; ++j ) fC[ j ] = fABcycle[ jnum ][ j ];

		for( j = 0; j <cem/2; ++j ){
			r1 = fC[2+2*j]; r2 = fC[3+2*j];
			b1 = fC[1+2*j]; b2 = fC[4+2*j];

		  h1 = (double)( fEdgeFreq[ r1 ][ r2 ] - 1 )/(double)Npop;
		  h2 = (double)( fEdgeFreq[ r1 ][ r2 ] )/(double)Npop;
		  if( fEdgeFreq[ r1 ][ r2 ] - 1 != 0 ) DLoss -= h1 * log( h1 );
		  DLoss += h2 * log( h2 );
		  --fEdgeFreq[ r1 ][ r2 ];
		  --fEdgeFreq[ r2 ][ r1 ];

		  h1 = (double)( fEdgeFreq[ r2 ][ b2 ] + 1 )/(double)Npop;
		  h2 = (double)( fEdgeFreq[ r2 ][ b2 ])/(double)Npop;
		  DLoss -= h1 * log( h1 );
		  if( fEdgeFreq[ r2 ][ b2 ] != 0 ) DLoss += h2 * log( h2 );
		  ++fEdgeFreq[ r2 ][ b2 ];
		  ++fEdgeFreq[ b2 ][ r2 ];
		}
	}

	for( int s = 0; s < fNumOfModiEdge; ++s ){
		aa = fModiEdge[ s ][ 0 ];
		bb = fModiEdge[ s ][ 1 ];
		a1 = fModiEdge[ s ][ 2 ];
		b1 = fModiEdge[ s ][ 3 ];

		h1 = (double)( fEdgeFreq[ aa ][ bb ] - 1 )/(double)Npop;
		h2 = (double)( fEdgeFreq[ aa ][ bb ] )/(double)Npop;
		if( fEdgeFreq[ aa ][ bb ] - 1 != 0 )
		  DLoss -= h1 * log( h1 );
		DLoss += h2 * log( h2 );
		--fEdgeFreq[ aa ][ bb ];
		--fEdgeFreq[ bb ][ aa ];

		h1 = (double)( fEdgeFreq[ a1 ][ b1 ] - 1 )/(double)Npop;
		h2 = (double)( fEdgeFreq[ a1 ][ b1 ] )/(double)Npop;
		if( fEdgeFreq[ a1 ][ b1 ] - 1 != 0 )
		  DLoss -= h1 * log( h1 );
		DLoss += h2 * log( h2 );
		--fEdgeFreq[ a1 ][ b1 ];
		--fEdgeFreq[ b1 ][ a1 ];

		h1 = (double)( fEdgeFreq[ aa ][ a1 ] + 1 )/(double)Npop;
		h2 = (double)( fEdgeFreq[ aa ][ a1 ])/(double)Npop;
		DLoss -= h1 * log( h1 );
		if( fEdgeFreq[ aa ][ a1 ] != 0 )
		  DLoss += h2 * log( h2 );
		++fEdgeFreq[ aa ][ a1 ];
		++fEdgeFreq[ a1 ][ aa ];

		h1 = (double)( fEdgeFreq[ bb ][ b1 ] + 1 )/(double)Npop;
		h2 = (double)( fEdgeFreq[ bb ][ b1 ])/(double)Npop;
		DLoss -= h1 * log( h1 );
		if( fEdgeFreq[ bb ][ b1 ] != 0 )
		  DLoss += h2 * log( h2 );
		++fEdgeFreq[ bb ][ b1 ];
		++fEdgeFreq[ b1 ][ bb ];
	}
	DLoss = -DLoss;

	// 更新 EdgeFreq
	for( int s = 0; s < fNumOfAppliedCycle; ++s ){
		jnum = fAppliedCylce[ s ];

		cem = fABcycle[ jnum ][ 0 ];
		fC[ 0 ] = fABcycle[ jnum ][ 0 ];

		for( j = 1; j <= cem+3; ++j ) fC[ j ] = fABcycle[ jnum ][ j ];

		for( j = 0; j <cem/2; ++j ){
		  r1 = fC[2+2*j]; r2 = fC[3+2*j];
		  b1 = fC[1+2*j]; b2 = fC[4+2*j];

		  ++fEdgeFreq[ r1 ][ r2 ];
		  ++fEdgeFreq[ r2 ][ r1 ];
		  --fEdgeFreq[ r2 ][ b2 ];
		  --fEdgeFreq[ b2 ][ r2 ];
		}
	}
	for( int s = 0; s < fNumOfModiEdge; ++s ){
		aa = fModiEdge[ s ][ 0 ];
		bb = fModiEdge[ s ][ 1 ];
		a1 = fModiEdge[ s ][ 2 ];
		b1 = fModiEdge[ s ][ 3 ];

		++fEdgeFreq[ aa ][ bb ];
		++fEdgeFreq[ bb ][ aa ];
		++fEdgeFreq[ a1 ][ b1 ];
		++fEdgeFreq[ b1 ][ a1 ];

		--fEdgeFreq[ aa ][ a1 ];
		--fEdgeFreq[ a1 ][ aa ];
		--fEdgeFreq[ bb ][ b1 ];
		--fEdgeFreq[ b1 ][ bb ];
	}
  return DLoss;
}

void TCross::setWeight( const TIndi& tPa1, const TIndi& tPa2 ){
	int cem;
	int r1, r2, v1, v2, v_p;
	int AB_num;

	for( int i = 0; i < fN; ++i ){
		fInEffectNode[ i ][ 0 ] = -1;
		fInEffectNode[ i ][ 1 ] = -1;
	}

	// Step 1:
	for( int s = 0; s < fNumOfABcycle; ++s ){
		cem = fABcycle[ s ][ 0 ];
		for( int j = 0; j < cem/2; ++j ){
			r1 = fABcycle[ s ][ 2*j+2 ];  // red edge
			r2 = fABcycle[ s ][ 2*j+3 ];

			if( fInEffectNode[ r1 ][ 0 ] == -1 ) fInEffectNode[ r1 ][ 0 ] = s;
			else if ( fInEffectNode[ r1 ][ 1 ] == -1 ) fInEffectNode[ r1 ][ 1 ] = s;


			if( fInEffectNode[ r2 ][ 0 ] == -1 ) fInEffectNode[ r2 ][ 0 ] = s;
			else if ( fInEffectNode[ r2 ][ 1 ] == -1 ) fInEffectNode[ r2 ][ 1 ] = s;

		}
	}

	// Step 2:
	for( int i = 0; i < fN; ++i ){
		if( fInEffectNode[ i ][ 0 ] != -1 && fInEffectNode[ i ][ 1 ] == -1 ){
			AB_num = fInEffectNode[ i ][ 0 ];
			v1 = i;

			if( tPa1.fLink[ v1 ][ 0 ] != tPa2.fLink[ v1 ][ 0 ] && tPa1.fLink[ v1 ][ 0 ] != tPa2.fLink[ v1 ][ 1 ] )
				v_p = tPa1.fLink[ v1 ][ 0 ];
			else if( tPa1.fLink[ v1 ][ 1 ] != tPa2.fLink[ v1 ][ 0 ] && tPa1.fLink[ v1 ][ 1 ] != tPa2.fLink[ v1 ][ 1 ] )
				v_p = tPa1.fLink[ v1 ][ 1 ];


			while( 1 ){
				fInEffectNode[ v1 ][ 1 ] = AB_num;

				if( tPa1.fLink[ v1 ][ 0 ] != v_p ) v2 = tPa1.fLink[ v1 ][ 0 ];
				else if( tPa1.fLink[ v1 ][ 1 ] != v_p ) v2 = tPa1.fLink[ v1 ][ 1 ];


				if( fInEffectNode[ v2 ][ 0 ] == -1 ) fInEffectNode[ v2 ][ 0 ] = AB_num;
				else if( fInEffectNode[ v2 ][ 1 ] == -1 ) fInEffectNode[ v2 ][ 1 ] = AB_num;


				if( fInEffectNode[ v2 ][ 1 ] != -1 ) break;
				v_p = v1;
				v1 = v2;
			}
		}
	}

	// Step 3:

	for( int s1 = 0; s1 < fNumOfABcycle; ++s1 ){
		fWeightC[ s1 ] = 0;
		for( int s2 = 0; s2 < fNumOfABcycle; ++s2 ) fWeightRR[ s1 ][ s2 ] = 0;
	}

	for( int i = 0; i < fN; ++i ){

		if( fInEffectNode[ i ][ 0 ] != -1 && fInEffectNode[ i ][ 1 ] != -1 ){
			++fWeightRR[ fInEffectNode[ i ][ 0 ] ][ fInEffectNode[ i ][ 1 ] ];
			++fWeightRR[ fInEffectNode[ i ][ 1 ] ][ fInEffectNode[ i ][ 0 ] ];
		}
		if( fInEffectNode[ i ][ 0 ] != fInEffectNode[ i ][ 1 ] ){
			++fWeightC[ fInEffectNode[ i ][ 0 ] ];
			++fWeightC[ fInEffectNode[ i ][ 1 ] ];
		}
	}
	for( int s1 = 0; s1 < fNumOfABcycle; ++s1 ) fWeightRR[ s1 ][ s1 ] = 0;
}

int TCross::calCNaive(){
	int count_C;
	int tt;

	count_C = 0;

	for( int i = 0; i < fN; ++i ){
		if( fInEffectNode[ i ][ 0 ] != -1 && fInEffectNode[ i ][ 1 ] != -1 ){
			tt = 0;
			if( fUsedAB[ fInEffectNode[ i ][ 0 ] ] == 1 ) ++tt;
			if( fUsedAB[ fInEffectNode[ i ][ 1 ] ] == 1 ) ++tt;
			if( tt == 1 ) ++count_C;
		}
	}
	return count_C;
}

void TCross::searchEset( int centerAB ){
	int nIter, stagImp;
	int delta_weight, min_delta_weight_nt;
	int flag_AddDelete, flag_AddDelete_nt;
	int selected_AB, selected_AB_nt;
	int jnum;

	fNumC = 0;  // Number of C nodes in E-set
	fNumE = 0;  // Number of Edges in E-set

	fNumOfUsedAB = 0;
	for( int s1 = 0; s1 < fNumOfABcycle; ++s1 ){
		fUsedAB[ s1 ] = 0;
		fWeightSR[ s1 ] = 0;
		fMovedAB[ s1 ] = 0;
	}

	for( int s = 0; s < fNumOfABcycleInEset; ++s ){
		jnum = fABcycleInEset[ s ];
		this->addAB( jnum );
	}
	fBestNumC = fNumC;
	fBestNumE = fNumE;

	stagImp = 0;
	nIter = 0;
	while( 1 ){
		++nIter;
		min_delta_weight_nt = 99999999;
		flag_AddDelete = 0;
		flag_AddDelete_nt = 0;
		for( int s1 = 0; s1 < fNumOfABcycle; ++s1 ){
			if( fUsedAB[ s1 ] == 0 && fWeightSR[ s1 ] > 0 ){
				delta_weight = fWeightC[ s1 ] - 2 * fWeightSR[ s1 ];
				if( fNumC + delta_weight < fBestNumC ){
					selected_AB = s1;
					flag_AddDelete = 1;
					fBestNumC = fNumC + delta_weight;
				}
				if( delta_weight < min_delta_weight_nt && nIter > fMovedAB[ s1 ] ){
					selected_AB_nt = s1;
					flag_AddDelete_nt = 1;
					min_delta_weight_nt = delta_weight;
				}
			}
			else if( fUsedAB[ s1 ] == 1 && s1 != centerAB ){
				delta_weight = - fWeightC[ s1 ] + 2 * fWeightSR[ s1 ];
				if( fNumC + delta_weight < fBestNumC ){
					selected_AB = s1;
					flag_AddDelete = -1;
					fBestNumC = fNumC + delta_weight;
				}
				if( delta_weight < min_delta_weight_nt && nIter > fMovedAB[ s1 ] ){
					selected_AB_nt = s1;
					flag_AddDelete_nt = -1;
					min_delta_weight_nt = delta_weight;
				}
			}
		}

		if( flag_AddDelete != 0 ){
			if( flag_AddDelete == 1 ) this->addAB( selected_AB );
			else if( flag_AddDelete == -1 ) this->deleteAB( selected_AB );

			fMovedAB[ selected_AB ] = nIter + tRand->Integer( 1, fTmax );

			fBestNumE = fNumE;

			fNumOfABcycleInEset = 0;
			for( int s1 = 0; s1 < fNumOfABcycle; ++s1 )
				if( fUsedAB[ s1 ] == 1 ) fABcycleInEset[ fNumOfABcycleInEset++ ] = s1;

			stagImp = 0;
		}
		else if( flag_AddDelete_nt != 0 ) {
			if( flag_AddDelete_nt == 1 ) this->addAB( selected_AB_nt );
			else if( flag_AddDelete_nt == -1 )

			this->deleteAB( selected_AB_nt );
			fMovedAB[ selected_AB_nt ] = nIter + tRand->Integer( 1, fTmax );
		}
		if( flag_AddDelete == 0 ) ++stagImp;
		if( stagImp == fMaxStag ) break;
	}
}

void TCross::addAB( int num ){
	fNumC += fWeightC[ num ] - 2 * fWeightSR[ num ];
	fNumE += fABcycle[ num ][ 0 ] / 2;

	fUsedAB[ num ] = 1;
	++fNumOfUsedAB;
	for( int s1 = 0; s1 < fNumOfABcycle; ++s1 ) fWeightSR[ s1 ] += fWeightRR[ s1 ][ num ];
}

void TCross::deleteAB( int num ){
	fNumC -= fWeightC[ num ] - 2 * fWeightSR[ num ];
	fNumE -= fABcycle[ num ][ 0 ] / 2;

	fUsedAB[ num ] = 0;
	--fNumOfUsedAB;
	for( int s1 = 0; s1 < fNumOfABcycle; ++s1 ) fWeightSR[ s1 ] -= fWeightRR[ s1 ][ num ];
}

The file cross.h contains:
/*
 * cross.h
 *   created on: April 24, 2013
 * last updated: June 13, 2013
 *       author: liushujia
 */

#ifndef __Cross__
#define __Cross__

#ifndef __RAND__
#include "randomize.h"
#endif

#ifndef __Sort__
#include "sort.h"
#endif

#ifndef __INDI__
#include "indi.h"
#endif

#ifndef __EVALUATOR__
#include "evaluator.h"
#endif

#include <stdio.h>
#include <stdlib.h>
#include <assert.h>

class TCross{
public:
	TCross( int N );
	~TCross();
	void input_data(int N);
	void doIt( TIndi& tKid, TIndi& tPa2, int numOfKids, int flagP, int flagC[ 10 ], int** fEdgeFreq );	// EAXÃ¤Â¸Â»Ã§Â¨â€¹Ã¥Âºï¿½
	void setParents( const TIndi& tPa1, const TIndi& tPa2, int flagC[ 10 ], int numOfKids );			// Ã¨Â®Â¾Ã§Â½Â®Ã§Ë†Â¶Ã¦Å“Â¬Ã¤Â¸Å½Ã¦Â¯ï¿½Ã¦Å“Â¬
	void setABcycle( const TIndi& parent1, const TIndi& parent2, int flagC[ 10 ], int numOfKids );		// Ã¨Â®Â¾Ã§Â½Â®ABcycle

	void swap(int &x, int &y);
	void formABcycle();																// Ã¤Â¿ï¿½Ã¥Â­ËœABcycle
	void changeSol( TIndi& tKid, int ABnum, int type );								// Ã§â€�Â¨ABcycleÃ¤ÂºÂ§Ã§â€�Å¸Ã¤Â¸Â­Ã©â€”Â´Ã¨Â§Â£

	void makeCompleteSol( TIndi& tKid );					// EAXÃ§Â¬Â¬5Ã¦Â­Â¥
	void makeUnit();										// EAXÃ§Â¬Â¬5-1Ã¦Â­Â¥
	void backToPa1( TIndi& tKid );							// Ã¥â€ºÅ¾Ã¦Â»Å¡p_A
	void goToBest( TIndi& tKid );							// Ã¤Â¿Â®Ã¦â€�Â¹tKidÃ¤Â¸ÂºÃ¥Â­ï¿½Ã¤Â»Â£Ã¦Å“â‚¬Ã¤Â¼ËœÃ¨Â§Â£

	void incrementEdgeFreq( int **fEdgeFreq );				// Ã¥Â¢Å¾Ã¥Å Â fEdgeFreq[][]
	int calAdpLoss( int **fEdgeFreq );						// Ã¨Â®Â¡Ã§Â®â€”Ã¥Â¹Â³Ã¥ï¿½â€¡Ã¨Â·Â¯Ã§Â¨â€¹Ã§Å¡â€žÃ¥Â·Â®
	double calEntLoss( int **fEdgeFreq );					// Ã¨Â®Â¡Ã§Â®â€”Ã¨Â¾Â¹Ã§â€ ÂµÃ§Å¡â€žÃ¥Â·Â®

	void setWeight( const TIndi& parent1, const TIndi& parent2 );	// Block2
	int	calCNaive();
	void searchEset( int num );
	void addAB( int num );
	void deleteAB( int num );

	int fNumOfGeneratedCh;
	TEvaluator* eval;
	int Npop;

private:
//	TIndi tBestTmp;
	int fFlagImp;
	int fN;
	int total_fN;////////////////////////////////
	int r;
	int exam;
	int examFlag;
	int flagSt;
	int flagCycle;
	int prType;
	int chDis;
	int koritsuMany;
	int bunkiMany;
	int st;
	int ci;
	int pr;
	int stock;
	int stAppear;
	int fEvalType;
	int fEsetType;
	int fNumOfABcycleInESet;
	int fNumOfABcycle;
	int fPosiCurr;
	int fMaxNumOfABcycle;

	int *koritsu;
	int *bunki;
	int *koriInv;
	int *bunInv;
	int *checkKoritsu;
	int *fRoute;
	int *fPermu;
	int *fC;
	int *fJun;
	int *fOrd1;
	int *fOrd2;

	int **nearData;
	int **fABcycle;

	// Speed Up Start
	int fNumOfUnit;
	int fNumOfSeg;
	int fNumOfSPL;
	int fNumOfElementInCU;
	int fNumOfSegForCenter;
	double fGainModi;
	//int fGainModi;
	int fNumOfModiEdge;
	int fNumOfBestModiEdge;
	int fNumOfAppliedCycle;
	int fNumOfBestAppliedCycle;

	int *fOrder;
	int *fInv;
	int *fSegUnit;
	int *fSegPosiList;
	int *LinkAPosi;
	int *fPosiSeg;
	int *fNumOfElementInUnit;
	int *fCenterUnit;
	int *fListOfCenterUnit;
	int *fSegForCenter;
	//int *fGainAB;
	double *fGainAB;
	int *fAppliedCylce;
	int *fBestAppliedCylce;

	int **fSegment;
	int **LinkBPosi;
	int **fModiEdge;
	int **fBestModiEdge;
	// Speed Up End

	// Block2
	int fNumOfUsedAB;
	int fNumC;
	int fNumE;
	int fTmax;
	int fMaxStag;
	int fNumOfABcycleInEset;
	int fDisAB;
	int fBestNumC;
	int fBestNumE;

	int *fNumOfElementINAB;
	int *fWeightSR;
	int *fWeightC;
	int *fUsedAB;
	int *fMovedAB;
	int *fABcycleInEset;

	int **fInEffectNode;
	int **fWeightRR;
};

#endif

The file EAX.cpp contains:
/*
 *
 *
 *
 *
 */

#ifndef __ENVIRONMENT__
#include "environment.h"
#endif
#include<iostream>
#include <time.h>
#include <stdio.h>
#include <stdlib.h>
using namespace std;

void EAX(TEnvironment* gEnv, int * given_sol,int count, double *x_coor,double *y_coor){// given a initial tour and coordiantion
//	InitURandom(); //
	int maxNumOfTrial;
	maxNumOfTrial=1;					// repeated times
//	gEnv->Npop=100;						// number of items
//	gEnv->Nch=30;						// number of offsprings

	int opt_tour[count];
	int cc[count];
	for (int i=0;i<=count-1;i++)
		cc[i]=given_sol[i];
//	cout<<"Initializing ..."<<endl;
//	clock_t start = clock();
	gEnv->input_data(given_sol,count,x_coor,y_coor);
//	cout<<"Building solution ..."<<endl;
	for ( int n = 0; n < maxNumOfTrial; ++n ){
		gEnv->doIt();
		gEnv->writeBest(opt_tour);
	}
	int best_sol[count];
	for (int i=0;i<count;i++)
	{
		best_sol[i]=given_sol[opt_tour[i]-1];
	}
	for (int i=0;i<=count;i++)
		given_sol[i]=best_sol[i];
}

The file EAX.h contains:
/*
 * EAX.h
 *
 *  Created on: 13 Apr 2020
 *      Author: Peng
 */

#ifndef EAX_H_
#define EAX_H_

#ifndef __ENVIRONMENT__
#include "environment.h"
#endif




int EAX(TEnvironment* gEnv, int * given_sol,int count, double *x_coor,double *y_coor);





#endif /* EAX_H_ */

The file environment.cpp contains:
/*
 * environment.cpp
 *   created on: April 24, 2013
 * last updated: June 13, 2013
 *       author: liushujia
 */

#ifndef __ENVIRONMENT__
#include "environment.h"
#endif
#include "basic.h"
#include <math.h>
#include<iostream>
using namespace std;

void MakeRandSol(TEvaluator* eval, TIndi& indi);
void Make2optSol(TEvaluator* eval, TIndi& indi);

TEnvironment::TEnvironment(){
	fEvaluator = new TEvaluator();
}

TEnvironment::~TEnvironment(){
	delete [] fIndexForMating;
	delete [] tCurPop;
	int N = fEvaluator->totalCity;
	delete fEvaluator;
	delete tCross;
	delete tKopt;
	for( int i = 0; i < N; ++i ) delete [] fEdgeFreq[ i ];
	delete [] fEdgeFreq;
}
void TEnvironment::input_data(int * given_sol,int count,double *x_coor,double *y_coor)
{
	fEvaluator->setInstance1(given_sol, count,x_coor,y_coor);
	for ( int i = 0; i < Npop; ++i ) tCurPop[i].define1(count);
	tBest.define1(count);// define the best solution
	tCross->input_data(count);
	tKopt->input_data(count);
	tKopt->setInvNearList();
	tCross->Npop = Npop;
	num_nodes=count;
}

void TEnvironment::define(int count,int graph_type){
	fEvaluator->setInstance(count,graph_type);
	int N_c = fEvaluator->totalCity;//æ€»å…±ç‚¹çš„æ•°é‡�
	fIndexForMating = new int [ Npop + 1 ];
	tCurPop = new TIndi [ Npop ];// define the number of population
	for ( int i = 0; i < Npop; ++i ) tCurPop[i].define( N_c );
	tBest.define( N_c );// define the best solution
	tCross = new TCross( N_c );// define a crossover objective by using parameter N which is the number cities
	tCross->eval = fEvaluator;// probe directs it
	tKopt = new TKopt(N_c );
	tKopt->eval = fEvaluator;
	fEdgeFreq = new int* [ N_c ];
	for( int i = 0; i < N_c; ++i ) fEdgeFreq[ i ] = new int [ N_c ];
}

void TEnvironment::doIt(){
	this->fTimeStart = clock();// to calculate the initial time
	this->initPop();				// åˆ�å§‹åŒ–ç§�ç¾¤
	if (num_nodes<10){// in this place, if the number of cities is too small, the k-optis used
		this->setAverageBest();
		return;
	}
	this->fTimeInit = clock();    // initial time
	this->init();
	this->getEdgeFreq();
	no_improve=0;
	change=Max;
	while( 1 ){
		this->setAverageBest();
		if ((change-1.0e-7)>tBest.fEvaluationValue){// indicate the improvement
			change=tBest.fEvaluationValue;
			no_improve=0;
		}
		else
			no_improve++;
//		printf( "%d:\t%f\t%lf\n", fCurNumOfGen, fBestValue, fAverageValue );
		if( this->terminationCondition() || no_improve>100) break;

		this->selectForMating();
		for( int s =0; s < Npop; ++s ) this->generateKids( s );

		++fCurNumOfGen;
	}
	this->fTimeEnd = clock();
}

void TEnvironment::init(){
	fAccumurateNumCh = 0;
	fCurNumOfGen = 0;
	fStagBest = 0;
	fMaxStagBest = 0;
	fStage = 1;				// é˜¶æ®µ1
	fFlagC[ 0 ] = 4;		// ç»´æŒ�ç§�ç¾¤å¤šæ ·æ€§	1:Greedy, 2:---, 3:Distance, 4:Entropy
	fFlagC[ 1 ] = 1;		// Esetç±»åž‹			1:Single-AB, 2:Block2
}

bool TEnvironment::terminationCondition(){
	if ( fAverageValue - fBestValue < 0.00001 )  return true;
	if( fStage == 1 ){
		if( fStagBest == int(1500/Nch) && fMaxStagBest == 0 )			// 1500/Nch
			fMaxStagBest =int( fCurNumOfGen / 10 );						// fMaxStagBest = G/10
		else if( fMaxStagBest != 0 && fMaxStagBest <= fStagBest ){
			fStagBest = 0;
			fMaxStagBest = 0;
			fCurNumOfGen1 = fCurNumOfGen;
			fFlagC[ 1 ] = 2;
			fStage = 2;
		}
		return false;
	}
	if( fStage == 2 ){
		if( fStagBest == int(1500/Nch) && fMaxStagBest == 0 )			// 1500/Nch
			fMaxStagBest = int( (fCurNumOfGen - fCurNumOfGen1) / 10 );	// fMaxStagBest = G/10
		else if( fMaxStagBest != 0 && fMaxStagBest <= fStagBest ) return true;
		return false;
	}

	return true;
}

void TEnvironment::setAverageBest(){
	double stockBest = tBest.fEvaluationValue;
	//int stockBest = tBest.fEvaluationValue;
	fAverageValue = 0.0;
	fBestIndex = 0;
	fBestValue = tCurPop[0].fEvaluationValue;
	for(int i = 0; i < Npop; ++i ){
		fAverageValue += tCurPop[i].fEvaluationValue;
		if( tCurPop[i].fEvaluationValue < fBestValue ){
			fBestIndex = i;
			fBestValue = tCurPop[i].fEvaluationValue;
		}
	}
	tBest = tCurPop[ fBestIndex ];
	fAverageValue /= (double)Npop;
	if( tBest.fEvaluationValue < stockBest ){
		fStagBest = 0;
		fBestNumOfGen = fCurNumOfGen;
		fBestAccumeratedNumCh = fAccumurateNumCh;
	}
	else ++fStagBest;
}

void TEnvironment::initPop(){
	for ( int i = 0; i < Npop; ++i ){
		tKopt->makeRandSol( tCurPop[ i ] );		// è®¾ç½®ä¸€ä¸ªéš�æœºè·¯ç¨‹
		tKopt->doIt( tCurPop[ i ] );			// å±€éƒ¨æ�œç´¢(2-opt neighborhood)
	}
}

void TEnvironment::selectForMating(){
	tRand->permutation( fIndexForMating, Npop, Npop );
	fIndexForMating[ Npop ] = fIndexForMating[ 0 ];
}

void TEnvironment::generateKids( int s ){
	// tCurPop[fIndexForMating[s]] è¢«æ›¿æ�¢ä¸ºtCross->DoIt()ä¸­å­�ä»£çš„ä¸€ä¸ªæœ€ä¼˜è§£
	// fEdgeFreq[][] å�Œæ—¶è¢«æ›´æ–°
	tCross->setParents( tCurPop[fIndexForMating[s]], tCurPop[fIndexForMating[s+1]], fFlagC, Nch );
	tCross->doIt( tCurPop[fIndexForMating[s]], tCurPop[fIndexForMating[s+1]], Nch, 1, fFlagC, fEdgeFreq );
	fAccumurateNumCh += tCross->fNumOfGeneratedCh;
}

void TEnvironment::getEdgeFreq(){
	int  k0, k1, N = fEvaluator->Ncity;
	for( int j1 = 0; j1 < N; ++j1 )
		for( int j2 = 0; j2 < N; ++j2 )
			fEdgeFreq[ j1 ][ j2 ] = 0;

	for( int i = 0; i < Npop; ++i )
		for(int j = 0; j < N; ++j ){
			k0 = tCurPop[ i ].fLink[ j ][ 0 ];
			k1 = tCurPop[ i ].fLink[ j ][ 1 ];
			++fEdgeFreq[ j ][ k0 ];
			++fEdgeFreq[ j ][ k1 ];
		}
}

void TEnvironment::printOn( int n ){
	printf( "n = %d val = %f Gen = %d Time = %d %d\n" , n, tBest.fEvaluationValue, fCurNumOfGen,
		(int)((double)(this->fTimeInit - this->fTimeStart)/(double)CLOCKS_PER_SEC),
		(int)((double)(this->fTimeEnd - this->fTimeStart)/(double)CLOCKS_PER_SEC) );
//	fflush(stdout);

}

void TEnvironment::writeBest(int *given_sol){
//	FILE *fp;
//	char filename[ 80 ];

//	sprintf( filename, "bestSolution.txt" );
//	fp = fopen( filename, "a");
	fEvaluator->writeTo(given_sol, tBest );
//	fclose( fp );
}

The file environment.h contains:

/*
 * environment.h
 *   created on: April 24, 2013
 * last updated: June 13, 2013
 *       author: liushujia
 */

#ifndef __ENVIRONMENT__
#define __ENVIRONMENT__

#ifndef __INDI__
#include "indi.h"
#endif

#ifndef __RAND__
#include "randomize.h"
#endif

#ifndef __EVALUATOR__
#include "evaluator.h"
#endif

#ifndef __Cross__
#include "cross.h"
#endif

#ifndef __KOPT__
#include "kopt.h"
#endif

#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <string.h>
#include <time.h>

class TEnvironment{
public:
	TEnvironment();
	~TEnvironment();
	void input_data(int * given_sol,int count,double *x_coor,double *y_coor);
	void define(int count,int graph_type);						// ÃƒÂ¥Ã‹â€ Ã¯Â¿Â½ÃƒÂ¥Ã‚Â§Ã¢â‚¬Â¹ÃƒÂ¥Ã…â€™Ã¢â‚¬â€œ
	//void define();						// ÃƒÂ¥Ã‹â€ Ã¯Â¿Â½ÃƒÂ¥Ã‚Â§Ã¢â‚¬Â¹ÃƒÂ¥Ã…â€™Ã¢â‚¬â€œ
	void doIt();						// GAÃƒÂ¤Ã‚Â¸Ã‚Â»ÃƒÂ§Ã‚Â¨Ã¢â‚¬Â¹ÃƒÂ¥Ã‚ÂºÃ¯Â¿Â½
	void init();						// GAÃƒÂ¥Ã‹â€ Ã¯Â¿Â½ÃƒÂ¥Ã‚Â§Ã¢â‚¬Â¹ÃƒÂ¥Ã…â€™Ã¢â‚¬â€œ
	bool terminationCondition();		// ÃƒÂ©Ã¢â€šÂ¬Ã¢â€šÂ¬ÃƒÂ¥Ã¢â‚¬Â¡Ã‚ÂºÃƒÂ¦Ã¯Â¿Â½Ã‚Â¡ÃƒÂ¤Ã‚Â»Ã‚Â¶
	void setAverageBest();				// ÃƒÂ¨Ã‚Â®Ã‚Â¡ÃƒÂ§Ã‚Â®Ã¢â‚¬â€�ÃƒÂ§Ã‚Â§Ã¯Â¿Â½ÃƒÂ§Ã‚Â¾Ã‚Â¤ÃƒÂ¥Ã‚Â¹Ã‚Â³ÃƒÂ¥Ã¯Â¿Â½Ã¢â‚¬Â¡TSPÃƒÂ©Ã¢â‚¬Â¢Ã‚Â¿ÃƒÂ¥Ã‚ÂºÃ‚Â¦ÃƒÂ¤Ã‚Â¸Ã…Â½ÃƒÂ§Ã‚Â§Ã¯Â¿Â½ÃƒÂ§Ã‚Â¾Ã‚Â¤ÃƒÂ¦Ã…â€œÃ¢â€šÂ¬ÃƒÂ¤Ã‚Â¼Ã‹Å“TSPÃƒÂ©Ã¢â‚¬Â¢Ã‚Â¿ÃƒÂ¥Ã‚ÂºÃ‚Â¦

	void initPop();						// ÃƒÂ¥Ã‹â€ Ã¯Â¿Â½ÃƒÂ¥Ã‚Â§Ã¢â‚¬Â¹ÃƒÂ¥Ã…â€™Ã¢â‚¬â€œÃƒÂ§Ã‚Â§Ã¯Â¿Â½ÃƒÂ§Ã‚Â¾Ã‚Â¤
	void selectForMating();				// ÃƒÂ©Ã¢â€šÂ¬Ã¢â‚¬Â°ÃƒÂ¦Ã¢â‚¬Â¹Ã‚Â©ÃƒÂ§Ã‹â€ Ã‚Â¶ÃƒÂ¦Ã…â€œÃ‚Â¬ÃƒÂ¤Ã‚Â¸Ã…Â½ÃƒÂ¦Ã‚Â¯Ã¯Â¿Â½ÃƒÂ¦Ã…â€œÃ‚Â¬
	void generateKids( int s );			// ÃƒÂ¤Ã‚ÂºÃ‚Â§ÃƒÂ§Ã¢â‚¬ï¿½Ã…Â¸ÃƒÂ¥Ã‚Â¹Ã‚Â¶ÃƒÂ©Ã¢â€šÂ¬Ã¢â‚¬Â°ÃƒÂ¦Ã¢â‚¬Â¹Ã‚Â©ÃƒÂ¥Ã‚Â­Ã¯Â¿Â½ÃƒÂ¤Ã‚Â»Ã‚Â£
	void getEdgeFreq();					// ÃƒÂ¨Ã‚Â®Ã‚Â¡ÃƒÂ§Ã‚Â®Ã¢â‚¬â€�ÃƒÂ§Ã‚Â§Ã¯Â¿Â½ÃƒÂ§Ã‚Â¾Ã‚Â¤ÃƒÂ¤Ã‚Â¸Ã‚Â­ÃƒÂ¦Ã‚Â¯Ã¯Â¿Â½ÃƒÂ¦Ã¯Â¿Â½Ã‚Â¡ÃƒÂ¨Ã‚Â¾Ã‚Â¹ÃƒÂ§Ã…Â¡Ã¢â‚¬Å¾ÃƒÂ©Ã‚Â¢Ã¢â‚¬ËœÃƒÂ§Ã…Â½Ã¢â‚¬Â¡

	void printOn( int n );				// ÃƒÂ¨Ã‚Â¾Ã¢â‚¬Å“ÃƒÂ¥Ã¢â‚¬Â¡Ã‚ÂºÃƒÂ§Ã‚Â»Ã¢â‚¬Å“ÃƒÂ¦Ã…Â¾Ã…â€œ
	void writeBest(int *given_sol);					// ÃƒÂ¨Ã‚Â¾Ã¢â‚¬Å“ÃƒÂ¥Ã¢â‚¬Â¡Ã‚ÂºÃƒÂ¦Ã…â€œÃ¢â€šÂ¬ÃƒÂ¤Ã‚Â¼Ã‹Å“TSPÃƒÂ¨Ã‚Â·Ã‚Â¯ÃƒÂ¥Ã‚Â¾Ã¢â‚¬Å¾
	//void writeBest();					// ÃƒÂ¨Ã‚Â¾Ã¢â‚¬Å“ÃƒÂ¥Ã¢â‚¬Â¡Ã‚ÂºÃƒÂ¦Ã…â€œÃ¢â€šÂ¬ÃƒÂ¤Ã‚Â¼Ã‹Å“TSPÃƒÂ¨Ã‚Â·Ã‚Â¯ÃƒÂ¥Ã‚Â¾Ã¢â‚¬Å¾

	TEvaluator* fEvaluator;				// ÃƒÂ¨Ã‚Â¾Ã‚Â¹ÃƒÂ¨Ã‚Â·Ã¯Â¿Â½ÃƒÂ§Ã‚Â¦Ã‚Â»
	TCross* tCross;						// ÃƒÂ¨Ã‚Â¾Ã‚Â¹ÃƒÂ©Ã¢â‚¬ÂºÃ¢â‚¬Â ÃƒÂ¥Ã¯Â¿Â½Ã‹â€ ÃƒÂ¤Ã‚ÂºÃ‚Â¤ÃƒÂ¥Ã¯Â¿Â½Ã¢â‚¬Â°
	TKopt* tKopt;						// ÃƒÂ¥Ã‚Â±Ã¢â€šÂ¬ÃƒÂ©Ã†â€™Ã‚Â¨ÃƒÂ¦Ã¯Â¿Â½Ã…â€œÃƒÂ§Ã‚Â´Ã‚Â¢(2-opt neighborhood)
//	char *fFileNameTSP;					// TSPÃƒÂ¦Ã¢â‚¬â€œÃ¢â‚¬Â¡ÃƒÂ¤Ã‚Â»Ã‚Â¶ÃƒÂ¥Ã¯Â¿Â½Ã¯Â¿Â½

	int Npop;							// ÃƒÂ§Ã‚Â§Ã¯Â¿Â½ÃƒÂ§Ã‚Â¾Ã‚Â¤ÃƒÂ¦Ã¢â‚¬Â¢Ã‚Â°ÃƒÂ©Ã¢â‚¬Â¡Ã¯Â¿Â½
	int Nch;							// ÃƒÂ¦Ã‚Â¯Ã¯Â¿Â½ÃƒÂ¤Ã‚Â¸Ã‚ÂªÃƒÂ§Ã‹â€ Ã‚Â¶ÃƒÂ¦Ã…â€œÃ‚Â¬(ÃƒÂ¦Ã‚Â¯Ã¯Â¿Â½ÃƒÂ¦Ã…â€œÃ‚Â¬)ÃƒÂ¤Ã‚ÂºÃ‚Â§ÃƒÂ§Ã¢â‚¬ï¿½Ã…Â¸ÃƒÂ§Ã…Â¡Ã¢â‚¬Å¾ÃƒÂ¥Ã‚Â­Ã¯Â¿Â½ÃƒÂ¤Ã‚Â»Ã‚Â£ÃƒÂ¦Ã¢â‚¬Â¢Ã‚Â°ÃƒÂ©Ã¢â‚¬Â¡Ã¯Â¿Â½
	TIndi* tCurPop;						// ÃƒÂ¥Ã‚Â½Ã¢â‚¬Å“ÃƒÂ¥Ã¢â‚¬Â°Ã¯Â¿Â½ÃƒÂ§Ã‚Â§Ã¯Â¿Â½ÃƒÂ§Ã‚Â¾Ã‚Â¤ÃƒÂ¦Ã‹â€ Ã¯Â¿Â½ÃƒÂ¥Ã¢â‚¬ËœÃ‹Å“
	TIndi tBest;						// ÃƒÂ¥Ã‚Â½Ã¢â‚¬Å“ÃƒÂ¥Ã¢â‚¬Â°Ã¯Â¿Â½ÃƒÂ§Ã‚Â§Ã¯Â¿Â½ÃƒÂ§Ã‚Â¾Ã‚Â¤ÃƒÂ¦Ã…â€œÃ¢â€šÂ¬ÃƒÂ¤Ã‚Â¼Ã‹Å“ÃƒÂ¨Ã‚Â§Ã‚Â£
	int fCurNumOfGen;					// ÃƒÂ¥Ã‚Â½Ã¢â‚¬Å“ÃƒÂ¥Ã¢â‚¬Â°Ã¯Â¿Â½ÃƒÂ§Ã‚Â§Ã¯Â¿Â½ÃƒÂ§Ã‚Â¾Ã‚Â¤ÃƒÂ¤Ã‚Â»Ã‚Â£ÃƒÂ¦Ã¢â‚¬Â¢Ã‚Â°
	long int fAccumurateNumCh;			// ÃƒÂ¥Ã‚Â­Ã¯Â¿Â½ÃƒÂ¤Ã‚Â»Ã‚Â£ÃƒÂ§Ã‚Â´Ã‚Â¯ÃƒÂ¨Ã‚Â®Ã‚Â¡ÃƒÂ¦Ã¢â‚¬Â¢Ã‚Â°ÃƒÂ§Ã¢â‚¬ÂºÃ‚Â®

	int fBestNumOfGen;					// ÃƒÂ¥Ã‚Â½Ã¢â‚¬Å“ÃƒÂ¥Ã¢â‚¬Â°Ã¯Â¿Â½ÃƒÂ¦Ã…â€œÃ¢â€šÂ¬ÃƒÂ¤Ã‚Â¼Ã‹Å“ÃƒÂ¨Ã‚Â§Ã‚Â£ÃƒÂ¦Ã¢â‚¬Â°Ã¢â€šÂ¬ÃƒÂ¥Ã…â€œÃ‚Â¨ÃƒÂ§Ã…Â¡Ã¢â‚¬Å¾ÃƒÂ¤Ã‚Â»Ã‚Â£ÃƒÂ¦Ã¢â‚¬Â¢Ã‚Â°
	long int fBestAccumeratedNumCh;		// ÃƒÂ¥Ã‚Â½Ã¢â‚¬Å“ÃƒÂ¥Ã¢â‚¬Â°Ã¯Â¿Â½ÃƒÂ¦Ã…â€œÃ¢â€šÂ¬ÃƒÂ¤Ã‚Â¼Ã‹Å“ÃƒÂ¨Ã‚Â§Ã‚Â£ÃƒÂ§Ã…Â¡Ã¢â‚¬Å¾ÃƒÂ¥Ã‚Â­Ã¯Â¿Â½ÃƒÂ¤Ã‚Â»Ã‚Â£ÃƒÂ§Ã‚Â´Ã‚Â¯ÃƒÂ¨Ã‚Â®Ã‚Â¡ÃƒÂ¦Ã¢â‚¬Â¢Ã‚Â°ÃƒÂ§Ã¢â‚¬ÂºÃ‚Â®
	int **fEdgeFreq;					// ÃƒÂ§Ã‚Â§Ã¯Â¿Â½ÃƒÂ§Ã‚Â¾Ã‚Â¤ÃƒÂ§Ã…Â¡Ã¢â‚¬Å¾ÃƒÂ¨Ã‚Â¾Ã‚Â¹ÃƒÂ©Ã‚Â¢Ã¢â‚¬ËœÃƒÂ§Ã…Â½Ã¢â‚¬Â¡
	double fAverageValue;				// ÃƒÂ§Ã‚Â§Ã¯Â¿Â½ÃƒÂ§Ã‚Â¾Ã‚Â¤TSPÃƒÂ¨Ã‚Â·Ã‚Â¯ÃƒÂ¥Ã‚Â¾Ã¢â‚¬Å¾ÃƒÂ§Ã…Â¡Ã¢â‚¬Å¾ÃƒÂ¥Ã‚Â¹Ã‚Â³ÃƒÂ¥Ã¯Â¿Â½Ã¢â‚¬Â¡ÃƒÂ©Ã¢â‚¬Â¢Ã‚Â¿ÃƒÂ¥Ã‚ÂºÃ‚Â¦
	double fBestValue;						// ÃƒÂ§Ã‚Â§Ã¯Â¿Â½ÃƒÂ§Ã‚Â¾Ã‚Â¤ÃƒÂ¦Ã…â€œÃ¢â€šÂ¬ÃƒÂ¤Ã‚Â¼Ã‹Å“ÃƒÂ¨Ã‚Â§Ã‚Â£ÃƒÂ§Ã…Â¡Ã¢â‚¬Å¾ÃƒÂ¨Ã‚Â·Ã‚Â¯ÃƒÂ¥Ã‚Â¾Ã¢â‚¬Å¾ÃƒÂ©Ã¢â‚¬Â¢Ã‚Â¿ÃƒÂ¥Ã‚ÂºÃ‚Â¦  //int fBestValue;						// ÃƒÂ§Ã‚Â§Ã¯Â¿Â½ÃƒÂ§Ã‚Â¾Ã‚Â¤ÃƒÂ¦Ã…â€œÃ¢â€šÂ¬ÃƒÂ¤Ã‚Â¼Ã‹Å“ÃƒÂ¨Ã‚Â§Ã‚Â£ÃƒÂ§Ã…Â¡Ã¢â‚¬Å¾ÃƒÂ¨Ã‚Â·Ã‚Â¯ÃƒÂ¥Ã‚Â¾Ã¢â‚¬Å¾ÃƒÂ©Ã¢â‚¬Â¢Ã‚Â¿ÃƒÂ¥Ã‚ÂºÃ‚Â¦
	int fBestIndex;						// ÃƒÂ¦Ã…â€œÃ¢â€šÂ¬ÃƒÂ¤Ã‚Â¼Ã‹Å“ÃƒÂ§Ã‚Â§Ã¯Â¿Â½ÃƒÂ§Ã‚Â¾Ã‚Â¤ÃƒÂ§Ã…Â¡Ã¢â‚¬Å¾ÃƒÂ¤Ã‚Â¸Ã¢â‚¬Â¹ÃƒÂ¦Ã‚Â Ã¢â‚¬Â¡

	int* fIndexForMating;				// ÃƒÂ¤Ã‚ÂºÃ‚Â¤ÃƒÂ¥Ã¯Â¿Â½Ã¢â‚¬Â°ÃƒÂ¥Ã‹â€ Ã¢â‚¬â€�ÃƒÂ¨Ã‚Â¡Ã‚Â¨(r[])
	int fStagBest;						// ÃƒÂ¥Ã‚Â­Ã¯Â¿Â½ÃƒÂ¤Ã‚Â»Ã‚Â£ÃƒÂ¦Ã…â€œÃ¢â€šÂ¬ÃƒÂ¤Ã‚Â¼Ã‹Å“ÃƒÂ¨Ã‚Â§Ã‚Â£ÃƒÂ¦Ã‚Â²Ã‚Â¡ÃƒÂ¦Ã…â€œÃ¢â‚¬Â°ÃƒÂ¦Ã¯Â¿Â½Ã¯Â¿Â½ÃƒÂ¥Ã¯Â¿Â½Ã¢â‚¬Â¡ÃƒÂ§Ã…Â¡Ã¢â‚¬Å¾ÃƒÂ§Ã‚Â´Ã‚Â¯ÃƒÂ¨Ã‚Â®Ã‚Â¡ÃƒÂ¤Ã‚Â»Ã‚Â£ÃƒÂ¦Ã¢â‚¬Â¢Ã‚Â°
	int fFlagC[ 10 ];					// EAXÃƒÂ¦Ã¢â‚¬â€œÃ‚Â¹ÃƒÂ¥Ã‚Â¼Ã¯Â¿Â½ÃƒÂ¤Ã‚Â¸Ã…Â½ÃƒÂ©Ã¢â€šÂ¬Ã¢â‚¬Â°ÃƒÂ¦Ã¢â‚¬Â¹Ã‚Â©ÃƒÂ§Ã‚Â­Ã¢â‚¬â€œÃƒÂ§Ã¢â‚¬Â¢Ã‚Â¥
	int fStage;							// ÃƒÂ¥Ã‚Â½Ã¢â‚¬Å“ÃƒÂ¥Ã¢â‚¬Â°Ã¯Â¿Â½ÃƒÂ©Ã‹Å“Ã‚Â¶ÃƒÂ¦Ã‚Â®Ã‚Âµ
	int fMaxStagBest;					// fStagBest==fMaxStagBestÃƒÂ¦Ã¢â‚¬â€�Ã‚Â¶ÃƒÂ¦Ã¢â‚¬Â°Ã‚Â§ÃƒÂ¨Ã‚Â¡Ã…â€™ÃƒÂ¤Ã‚Â¸Ã¢â‚¬Â¹ÃƒÂ¤Ã‚Â¸Ã¢â€šÂ¬ÃƒÂ©Ã‹Å“Ã‚Â¶ÃƒÂ¦Ã‚Â®Ã‚Âµ
	int fCurNumOfGen1;					// Stage IÃƒÂ§Ã‚Â»Ã¢â‚¬Å“ÃƒÂ¦Ã¯Â¿Â½Ã…Â¸ÃƒÂ¦Ã¢â‚¬â€�Ã‚Â¶ÃƒÂ§Ã…Â¡Ã¢â‚¬Å¾ÃƒÂ§Ã‚Â§Ã¯Â¿Â½ÃƒÂ§Ã‚Â¾Ã‚Â¤ÃƒÂ¤Ã‚Â»Ã‚Â£ÃƒÂ¦Ã¢â‚¬Â¢Ã‚Â°

	clock_t fTimeStart, fTimeInit, fTimeEnd;	// ÃƒÂ¤Ã‚Â¿Ã¯Â¿Â½ÃƒÂ¥Ã‚Â­Ã‹Å“ÃƒÂ¨Ã‚Â®Ã‚Â¡ÃƒÂ§Ã‚Â®Ã¢â‚¬â€�ÃƒÂ¦Ã¢â‚¬â€�Ã‚Â¶ÃƒÂ©Ã¢â‚¬â€�Ã‚Â´
private:
	int no_improve;
	double change;
	int num_nodes;
};

#endif

The file evaluator.cpp contains:
/*
 * evaluator.cpp
 *   created on: April 24, 2013
 * last updated: June 13, 2013
 *       author: liushujia
 */

#ifndef __EVALUATOR__
#include "evaluator.h"
#endif
TEvaluator::TEvaluator(){
	fEdgeDis = NULL;
	fNearCity = NULL;
	Ncity = 0;
	fNearNumMax = 50;
}

TEvaluator::~TEvaluator(){
	for ( int i = 0; i < totalCity; ++i ) delete[] fEdgeDis[ i ];
	delete[] fEdgeDis;

	for ( int i = 0; i < totalCity; ++i ) delete[] fNearCity[ i ];
	delete[] fNearCity;

	delete [] x;
	delete [] y;
}
void TEvaluator::setInstance(int count ,int graph_type){
	totalCity=count;
	graph_t=graph_type;
	x = new double [ totalCity ];
	y = new double [ totalCity ];
	fEdgeDis = new double * [totalCity];
	for( int i = 0; i < totalCity; ++i ) fEdgeDis[ i ] = new double [ totalCity ];//fEdgeDis[ i ] = new int [ Ncity ];
	fNearCity = new int* [ totalCity ];
	for( int i = 0; i < totalCity; ++i ) fNearCity[ i ] = new int [ fNearNumMax+1 ];
}
void TEvaluator::setInstance1( int * given_sol,int count,double *x_coor,double *y_coor){
	Ncity=count;
	int *checkedN = new int[Ncity];// dynamic array with a probe
	for (int i=0;i<Ncity;++i)
	{
		x[i]=x_coor[given_sol[i]];
		y[i]=y_coor[given_sol[i]];
	}
	// calculate the distance matrix
	if (graph_t==1){
		for( int i = 0; i < Ncity ; ++i )
			for( int j = 0; j < Ncity ; ++j )
				fEdgeDis[ i ][ j ]=(sqrt((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j])));
	}
	if (graph_t==2){
		for( int i = 0; i < Ncity ; ++i )
			for( int j = 0; j < Ncity ; ++j ){
				double r = (sqrt(((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j]))/10.0));
				int t = (int)r;
				if( (double)t < r ) {
					fEdgeDis[ i ][ j ] = t+1;
				}
				else {
					fEdgeDis[ i ][ j ] = t;
				}
				//fEdgeDis[ i ][ j ]=ceil(sqrt((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j])));
			}
	}
	if (graph_t==3){
		for( int i = 0; i < Ncity ; ++i )
			for( int j = 0; j < Ncity ; ++j )
				fEdgeDis[ i ][ j ]=ceil(sqrt((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j])));
	}

	if (graph_t==4){
		double q1,q2,q3;
		double RRR = 6378.388;
		double latitude[Ncity];
		double longitude[Ncity];
		double min;
		double deg;
		double PI=3.141592;
		for (int i=0;i<Ncity;i++){
			deg=int(x[i]);
			min=x[i]-deg;
			latitude[i]=PI * (deg + 5.0 * min / 3.0 ) / 180.0;
			deg=int(y[i]);
			min=y[i]-deg;
			longitude[i]=PI * (deg + 5.0 * min / 3.0 ) / 180.0;
		}
		for (int i=0;i<Ncity;i++)
			for (int j=0;j<Ncity;j++){
				q1 = cos( longitude[i] - longitude[j] );
				q2 = cos( latitude[i] - latitude[j] );
				q3 = cos( latitude[i] + latitude[j] );
				fEdgeDis[i][j] = (int) ( RRR * acos( 0.5*((1.0+q1)*q2 - (1.0-q1)*q3) ) + 1.0);
			}
	}


	int ci, j1, j2, j3;
	int cityNum = 0;
	double minDis;
	//int minDis;
	for( ci = 0; ci < Ncity; ++ci ){      // find the neareat nodes for all nodes
		for( j3 = 0; j3 < Ncity; ++j3 ) checkedN[ j3 ] = 0;
		checkedN[ ci ] = 1;
		fNearCity[ ci ][ 0 ] = ci;
		for( j1 = 1; j1 <= fNearNumMax; ++j1 ) {
			minDis = 100000000;
			for( j2 = 0; j2 < Ncity; ++j2 ){
				if( fEdgeDis[ ci ][ j2 ] <= minDis && checkedN[ j2 ] == 0 ){
					cityNum = j2;
					minDis = fEdgeDis[ ci ][ j2 ];
				}
			}
			fNearCity[ ci ][ j1 ] = cityNum;
			checkedN[ cityNum ] = 1;
		}
	}
	delete [] checkedN;
}

void TEvaluator::doIt( TIndi& indi ){
	double d = 0;
	//int d = 0;
	for( int i = 0; i < Ncity; ++i ) d += fEdgeDis[ i ][ indi.fLink[i][0] ] + fEdgeDis[ i ][ indi.fLink[i][1] ];
	indi.fEvaluationValue = d/2;
}

void TEvaluator::writeTo( int * given_sol, TIndi& indi ){
	int *Array=new int[Ncity];
	int curr=0, st=0, count=0, pre=-1, next;
	while( 1 ){
		Array[ count++ ] = curr + 1;
		if( count > Ncity ){
			printf( "Invalid\n" );
			return;
		}
		if( indi.fLink[ curr ][ 0 ] == pre ) next = indi.fLink[ curr ][ 1 ];
		else next = indi.fLink[ curr ][ 0 ];

		pre = curr;
		curr = next;
		if( curr == st ) break;
	}
	if( this->checkValid( Array, indi.fEvaluationValue ) == false )
		printf( "Individual is invalid \n" );
	for( int i = 0; i < indi.fN; ++i )
		given_sol[i]=Array[i];
	delete [] Array;
}

bool TEvaluator::checkValid( int* array, double value ){
	int *check=new int[Ncity];
	for( int i = 0; i < Ncity; ++i ) check[ i ] = 0;
	for( int i = 0; i < Ncity; ++i ) ++check[ array[ i ]-1 ];
	for( int i = 0; i < Ncity; ++i )
		if( check[ i ] != 1 ) return false;
	double distance = 0;
	for( int i = 0; i < Ncity-1; ++i )
		distance += fEdgeDis[ array[ i ]-1 ][ array[ i+1 ]-1 ];

	distance += fEdgeDis[ array[ Ncity-1 ]-1 ][ array[ 0 ]-1 ];

	delete [] check;
	if( abs(distance - value)>1.0e-7 ) return false;
	//if( distance != value ) return false;
	return true;
}


The file evaluator.h contains:
/*
 * evaluator.h
 *   created on: April 24, 2013
 * last updated: June 13, 2013
 *       author: liushujia
 */

#ifndef __EVALUATOR__
#define __EVALUATOR__

#ifndef __INDI__
#include "indi.h"
#endif

#include <string.h>
#include <assert.h>

class TEvaluator{
public:
	TEvaluator();
	~TEvaluator();
	void setInstance(int count,int graph_type);		// è®¾ç½®å�˜é‡�
	void setInstance1( int * given_sol,int count,double *x_coor,double *y_coor);		// è®¾ç½®å�˜é‡�
	//void setInstance( char filename[] );		// è®¾ç½®å�˜é‡�
	void doIt( TIndi& indi );					// è®¾ç½®indi.fEvaluationValue
	void writeTo( int * given_sol, TIndi& indi );		// è¾“å‡ºTSPè·¯å¾„
	bool checkValid( int* array, double value );	// æ£€æŸ¥TSPè·¯å¾„å�ˆæ³•æ€§

	int fNearNumMax;	// è¿‘é‚»ç‚¹æ•°ç›®çš„æœ€å¤§å€¼
	int **fNearCity;	// NearCity[i][k]è¡¨ç¤ºè·�ç¦»iæœ€è¿‘çš„ç¬¬kä¸ªåŸŽå¸‚
	double **fEdgeDis;		// EdgeDis[i][j]è¡¨ç¤ºåŸŽå¸‚iåˆ°jçš„è·�ç¦»
	int Ncity;			// åŸŽå¸‚æ•°ç›®
	int totalCity;
	double *x;			// x[i]è¡¨ç¤ºç¬¬iä¸ªåŸŽå¸‚çš„xå��æ ‡
	double *y;			// y[i]è¡¨ç¤ºç¬¬iä¸ªåŸŽå¸‚çš„yå��æ ‡

	int graph_t;
//	int *Array;			// æœ€ä¼˜è§£çš„èŠ‚ç‚¹æ ‡å�·
};

#endif

The file indi.cpp contains:
/*
 * indi.cpp
 *   created on: April 24, 2013
 * last updated: June 13, 2013
 *       author: liushujia
 */


#ifndef __INDI__
#include "indi.h"
#endif

TIndi::TIndi(){
	fN = 0;
	fLink = NULL;
	fEvaluationValue = 0;
}

TIndi::~TIndi(){
	for ( int i = 0; i < total_fN; ++i ) delete[] fLink[ i ];
	delete[] fLink;
}
void TIndi::define1( int N ){
	fN = N;
}
void TIndi::define( int N ){
	total_fN=N;
	fLink = new int* [ total_fN ];
	for( int i = 0; i < total_fN; ++i ) fLink[ i ] = new int [ 2 ];
}

TIndi& TIndi::operator = ( const TIndi& src ){
	fN = src.fN;
	for ( int i = 0; i < fN; ++i )
		for ( int j = 0; j < 2; ++j ) fLink[i][j] = src.fLink[i][j];
	fEvaluationValue = src.fEvaluationValue;
	return *this;
}

bool TIndi::operator == ( const TIndi& src ){
	int curr, next, pre, flag_identify;

	if( fN != src.fN ) return false;
	if( fEvaluationValue != src.fEvaluationValue ) return false;

	curr = 0;
	pre = -1;
	for( int i = 0; i < fN; ++i ){
		if( fLink[curr][0] == pre ) next = fLink[curr][1];
		else next = fLink[curr][0];

		if( src.fLink[curr][0] != next && src.fLink[curr][1] != next ) return false;
		pre = curr;
		curr = next;
	}
	return true;
}


The file indi.h contains:
/*
 * indi.h
 *   created on: April 24, 2013
 * last updated: June 13, 2013
 *       author: liushujia
 */

#ifndef __INDI__
#define __INDI__

#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>

class TIndi{
public:
	TIndi();
	~TIndi();
	void define1( int N );
	void define( int N );
	TIndi& operator = ( const TIndi& src );
	bool operator == (  const TIndi& indi2 );	// åˆ¤æ–­ä¸¤è·¯å¾„æ˜¯å�¦ç›¸å�Œ

	int total_fN;
	int fN;						// åŸŽå¸‚æ•°ç›®
	int** fLink;				// fLink[i][]è¡¨ç¤ºè·¯å¾„ä¸­içš„ä¸¤ä¸ªç›¸é‚»çš„åŸŽå¸‚     double linked list
	double fEvaluationValue;		// TSPè·¯å¾„é•¿åº¦
	//int fEvaluationValue;		// TSPè·¯å¾„é•¿åº¦
};

#endif

The file Individual.cpp contains:
/*
 * Indi.cpp
 *
 *  Created on: 18 Apr 2020
 *      Author: Peng
 */

#include "Individual.h"

Individual::Individual() {

}
Individual::~Individual() {
	for (int i=0;i<=v_num-1;i++)
	{
		delete [] sol[i];
		delete [] sol_r[i];
	}
	delete [] sol;
	delete [] sol_r;
}
void Individual::define(int number_nodes,int number_vehicles){
	num_v=number_nodes;
	v_num=number_vehicles;
	sol=new int *[v_num];
	sol_r=new int *[v_num];
	for (int i=0;i<=v_num-1;i++)
	{
		sol[i]=new int [num_v+1];
		sol_r[i]=new int [num_v+1];
	}
}

The file Individual.h contains:
/*
 * Indi.h
 *
 *  Created on: 18 Apr 2020
 *      Author: Peng
 */

#ifndef INDIVIDUAL_H_
#define INDIVIDUAL_H_

class Individual {
public:
	Individual();
	virtual ~Individual();
	void define(int number_nodes,int number_vehicles);
	int ** sol;
	int ** sol_r;
	int num_v;
	int v_num;
	int num_s;
	double fitness;

};

#endif /* INDI_H_ */

The file initialsol.cpp contains:
/*
 * initialsol.cpp
 *
 *  Created on: 17 Apr 2020
 *      Author: Pengfei He
 */
#include "basic.h"
#include "initialsol.h"
initial_sol::initial_sol() {
}

initial_sol::~initial_sol() {
	// TODO Auto-generated destructor stub
}
void initial_sol::greedy_fun(){
	for (int i=0;i<=I_data->v_num-1;i++){
		for (int j=0;j<=I_data->num_v;j++)
			s->sol[i][j]=-1;
		s->sol[i][0]=0;
	}
	vector <  int > node;
	for (int i=1;i<=I_data->num_v;i++)
		node.push_back(i);
	random_shuffle(node.begin(), node.end());
	for (int i=0;i<=I_data->v_num-1;i++){
		s->sol[i][0]=node[i];
		s->sol[i][node[i]]=0;
	}
	int pointer,tem;
	int row,pos;double delta,delta_tem;
	int size_node=node.size();
	for (int i=I_data->v_num;i<=size_node-1;i++){
		delta=Max;
		int j=0;
//		for (int j=0;j<=I_data->v_num-1;j++){
			pointer=0;
			while(1){
				delta_tem=I_data->Distance[node[i]][pointer]+I_data->Distance[node[i]][s->sol[j][pointer]]-
						I_data->Distance[pointer][s->sol[j][pointer]];
				if (delta>delta_tem){
					row=j;
					pos=pointer;
					delta=delta_tem;
				}
				pointer=s->sol[j][pointer];
				if (pointer==0)break;
			}
//		}
		tem=s->sol[row][pos];
		s->sol[row][pos]=node[i];
		s->sol[row][node[i]]=tem;
	}
	s->fitness=0;
	for (int i=0;i<=I_data->v_num-1;i++){
		pointer=0;
		while (1){
			s->fitness+=I_data->Distance[s->sol[i][pointer]][pointer];
	//		cout<<pointer<<"  ";
			pointer=s->sol[i][pointer];
			if (pointer==0)
				break;
		}
//		cout<<endl;
	}
//	cout<<endl;





//	cout<<"the actuall cost is "<<s->fitness<<endl;

	// check the solution
	int count=0;
	for (int i=0;i<=I_data->v_num-1;i++){
		pointer=0;
		while(1){
			pointer=s->sol[i][pointer];
			if (pointer>0)count++;
			else break;
		}
	}
	if (!(count==I_data->num_v)){
		cout<<"initial solution is wrong"<<endl;
		exit(0);
	}
}

The file initialsol.h contains:
/*
 * initialsol.h
 *
 *  Created on: 17 Apr 2020
 *      Author: Peng
 */

#ifndef INITIALSOL_H_
#define INITIALSOL_H_
#include "read_data.h"
#include "Individual.h"
class initial_sol {
public:
	initial_sol();
	virtual ~initial_sol();
	void greedy_fun();
	Individual * s;
	read_data * I_data;
};

#endif /* INITIALSOL_H_ */

The file kopt.cpp contains:
/*
 * kopt.cpp
 *   created on: April 24, 2013
 * last updated: June 13, 2013
 *       author: liushujia
 */



#ifndef __KOPT__
#include "kopt.h"
#endif

TKopt::TKopt( int N ){
	total_fN = N;
	fLink = new int* [ total_fN ];
	for( int i = 0; i < total_fN; ++i ) fLink[ i ] = new int [ 2 ];

	fOrdCity = new int [ total_fN ];
	fOrdSeg = new int [ total_fN ];
	fSegCity = new int [ total_fN ];
	fOrient = new int [ total_fN ];
	fLinkSeg = new int* [ total_fN ];
	for( int i = 0; i < total_fN; ++i ) fLinkSeg[ i ] = new int [ 2 ];

	fSizeSeg = new int [ total_fN ];
	fCitySeg = new int* [ total_fN ];
	for( int i = 0; i < total_fN; ++i ) fCitySeg[ i ] = new int [ 2 ];

	fT = new int [ 5 ];
	fActiveV = new int [ total_fN ];
	fInvNearList = new int* [ total_fN ];
	for( int i = 0; i < total_fN; ++i ) fInvNearList[ i ] = new int [ 500 ];

	fNumOfINL = new int [ total_fN ];
	fArray = new int [ total_fN+2 ];
	fCheckN = new int [ total_fN ];
	fB = new int [ total_fN ];
	fGene = new int [ total_fN ];
}

TKopt::~TKopt(){
	for( int i = 0; i < total_fN; ++i ) delete [] fLink[ i ];
	delete [] fLink;

	for( int i = 0; i < total_fN; ++i ) delete [] fLinkSeg[ i ];
	delete [] fLinkSeg;

	for( int i = 0; i < total_fN; ++i ) delete [] fCitySeg[ i ];
	delete [] fCitySeg;

	for( int i = 0; i < total_fN; ++i ) delete [] fInvNearList[ i ];
	delete [] fInvNearList;

	delete [] fOrdCity;
	delete [] fOrdSeg;
	delete [] fSegCity;
	delete [] fOrient;
	delete [] fSizeSeg;
	delete [] fT;
	delete [] fActiveV;
	delete [] fNumOfINL;
	delete [] fArray;
	delete [] fCheckN;
	delete [] fB;
	delete [] fGene;
//	delete eval;
}
void TKopt::input_data(int N)
{
	fN=N;
}
void TKopt::setInvNearList(){
	for( int i = 0; i < fN; ++i ) fNumOfINL[ i ] = 0;
	int c;
	for( int i = 0; i < fN; ++i ){
		for( int k = 0; k < 50; ++k ){
			c = eval->fNearCity[i][k];
			if( fNumOfINL[c] < 500 ) fInvNearList[ c ][ fNumOfINL[c]++ ] = i;
			else{
				//printf( "Check fNumOfINL[c] < 500 ) in kopt.cpp \n" );
				//fflush( stdout );
			}
		}
	}
}

void TKopt::transIndiToTree( TIndi& indi ){
	int num, size, orient;
	fArray[1] = 0;
	for( int i = 2; i <= fN; ++i ) fArray[i] = indi.fLink[ fArray[i-1] ][ 1 ];

	fArray[0] = fArray[fN];
	fArray[fN+1] = fArray[1];
	num = 1;
	fNumOfSeg = 0;
	while(1){
		orient = 1;
		size = 0;
		fOrient[ fNumOfSeg ] = orient;
		fOrdSeg[ fNumOfSeg ] = fNumOfSeg;

		fLink[ fArray[ num ] ][ 0 ] = -1;
		fLink[ fArray[ num ] ][ 1 ] = fArray[ num+1 ];
		fOrdCity[ fArray[ num ] ] = size;
		fSegCity[ fArray[ num ] ] = fNumOfSeg;
		fCitySeg[ fNumOfSeg ][ this->turn(orient) ] = fArray[ num ];
		++num;
		++size;
		for( int i = 0; i < (int)sqrt( fN*1.0 )-1; ++i ){
			if( num == fN ) break;
			fLink[ fArray[ num ] ][ 0 ] = fArray[ num-1 ];
			fLink[ fArray[ num ] ][ 1 ] = fArray[ num+1 ];
			fOrdCity[ fArray[ num ] ] = size;
			fSegCity[ fArray[ num ] ] = fNumOfSeg;
			++num;
			++size;
		}
		if( num == fN-1 ){
			fLink[ fArray[ num ] ][ 0 ] = fArray[ num-1 ];
			fLink[ fArray[ num ] ][ 1 ] = fArray[ num+1 ];
			fOrdCity[ fArray[ num ] ] = size;
			fSegCity[ fArray[ num ] ] = fNumOfSeg;
			++num;
			++size;
		}
		fLink[ fArray[ num ] ][ 0 ] = fArray[ num-1 ];
		fLink[ fArray[ num ] ][ 1 ] = -1;
		fOrdCity[ fArray[ num ] ] = size;
		fSegCity[ fArray[ num ] ] = fNumOfSeg;
		fCitySeg[ fNumOfSeg ][ orient ] = fArray[ num ];
		++num;
		++size;
		fSizeSeg[ fNumOfSeg ] = size;
		++fNumOfSeg;
		if( num == fN+1 ) break;
	}
	for( int s = 1; s < fNumOfSeg-1; ++s ){
		fLinkSeg[ s ][ 0 ] = s-1;
		fLinkSeg[ s ][ 1 ] = s+1;
	}
	fLinkSeg[ 0 ][ 0 ] = fNumOfSeg-1;
	fLinkSeg[ 0 ][ 1 ] = 1;
	fLinkSeg[ fNumOfSeg-1 ][ 0 ] = fNumOfSeg-2;
	fLinkSeg[ fNumOfSeg-1 ][ 1 ] = 0;
	fTourLength = indi.fEvaluationValue;
	fFixNumOfSeg = fNumOfSeg;
}

void TKopt::transTreeToIndi( TIndi& indi ){
	int t_p, t_n;
	for( int t = 0; t < fN; ++t ){
		t_p = this->getPrev( t );
		t_n = this->getNext( t );
		indi.fLink[ t ][ 0 ] = t_p;
		indi.fLink[ t ][ 1 ] = t_n;
	}
	eval->doIt( indi );
}

void TKopt::doIt( TIndi& tIndi ){
	this->transIndiToTree( tIndi );
	this->sub();
	this->transTreeToIndi( tIndi );
}

void TKopt::sub(){
	int t1_st;
	double dis1, dis2;
	//int dis1, dis2;
	for( int t = 0; t < fN; ++t ) fActiveV[ t ] = 1;
BEGIN:
	t1_st = rand()%fN;// select a node randomly
	fT[1] = t1_st;
	//t1's loop
	while(1){
		fT[1] = this->getNext( fT[1] );
		if( fActiveV[ fT[1] ] == 0 ) goto RETURN;
		fFlagRev = 0;
		fT[2] = this->getPrev( fT[1] );
		for( int num1 = 1; num1 < 50; ++num1 ){
			fT[4] = eval->fNearCity[ fT[1] ][ num1 ];
			fT[3] = this->getPrev( fT[4] );
			dis1 = eval->fEdgeDis[fT[1]][fT[2]] - eval->fEdgeDis[fT[1]][fT[4]];
			if( dis1 > 1.0e-7 ){
				dis2 = dis1 + eval->fEdgeDis[fT[3]][fT[4]] - eval->fEdgeDis[fT[3]][fT[2]];
				if( dis2 > 1.0e-7 ){
					this->incrementImp( fFlagRev );// implement swap
					for( int a = 1; a <= 4; ++a )
						for( int k = 0; k < fNumOfINL[fT[a]]; ++k )
							fActiveV[ this->fInvNearList[fT[a]][k] ] = 1;
					goto BEGIN;
				}
			}
			else break;
		}
		fFlagRev = 1;
		fT[2] = this->getNext( fT[1] );
		for( int num1 = 1; num1 < 50; ++num1 ){
			fT[4] = eval->fNearCity[ fT[1] ][ num1 ];
			fT[3] = this->getNext( fT[4] );
			dis1 = eval->fEdgeDis[fT[1]][fT[2]] - eval->fEdgeDis[fT[1]][fT[4]];
			if( dis1 > 1.0e-7 ){
				dis2 = dis1 + eval->fEdgeDis[fT[3]][fT[4]] - eval->fEdgeDis[fT[3]][fT[2]];
				if( dis2 > 1.0e-7 ){
					this->incrementImp( fFlagRev );
					for( int a = 1; a <= 4; ++a )
						for( int k = 0; k < fNumOfINL[fT[a]]; ++k )
							fActiveV[ this->fInvNearList[fT[a]][k] ] = 1;
					goto BEGIN;
				}
			}
			else break;
		}
		fActiveV[ fT[1] ] = 0;
RETURN:
		if( fT[1] == t1_st ) break;
	}
}

int TKopt::getNext( int t ){
	int t_n, seg, orient;
	seg = fSegCity[ t ];
	orient = fOrient[ seg ];
	t_n = fLink[ t ][ orient ];
	if( t_n == -1 ){
		seg = fLinkSeg[ seg ][ orient ];
		orient = turn( fOrient[ seg ] );
		t_n = fCitySeg[ seg ][ orient ];
	}
	return t_n;
}

int TKopt::getPrev( int t ){
	int t_p, seg, orient;
	seg = fSegCity[ t ];
	orient = fOrient[ seg ];
	t_p = fLink[ t ][ this->turn( orient ) ];
	if( t_p == -1 ){
		seg = fLinkSeg[ seg ][ turn(orient) ];
		orient = fOrient[ seg ];
		t_p = fCitySeg[ seg ][ orient ];
	}
	return t_p;
}

void TKopt::swap(int &x, int &y){
	int s=x;
	x=y;
	y=s;
}

int TKopt::turn( int &orient ){
	return 1-orient;
}

void TKopt::incrementImp( int flagRev ){
	int t1_s, t1_e, t2_s, t2_e;
	int seg_t1_s, seg_t1_e, seg_t2_s, seg_t2_e;
	int ordSeg_t1_s, ordSeg_t1_e, ordSeg_t2_s, ordSeg_t2_e;
	int orient_t1_s, orient_t1_e, orient_t2_s, orient_t2_e;
	int numOfSeg1, numOfSeg2;
	int curr;
	int ord;

	int flag_t2e_t1s;
	int flag_t2s_t1e;
	int length_t1s_seg;
	int length_t1e_seg;
	int seg;

	if( fFlagRev == 0 ){
		t1_s = fT[1];
		t1_e = fT[3];
		t2_s = fT[4];
		t2_e = fT[2];
	}
	else if( fFlagRev == 1 ){
		t1_s = fT[2];
		t1_e = fT[4];
		t2_s = fT[3];
		t2_e = fT[1];
	}

	seg_t1_s = fSegCity[ t1_s ];
	ordSeg_t1_s = fOrdSeg[ seg_t1_s ];
	orient_t1_s = fOrient[ seg_t1_s ];
	seg_t1_e = fSegCity[ t1_e ];
	ordSeg_t1_e = fOrdSeg[ seg_t1_e ];
	orient_t1_e = fOrient[ seg_t1_e ];
	seg_t2_s = fSegCity[ t2_s ];
	ordSeg_t2_s = fOrdSeg[ seg_t2_s ];
	orient_t2_s = fOrient[ seg_t2_s ];
	seg_t2_e = fSegCity[ t2_e ];
	ordSeg_t2_e = fOrdSeg[ seg_t2_e ];
	orient_t2_e = fOrient[ seg_t2_e ];

	//////////////////// Type1 ////////////////////////
	if( ( seg_t1_s == seg_t1_e ) && ( seg_t1_s == seg_t2_s ) && ( seg_t1_s == seg_t2_e ) ){
		if( (fOrient[seg_t1_s] == 1 && (fOrdCity[ t1_s ] > fOrdCity[ t1_e ])) ||
			(fOrient[seg_t1_s] == 0 && (fOrdCity[ t1_s ] < fOrdCity[ t1_e ]))){
			this->swap( t1_s, t2_s );
			this->swap( t1_e, t2_e );
			this->swap( seg_t1_s, seg_t2_s );
			this->swap( seg_t1_e, seg_t2_e );
			this->swap( ordSeg_t1_s, ordSeg_t2_s );
			this->swap( ordSeg_t1_e, ordSeg_t2_e );
			this->swap( orient_t1_s, orient_t2_s );
			this->swap( orient_t1_e, orient_t2_e );
		}
		curr = t1_s;
		ord = fOrdCity[ t1_e ];
		while(1){
			this->swap( fLink[curr][0], fLink[curr][1] );
			fOrdCity[ curr ] = ord;
			if( curr == t1_e ) break;
			curr = fLink[curr][turn(orient_t1_s)];
			if( orient_t1_s == 0 ) ++ord;
			else --ord;
		}

		fLink[t2_e][orient_t1_s] = t1_e;
		fLink[t2_s][turn(orient_t1_s)] = t1_s;
		fLink[t1_s][orient_t1_s] = t2_s;
		fLink[t1_e][turn(orient_t1_s)] = t2_e;

		return;
	}
	//////////////////// Type1 ///////////////////////


	if( ordSeg_t1_e >= ordSeg_t1_s )	numOfSeg1 = ordSeg_t1_e - ordSeg_t1_s + 1;
	else								numOfSeg1 = ordSeg_t1_e - ordSeg_t1_s + 1 + fNumOfSeg;
	if( ordSeg_t2_e >= ordSeg_t2_s )	numOfSeg2 = ordSeg_t2_e - ordSeg_t2_s + 1;
	else								numOfSeg2 = ordSeg_t2_e - ordSeg_t2_s + 1 + fNumOfSeg;

	if( numOfSeg1 > numOfSeg2 ){
		this->swap( numOfSeg1, numOfSeg2 );
		this->swap( t1_s, t2_s );
		this->swap( t1_e, t2_e );
		this->swap( seg_t1_s, seg_t2_s );
		this->swap( seg_t1_e, seg_t2_e );
		this->swap( ordSeg_t1_s, ordSeg_t2_s );
		this->swap( ordSeg_t1_e, ordSeg_t2_e );
		this->swap( orient_t1_s, orient_t2_s );
		this->swap( orient_t1_e, orient_t2_e );
	}
	if( fLink[ t2_e ][ orient_t2_e ] == -1 ) flag_t2e_t1s = 1;
	else flag_t2e_t1s = 0;

	if( fLink[ t2_s ][ this->turn(orient_t2_s) ] == -1 ) flag_t2s_t1e = 1;
	else flag_t2s_t1e = 0;

	length_t1s_seg = abs( fOrdCity[ t2_e ] - fOrdCity[ fCitySeg[ seg_t2_e ][ orient_t2_e ] ] );
	length_t1e_seg = abs( fOrdCity[ t2_s ] - fOrdCity[ fCitySeg[ seg_t2_s ][ this->turn(orient_t2_s) ] ] );

	///////////////////// Type2 /////////////////
	if( seg_t1_s == seg_t1_e ){
		if( flag_t2e_t1s == 1 && flag_t2s_t1e == 1 ){
			orient_t1_s = turn( fOrient[ seg_t1_s ] );
			fOrient[ seg_t1_s ] = orient_t1_s;
			fCitySeg[ seg_t1_s ][ orient_t1_s ] = t1_s;
			fCitySeg[ seg_t1_s ][ turn(orient_t1_s) ] = t1_e;
			fLinkSeg[ seg_t1_s ][ orient_t1_s ] = seg_t2_s;
			fLinkSeg[ seg_t1_s ][ turn(orient_t1_s) ] = seg_t2_e;
			return;
		}
		if( flag_t2e_t1s == 0 && flag_t2s_t1e == 1 ){
			curr = t1_e;
			ord = fOrdCity[ t1_s ];
			while(1){
				this->swap( fLink[curr][0], fLink[curr][1] );
				fOrdCity[ curr ] = ord;
				if( curr == t1_s ) break;

				curr = fLink[curr][orient_t2_e];
				if( orient_t2_e == 0 ) --ord;
				else ++ord;
			}
			fLink[t2_e][orient_t2_e] = t1_e;
			fLink[t1_s][orient_t2_e] = -1;
			fLink[t1_e][turn(orient_t2_e)] = t2_e;
			fCitySeg[seg_t2_e][orient_t2_e] = t1_s;
			return;
		}
		if( flag_t2e_t1s == 1 && flag_t2s_t1e == 0 ){
			curr = t1_s;
			ord = fOrdCity[ t1_e ];
			while(1){
				this->swap( fLink[curr][0], fLink[curr][1] );
				fOrdCity[ curr ] = ord;
				if( curr == t1_e ) break;

				curr = fLink[curr][turn(orient_t2_s)];
				if( orient_t2_s == 0 ) ++ord;
				else --ord;
			}
			fLink[t2_s][turn(orient_t2_s)] = t1_s;
			fLink[t1_e][turn(orient_t2_s)] = -1;
			fLink[t1_s][orient_t2_s] = t2_s;
			fCitySeg[seg_t2_s][turn(orient_t2_s)] = t1_e;
			return;
		}
	}

	///////////////////// Type3 /////////////////

	if( flag_t2e_t1s == 1 ) fLinkSeg[seg_t1_s][turn(orient_t1_s)] = seg_t2_s;
	else{
		seg_t1_s = fNumOfSeg++;
		orient_t1_s = orient_t2_e;
		fLink[ t1_s ][turn(orient_t1_s)] = -1;
		fLink[ fCitySeg[seg_t2_e][orient_t2_e]][orient_t1_s] = -1;
		fOrient[seg_t1_s] = orient_t1_s;
		fSizeSeg[seg_t1_s] = length_t1s_seg;
		fCitySeg[seg_t1_s][turn(orient_t1_s)] = t1_s;
		fCitySeg[seg_t1_s][orient_t1_s] = fCitySeg[seg_t2_e][orient_t2_e];
		fLinkSeg[seg_t1_s][turn(orient_t1_s)] = seg_t2_s;
		fLinkSeg[seg_t1_s][orient_t1_s] = fLinkSeg[seg_t2_e][orient_t2_e];
		seg = fLinkSeg[seg_t2_e][orient_t2_e];
		fLinkSeg[seg][turn(fOrient[seg])] = seg_t1_s;
	}

	if( flag_t2s_t1e == 1 ) fLinkSeg[seg_t1_e][orient_t1_e] = seg_t2_e;
	else{
		seg_t1_e = fNumOfSeg++;
		orient_t1_e = orient_t2_s;
		fLink[ t1_e ][orient_t1_e] = -1;
		fLink[ fCitySeg[seg_t2_s][turn(orient_t2_s)] ][turn(orient_t1_e)] = -1;
		fOrient[seg_t1_e] = orient_t1_e;
		fSizeSeg[seg_t1_e] = length_t1e_seg;
		fCitySeg[seg_t1_e][orient_t1_e] = t1_e;
		fCitySeg[seg_t1_e][turn(orient_t1_e)] = fCitySeg[seg_t2_s][turn(orient_t2_s)];
		fLinkSeg[seg_t1_e][orient_t1_e] = seg_t2_e;
		fLinkSeg[seg_t1_e][turn(orient_t1_e)] = fLinkSeg[seg_t2_s][turn(orient_t2_s)];
		seg = fLinkSeg[seg_t2_s][turn(orient_t2_s)];
		fLinkSeg[seg][fOrient[seg]] = seg_t1_e;
	}

	fLink[t2_e][orient_t2_e] = -1;
	fSizeSeg[seg_t2_e] -= length_t1s_seg;
	fCitySeg[seg_t2_e][orient_t2_e] = t2_e;
	fLinkSeg[seg_t2_e][orient_t2_e] = seg_t1_e;
	fLink[t2_s][turn(orient_t2_s)] = -1;
	fSizeSeg[seg_t2_s] -= length_t1e_seg;
	fCitySeg[seg_t2_s][turn(orient_t2_s)] = t2_s;
	fLinkSeg[seg_t2_s][turn(orient_t2_s)] = seg_t1_s;

	seg = seg_t1_e;
	while(1){
		fOrient[seg] = turn(fOrient[seg]);
		if( seg == seg_t1_s ) break;
		seg = fLinkSeg[seg][fOrient[seg]];
	}

	if( fSizeSeg[seg_t2_e] < length_t1s_seg ){
		seg = fLinkSeg[seg_t2_e][turn(fOrient[seg_t2_e])];
		fLinkSeg[seg][fOrient[seg]] = seg_t1_s;
		seg = fLinkSeg[seg_t2_e][fOrient[seg_t2_e]];
		fLinkSeg[seg][turn(fOrient[seg])] = seg_t1_s;
		seg = fLinkSeg[seg_t1_s][turn(fOrient[seg_t1_s])];
		fLinkSeg[seg][fOrient[seg]] = seg_t2_e;
		seg = fLinkSeg[seg_t1_s][fOrient[seg_t1_s]];
		fLinkSeg[seg][turn(fOrient[seg])] = seg_t2_e;

		this->swap( fOrient[seg_t2_e], fOrient[seg_t1_s] );
		this->swap( fSizeSeg[seg_t2_e], fSizeSeg[seg_t1_s] );
		this->swap( fCitySeg[seg_t2_e][0], fCitySeg[seg_t1_s][0] );
		this->swap( fCitySeg[seg_t2_e][1], fCitySeg[seg_t1_s][1] );
		this->swap( fLinkSeg[seg_t2_e][0], fLinkSeg[seg_t1_s][0] );
		this->swap( fLinkSeg[seg_t2_e][1], fLinkSeg[seg_t1_s][1] );
		this->swap( seg_t2_e, seg_t1_s );
	}

	if( fSizeSeg[seg_t2_s] < length_t1e_seg ){
		seg = fLinkSeg[seg_t2_s][turn(fOrient[seg_t2_s])];
		fLinkSeg[seg][fOrient[seg]] = seg_t1_e;
		seg = fLinkSeg[seg_t2_s][fOrient[seg_t2_s]];
		fLinkSeg[seg][turn(fOrient[seg])] = seg_t1_e;
		seg = fLinkSeg[seg_t1_e][turn(fOrient[seg_t1_e])];
		fLinkSeg[seg][fOrient[seg]] = seg_t2_s;
		seg = fLinkSeg[seg_t1_e][fOrient[seg_t1_e]];
		fLinkSeg[seg][turn(fOrient[seg])] = seg_t2_s;

		this->swap( fOrient[seg_t2_s], fOrient[seg_t1_e] );
		this->swap( fSizeSeg[seg_t2_s], fSizeSeg[seg_t1_e] );
		this->swap( fCitySeg[seg_t2_s][0], fCitySeg[seg_t1_e][0] );
		this->swap( fCitySeg[seg_t2_s][1], fCitySeg[seg_t1_e][1] );
		this->swap( fLinkSeg[seg_t2_s][0], fLinkSeg[seg_t1_e][0] );
		this->swap( fLinkSeg[seg_t2_s][1], fLinkSeg[seg_t1_e][1] );
		this->swap( seg_t2_s, seg_t1_e );
	}

	while( fNumOfSeg > fFixNumOfSeg ){
	if( fSizeSeg[ fLinkSeg[fNumOfSeg-1][0] ] <
		fSizeSeg[ fLinkSeg[fNumOfSeg-1][1] ] )
		this->combineSeg( fLinkSeg[fNumOfSeg-1][0], fNumOfSeg-1 );
	else
		this->combineSeg( fLinkSeg[fNumOfSeg-1][1], fNumOfSeg-1 );
	}
	int ordSeg = 0;
	seg = 0;
	while(1){
		fOrdSeg[seg] = ordSeg;
		++ordSeg;
		seg = fLinkSeg[seg][ fOrient[seg] ];
		if( seg == 0 ) break;
	}
  return;
}

void TKopt::combineSeg( int segL, int segS ){
	int seg;
	int t_s, t_e, direction; t_s = 0; t_e = 0; direction = 0;
	int ord; ord = 0;
	int increment; increment = 0;
	int curr, next;

	if( fLinkSeg[segL][fOrient[segL]] == segS ){
		fLink[fCitySeg[segL][fOrient[segL]]][fOrient[segL]] = fCitySeg[segS][turn(fOrient[segS])];
		fLink[fCitySeg[segS][turn(fOrient[segS])]][turn(fOrient[segS])] = fCitySeg[segL][fOrient[segL]];
		ord = fOrdCity[fCitySeg[segL][fOrient[segL]]];

		fCitySeg[segL][fOrient[segL]] = fCitySeg[segS][fOrient[segS]];
		fLinkSeg[segL][fOrient[segL]] = fLinkSeg[segS][fOrient[segS]];
		seg = fLinkSeg[segS][fOrient[segS]];
		fLinkSeg[seg][turn(fOrient[seg])] = segL;

		t_s = fCitySeg[segS][turn(fOrient[segS])];
		t_e = fCitySeg[segS][fOrient[segS]];
		direction = fOrient[segS];

		if( fOrient[segL] == 1 ) increment = 1;
		else increment = -1;
	}
	else if( fLinkSeg[segL][turn(fOrient[segL])] == segS ){
		fLink[fCitySeg[segL][turn(fOrient[segL])]][turn(fOrient[segL])] = fCitySeg[segS][fOrient[segS]];
		fLink[fCitySeg[segS][fOrient[segS]]][fOrient[segS]] = fCitySeg[segL][turn(fOrient[segL])];
		ord = fOrdCity[fCitySeg[segL][turn(fOrient[segL])]];

		fCitySeg[segL][turn(fOrient[segL])] = fCitySeg[segS][turn(fOrient[segS])];
		fLinkSeg[segL][turn(fOrient[segL])] = fLinkSeg[segS][turn(fOrient[segS])];
		seg = fLinkSeg[segS][turn(fOrient[segS])];
		fLinkSeg[seg][fOrient[seg]] = segL;

		t_s = fCitySeg[segS][fOrient[segS]];
		t_e = fCitySeg[segS][turn(fOrient[segS])];
		direction = turn(fOrient[segS]);

		if( fOrient[segL] == 1 ) increment = -1;
		else increment = 1;
	}
	curr = t_s;
	ord = ord + increment;
	while(1){
		fSegCity[curr] = segL;
		fOrdCity[curr] = ord;

		next = fLink[curr][direction];
		if( fOrient[segL] != fOrient[segS] ) this->swap( fLink[curr][0], fLink[curr][1] );

		if( curr == t_e ) break;
		curr = next;
		ord += increment;
	}
	fSizeSeg[segL] += fSizeSeg[segS];
	--fNumOfSeg;
}

void TKopt::checkDetail(){
	int seg, seg_p, seg_n;
	int ord, ord_p, ord_n;
	int orient;
	int curr;

	seg = 0;
	for( int s = 0; s < fNumOfSeg; ++s ){
		seg = s;
		orient = fOrient[ seg ];
		seg_p = fLinkSeg[ seg ][ this->turn(orient) ];
		seg_n = fLinkSeg[ seg ][ orient ];

		ord = fOrdSeg[ seg ];
		ord_p = ord - 1 ;
		if( ord_p < 0 ) ord_p = fNumOfSeg - 1;

		ord_n = ord + 1;
		if( ord_n >= fNumOfSeg ) ord_n = 0;

		curr = fCitySeg[ s ][ 0 ];
		int count = 0;

		while(1){
			++count;
			if( curr == fCitySeg[ s ][1] ) break;
			curr = fLink[curr][1];
		}
	}
	int t, t_n, t_p, t_s, t_e;
	for( t = 0; t < fN; ++t ){
		seg = fSegCity[ t ];
		orient = fOrient[ seg ];
		t_s = fCitySeg[ seg ][ 0 ];
		t_e = fCitySeg[ seg ][ 1 ];

		t_p = fLink[ t ][ 0 ];
		t_n = fLink[ t ][ 1 ];
	}
}

void TKopt::checkValid(){
	int t_st, t_c, t_n, count, seg, orient, Invalid = 0;
	for( int i = 0; i < fN; ++i ) fCheckN[ i ] = 0;

	t_st = rand() % fN;
	t_n = t_st;
	count = 0;
	while(1){
		t_c = t_n;
		fCheckN[ t_c ] = 1;
		++count;

		seg = fSegCity[ t_c ];
		orient = fOrient[ seg ];
		t_n = this->getNext( t_c );

		if( t_n == t_st ) break;

		if( count == fN+1 ){
			Invalid = 1;
			break;
		}
	}
	for( int i = 0; i < fN; ++i )
		if( fCheckN[ i ] == 0 ) Invalid = 1;

	if( Invalid == 1 ) printf( "Invalid \n" ); fflush( stdout );

}

void TKopt::makeRandSol( TIndi& indi ){
	for( int j = 0; j < fN; ++j ) fB[j] = j;
	int r;
	for( int i = 0; i < fN; ++i ){
		r = rand() % (fN-i);
		fGene[i] = fB[r];
		fB[r] = fB[fN-i-1];
	}

	for( int j2 = 1 ; j2 < fN-1; ++j2 ){
		indi.fLink[fGene[j2]][0] = fGene[j2-1];
		indi.fLink[fGene[j2]][1] = fGene[j2+1];
	}
	indi.fLink[fGene[0]][0] = fGene[fN-1];
	indi.fLink[fGene[0]][1] = fGene[1];
	indi.fLink[fGene[fN-1]][0] = fGene[fN-2];
	indi.fLink[fGene[fN-1]][1] = fGene[0];

	eval->doIt( indi );
}


The file kopt.h contains:
/*
 * kopt.h
 *   created on: April 24, 2013
 * last updated: June 13, 2013
 *       author: liushujia
 */

#ifndef __KOPT__
#define __KOPT__

#ifndef __RAND__
#include "randomize.h"
#endif

#ifndef __Sort__
#include "sort.h"
#endif

#ifndef __INDI__
#include "indi.h"
#endif

#ifndef __EVALUATOR__
#include "evaluator.h"
#endif

#include <stdio.h>
#include <stdlib.h>
#include <assert.h>

class TKopt{
public:
	TKopt( int N );
	~TKopt();
	void input_data(int N);
	void setInvNearList();
	void transIndiToTree( TIndi& indi );
	void transTreeToIndi( TIndi& indi );
	void doIt( TIndi& tIndi );			// å±€éƒ¨æ�œç´¢(2-opt neighborhood)

	int getNext( int t );
	int getPrev( int t );
	int turn( int &orient );

	void sub();
	void incrementImp( int flagRev );
	void combineSeg( int segL, int segS );

	void checkDetail();
	void checkValid();
	void swap(int &x, int &y);
	void makeRandSol( TIndi& indi );		// è®¾ç½®éš�æœºè·¯ç¨‹

	TEvaluator* eval;

private:
	int fN;
	int total_fN;
	int fFixNumOfSeg;
	int fNumOfSeg;
	int fFlagRev;
	double fTourLength;
	//int fTourLength;

	int **fLink;
	int **fLinkSeg;
	int **fCitySeg;
	int **fInvNearList;

	int *fT;
	int *fB;
	int *fSegCity;
	int *fOrdCity;
	int *fOrdSeg;
	int *fOrient;
	int *fSizeSeg;
	int *fActiveV;
	int *fNumOfINL;
	int *fArray;
	int *fCheckN;
	int *fGene;
};

#endif

The file LS.cpp contains:
/*
 * LS.cpp
 *
 *  Created on: 18 Apr 2020
 *      Author: Peng
 */

#include "LS.h"
#include "basic.h"
#include "Tstwoopt.h"
#include "EAX.h"
#include "environment.h"
#include "Individual.h"
LS::LS(read_data * data) {
	num_v=data->num_v;
	v_num=data->v_num;
	tem=new Individual();
	tem->define(num_v,v_num);
	each_route=new Tstwoopt (data);
	each_route->I_data=data;
	record_table=new int [v_num];
	s_t=new int [num_v+1];
	cand_str1=new int *[length_s*length_s];
	cand_str2=new int *[length_s*length_s];
	for (int i=0;i<=length_s*length_s-1;i++){
		cand_str1[i]=new int [length_s];
		cand_str2[i]=new int [length_s];
	}
	cand_fit=new double [length_s*length_s];
	near_cand1=new int *[num_near_nodes];
	for (int i=0;i<=num_near_nodes-1;i++)
		near_cand1[i]=new int [6];
	near_fit=new double [num_near_nodes];
	rever_list=new int [length_s*length_s];
	// tabu search variables
	tabu_table=new int *[v_num];
	tabu_table_c=new int *[v_num];
	for (int i=0;i<=v_num-1;i++){
		tabu_table[i]=new int [num_v+1];
		tabu_table_c[i]=new int [num_v+1];
	}
}
LS::~LS() {
	delete tem;
	delete each_route;
	delete [] record_table;
	delete [] s_t;
	for (int i=0;i<=length_s*length_s-1;i++){
		delete [] cand_str1[i];
		delete [] cand_str2[i];
	}
	delete [] cand_str1;
	delete [] cand_str2;
	delete [] cand_fit;
	for (int i=0;i<=num_near_nodes-1;i++)
		delete [] near_cand1[i];
	delete [] near_cand1;
	delete [] near_fit;
	delete [] rever_list;
	for (int i=0;i<=v_num-1;i++){
		delete [] tabu_table[i];
		delete [] tabu_table_c[i];
	}
	delete [] tabu_table;
	delete [] tabu_table_c;
}
void LS::update_best_solution(){
	if (s->fitness < b_s->fitness){
		for (int i=0;i<=v_num-1;i++)
			for (int j=0;j<=num_v;j++){
				b_s->sol[i][j]=s->sol[i][j];
				b_s->sol_r[i][j]=s->sol_r[i][j];
			}
		b_s->fitness=s->fitness;
	}
}
void LS::supply_edge(){
	int p;
	for (int i=0;i<v_num;i++){
		p=0;
		while(1){
			I_data->edge[p][b_s->sol[i][p]]=1;
			p=b_s->sol[i][p];
			if (p==0)break;
		}
	}
}
void LS::reverse_fun(){// get value for sol_r;
	int pointer;
	vector<int >tour;
	for (int i=0;i<=v_num-1;i++)	{
		pointer=s->sol[i][0];
		while (pointer!=0)		{
			tour.push_back(pointer);
			pointer=s->sol[i][pointer];
		}
		s->sol_r[i][0]=tour.back();
		tour.pop_back();
		pointer=s->sol_r[i][0];
		while (tour.size())		{
			s->sol_r[i][pointer]=tour.back();
			pointer=s->sol_r[i][pointer];
			tour.pop_back();
		}
		s->sol_r[i][pointer]=0;
	}
}
void LS::replace_fun(int *move){
	int string1[length_s];
	int string2[length_s];
	for (int i=0;i<=length_s-1;i++){
		string1[i]=-1;
		string2[i]=-1;
	}
	int count1=0;
	int row1=move[5];
	int row2=s_t[move[2]];
	while(1){
		if (move[0]!=move[1]){
			string1[count1]=move[0];
			count1++;
			move[0]=s->sol[row1][move[0]];
		}
		else{
			string1[count1]=move[1];count1++;
			break;
		}
	}
	int count2=0;
	while (1){
		if (move[2]!=move[3]){
			string2[count2]=move[2];
			count2++;
			if (move[4]==1)
				move[2]=s->sol[row2][move[2]];
			else
				move[2]=s->sol_r[row2][move[2]];
		}
		else{
			string2[count2]=move[3];count2++;
			break;
		}
	}
	I_data->use_frequency[count1-1][count2-1]=I_data->use_frequency[count1-1][count2-1]+1;
	if (cross_exchange_identify==1){
		for (int i=1;i<=count1-1;i++){
			s_t[string1[i]]=row2;
		}
		for (int i=0;i<=count2-1;i++){
			s_t[string2[i]]=row1;
		}
	}
	if (cross_exchange_identify==2){
		for (int i=1;i<=count1-1;i++){
			tabu_table[s_t[string1[i]]][string1[i]]=iteration + tabu_l+rand()%tabu_l;// tabu
			s_t[string1[i]]=row2;
		}
		for (int i=0;i<=count2-1;i++){
			tabu_table[s_t[string2[i]]][string2[i]]=iteration + tabu_l+rand()%tabu_l;// tabu
			s_t[string2[i]]=row1;
		}
	}

	int start1=string1[0];
	int start11=start1;
	int end1=s->sol[row1][string1[count1-1]];
	int end11=end1;
	int start2,end2,start22;
	if (move[4]==1){//whether reverse 1 is not and 0 is true
		start2=s->sol_r[row2][string2[0]];
		end2=s->sol[row2][string2[count2-1]];
		start22=start2;
		for (int i=1;i<=count1-1;i++){
			s->sol[row1][string1[i]]=-1;
			s->sol_r[row1][string1[i]]=-1;
		}
		for (int i=0;i<=count2-1;i++){
			s->sol[row2][string2[i]]=-1;
			s->sol_r[row2][string2[i]]=-1;
		}
		for (int i=0;i<=count2-1;i++){
			s->sol[row1][start1]=string2[i];
			start1=string2[i];
		}
		s->sol[row1][start1]=end11;
		for(int i=1;i<=count1-1;i++){
			s->sol[row2][start2]=string1[i];
			start2=string1[i];
		}
		s->sol[row2][start2]=end2;
		// for sol_r
		for (int i=count2-1;i>=0;i--){
			s->sol_r[row1][end1]=string2[i];
			end1=string2[i];
		}
		s->sol_r[row1][end1]=start11;
		for (int i=count1-1;i>=1;i--){
			s->sol_r[row2][end2]=string1[i];
			end2=string1[i];
		}
		s->sol_r[row2][end2]=start22;
	}
	else{
		start2=s->sol[row2][string2[0]];
		end2=s->sol_r[row2][string2[count2-1]];
		start22=start2;
		for (int i=1;i<=count1-1;i++){
			s->sol[row1][string1[i]]=-1;
			s->sol_r[row1][string1[i]]=-1;
		}
		for (int i=0;i<=count2-1;i++){
			s->sol[row2][string2[i]]=-1;
			s->sol_r[row2][string2[i]]=-1;
		}
		for (int i=0;i<=count2-1;i++){
			s->sol[row1][start1]=string2[i];
			start1=string2[i];
		}
		s->sol[row1][start1]=end11;
		for(int i=1;i<=count1-1;i++){
			s->sol_r[row2][start2]=string1[i];
			start2=string1[i];
		}
		s->sol_r[row2][start2]=end2;
		// for sol_r
		for (int i=count2-1;i>=0;i--){
			s->sol_r[row1][end1]=string2[i];
			end1=string2[i];
		}
		s->sol_r[row1][end1]=start11;
		for (int i=count1-1;i>=1;i--){
			s->sol[row2][end2]=string1[i];
			end2=string1[i];
		}
		s->sol[row2][end2]=start22;
	}
}
void LS::intra_route_optimization(){// this method will include many methods to optimize each route, such as 2-opt, Lk and EAX.
	int pointer;
	tem->fitness=s->fitness;
	for (int i=0;i<=v_num-1;i++)
		for (int j=0;j<=num_v;j++){
			tem->sol[i][j]=s->sol[i][j];
			tem->sol_r[i][j]=s->sol_r[i][j];
		}
	int number_routes[v_num];
	int route[num_v+1];
	for (int i=0;i<=v_num-1;i++){
		if (record_table[i]==1){
			record_table[i]=0;
			pointer=s->sol[i][0];number_routes[i]=0;
			route[number_routes[i]]=0;number_routes[i]++;
			while (1){
				if (pointer==0)
					break;
				else{
					route[number_routes[i]]=pointer;
					number_routes[i]++;
					pointer=s->sol[i][pointer];
				}
			}
			int sub_route[number_routes[i]];
			for (int j=0;j<=number_routes[i]-1;j++)
				sub_route[j]=route[j];
			if (intra_opt==1)
				each_route->twoopt(sub_route,number_routes[i]);
			if (intra_opt==3 && number_routes[i]>4){
					EAX(gEnv, sub_route,number_routes[i],I_data->x,I_data->y);
			}
			pointer=0;
			for (int j=1;j<=number_routes[i]-1;j++){
				tem->sol[i][pointer]=sub_route[j];
				pointer=tem->sol[i][pointer];
			}
			tem->sol[i][pointer]=0;
			pointer=0;
			for (int j=number_routes[i]-1;j>=1;j--){
				tem->sol_r[i][pointer]=sub_route[j];
				pointer=tem->sol_r[i][pointer];
			}
			tem->sol_r[i][pointer]=0;
		}
		else
			continue;
	}
	double current_cost=0;
	for (int i=0;i<=v_num-1;i++){
		pointer=0;
		while (1){
			current_cost+=I_data->Distance[pointer][tem->sol[i][pointer]];
			if (tem->sol[i][pointer]==0)
				break;
			else
				pointer=tem->sol[i][pointer];
		}
	}
	if (current_cost<s->fitness){
		s->fitness=current_cost;
		for (int i=0;i<=v_num-1;i++)
			for (int j=0;j<=num_v;j++){
				s->sol[i][j]=tem->sol[i][j];
				s->sol_r[i][j]=tem->sol_r[i][j];
			}
	}
	//update_best_solution();
}
void LS::replace_fun_insert(double min_delta,int row_out,int city_out,int row_in,int city_in){
	int n_p,p_p;
	s->fitness+=min_delta;
	n_p=s->sol[row_out][city_out];
	p_p=s->sol_r[row_out][city_out];
	s->sol[row_out][p_p]=n_p;
	s->sol_r[row_out][n_p]=p_p;
	s->sol[row_out][city_out]=-1;
	s->sol_r[row_out][city_out]=-1;
	//
	n_p=s->sol[row_in][city_in];
	s->sol[row_in][city_in]=city_out;
	s->sol[row_in][city_out]=n_p;
	s->sol_r[row_in][n_p]=city_out;
	s->sol_r[row_in][city_out]=city_in;
}
double LS::calculate_fit_insert(int row_out,int city_out,int row_in,int city_in){
	double delta=0;
	delta+=I_data->Distance[s->sol_r[row_out][city_out]][s->sol[row_out][city_out]];
	delta=delta-I_data->Distance[s->sol_r[row_out][city_out]][city_out];
	delta=delta-I_data->Distance[s->sol[row_out][city_out]][city_out];
	//
	delta+=I_data->Distance[city_in][city_out]+I_data->Distance[city_out][s->sol[row_in][city_in]];
	delta=delta-I_data->Distance[city_in][s->sol[row_in][city_in]];
	return delta;
}
void LS::insert(){// this function is used to implement a simple inserting operation
	int pointer,pointer_2;
	int row_out,city_out,row_in,city_in;
	double delta,min_delta;
	while (1){
		min_delta=Max;
		for (int i=0;i<=v_num-1;i++){
			pointer=s->sol[i][0];
			if (s->sol_r[i][pointer]==0 && s->sol[i][pointer]==0)
				continue;
			while(1){
				for (int j=0;j<=v_num-1;j++){
					if (j==i)continue;
					pointer_2=0;
					while(1){
						//////////////
						if (I_data->edge[pointer][pointer_2]!=1){
							pointer_2=s->sol[j][pointer_2];
							if (pointer_2==0)break;
							else continue;
						}
						//////////////
						delta=calculate_fit_insert(i,pointer,j,pointer_2);
						if (delta<min_delta){
							min_delta=delta;
							row_out=i;
							city_out=pointer;
							row_in=j;
							city_in=pointer_2;
						}
						pointer_2=s->sol[j][pointer_2];
						if (pointer_2==0)break;
					}
				}
				pointer=s->sol[i][pointer];
				if (pointer==0)break;
			}
		}
		if (min_delta+1.0e-7>0)break;
		replace_fun_insert(min_delta,row_out,city_out,row_in,city_in);
		record_table[row_out]=1;
		record_table[row_in]=1;
		if (ceil((clock()-I_data->start)/static_cast<double>(CLOCKS_PER_SEC))>=time_length)
			break;
	}
}

double LS::gain_fun(int st1,int end1,int row1,int st2,int end2,int row2,int k, int reverse){
	double fitn=0;
	if (k==0 && reverse==1)// forward
		fitn+=I_data->Distance[st2][s->sol_r[s_t[st2]][st2]]+I_data->Distance[end2][s->sol[s_t[end2]][end2]]-
			I_data->Distance[s->sol_r[s_t[st2]][st2]][s->sol[s_t[end2]][end2]]-I_data->Distance[end2][s->sol[row1][st1]];
	if (k==0 && reverse==0)// reverse
		fitn+=I_data->Distance[st2][s->sol[s_t[st2]][st2]]+I_data->Distance[end2][s->sol_r[s_t[end2]][end2]]-
			I_data->Distance[s->sol[s_t[st2]][st2]][s->sol_r[s_t[end2]][end2]]-I_data->Distance[end2][s->sol[row1][st1]];
	if (k!=0 && reverse==1)
		fitn+=I_data->Distance[st2][s->sol_r[s_t[st2]][st2]]+I_data->Distance[end2][s->sol[s_t[end2]][end2]]+
			I_data->Distance[end1][s->sol[s_t[end1]][end1]]-I_data->Distance[s->sol_r[s_t[st2]][st2]][s->sol[row1][st1]]-
			I_data->Distance[s->sol[s_t[end2]][end2]][end1]-I_data->Distance[end2][s->sol[s_t[end1]][end1]];
	if (k!=0 && reverse==0)
		fitn+=I_data->Distance[st2][s->sol[s_t[st2]][st2]]+I_data->Distance[end2][s->sol_r[s_t[end2]][end2]]+
			I_data->Distance[end1][s->sol[s_t[end1]][end1]]-I_data->Distance[s->sol[s_t[st2]][st2]][s->sol[row1][st1]]-
			I_data->Distance[s->sol_r[s_t[end2]][end2]][end1]-I_data->Distance[end2][s->sol[s_t[end1]][end1]];
	return fitn;
}

void LS:: cross_exchange_1(){
	int pointer;
	for (int i=0;i<=v_num-1;i++){
		pointer=s->sol[i][0];
		while (pointer!=0){
			s_t[pointer]=i;
			pointer=s->sol[i][pointer];
		}
	}
	double gi;int j;int in_num;
	int end2,end1;int count;double tem;
	int better_move[6];double better_fit;
	int reverse;
	int step=0;
	int identify;int identify2;
	while (1){
		better_fit=0;step++;
		for (int i=0;i<=v_num-1;i++){
			//pointer=s->sol[i][0];
			pointer=0;
			identify=1;
			while(1){
				if (pointer==0 && identify==0){identify=0;break;}
				else{
					c=0;
					//////////////////////////////////////////////////////
					for (j=1;j<=num_v;j++){
						in_num=-1;
						if(I_data->edge[pointer][j]==1){
							if (i!=s_t[j])
								in_num=j;
						}
					//////////////////////////////////////////////////////
						if (in_num==-1)continue;
						count=0;
						gi=0;//
						gi+=I_data->Distance[pointer][s->sol[i][pointer]];
						gi=gi-I_data->Distance[pointer][in_num];
						if (1){// case 1
							end1=pointer;identify2=1;
							for (int k=0;k<=length_s-1;k++){// carry the out row
								reverse=1;
								if (k>0){
									end1=s->sol[i][end1];identify2=0;
								}
								if (end1==0 &&identify2==0)break;//
								end2=in_num;
								for (int n=0;n<=length_s-1;n++){
									if (n==1){// determine the right or left
										if (s->sol[s_t[in_num]][in_num]==0)reverse=0;
										if (s->sol_r[s_t[in_num]][in_num]==0)reverse=1;
										if (s->sol_r[s_t[in_num]][in_num]!=0 && s->sol[s_t[in_num]][in_num]!=0){
											if (gain_fun(pointer,end1,i,in_num,s->sol[s_t[in_num]][in_num],s_t[in_num],k,1)>
												gain_fun(pointer,end1,i,in_num,s->sol_r[s_t[in_num]][in_num],s_t[in_num],k,0))
												reverse=1;
											else
												reverse=0;
										}
									}
									if (reverse==1 && n!=0){
										end2=s->sol[s_t[end2]][end2];
										}
									if (reverse==0 && n!=0){
										end2=s->sol_r[s_t[end2]][end2];
										}
									if (end2==0)break;
									if (pointer==end1 && (s->sol[s_t[end2]][end2]==0 || s->sol_r[s_t[end2]][end2]==0))break;
									if (gi+gain_fun(pointer,end1,i,in_num,end2,s_t[in_num],k,reverse)>0){
										count++;
										cand_str1[count-1][0]=pointer;
										cand_str1[count-1][1]=end1;
										cand_str1[count-1][2]=i;
										cand_str2[count-1][0]=in_num;
										cand_str2[count-1][1]=end2;
										rever_list[count-1]=reverse;
										cand_fit[count-1]=gi+gain_fun(pointer,end1,i,in_num,end2,s_t[in_num],k,reverse);
									}
								}
							}
						}
						if (count==0){continue;}
						tem=0;
						for (int k=0;k<=count-1;k++)
							if (tem<cand_fit[k]){
								near_cand1[c][0]=cand_str1[k][0];
								near_cand1[c][1]=cand_str1[k][1];
								near_cand1[c][2]=cand_str2[k][0];
								near_cand1[c][3]=cand_str2[k][1];
								near_cand1[c][4]=rever_list[k];
								near_cand1[c][5]=cand_str1[k][2];
								near_fit[c]=cand_fit[k];
								tem=cand_fit[k];////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							}
						c++;
					}
					for (j=1;j<=c-1;j++){
						if (better_fit<near_fit[j]){
							better_fit=near_fit[j];
							better_move[0]=near_cand1[j][0];
							better_move[1]=near_cand1[j][1];
							better_move[2]=near_cand1[j][2];
							better_move[3]=near_cand1[j][3];
							better_move[4]=near_cand1[j][4];
							better_move[5]=near_cand1[j][5];
						}
					}
				}
				pointer=s->sol[i][pointer];
				if (pointer==0)break;
			}
		}

		if (better_fit<1.0e-7)
			break;
		s->fitness=s->fitness-better_fit;
		record_table[better_move[5]]=1;
		record_table[s_t[better_move[2]]]=1;
		replace_fun(better_move);
		if (ceil((clock()-I_data->start)/static_cast<double>(CLOCKS_PER_SEC))>=time_length)
			break;
	}
	//update_best_solution();
}

void LS::cross_exchange(){
	insert();

	cross_exchange_1();
}
void LS::local_search(){
	reverse_fun();// get value for sol_r;
	iteration_c=0;
	// to iterate all steps
	for (int i=0;i<=v_num-1;i++)
		record_table[i]=1;
	double local_optima;
	//intra_route_optimization();
	//cross_exchange();
	local_optima=s->fitness;
	//intra_route_optimization();

	while (1){
		cross_exchange();
		if (local_optima-1.0e-7<s->fitness && local_optima+1.0e-7>s->fitness)
			break;
		else{
			local_optima=s->fitness;
			intra_route_optimization();
		}
		if(ceil((clock() - I_data->start)/static_cast<double>(CLOCKS_PER_SEC))>=time_length)
			break;
	}
	for (int i=0;i<=v_num-1;i++){
		for (int j=0;j<=num_v;j++){
			b_s->sol[i][j]=s->sol[i][j];
			b_s->sol_r[i][j]=s->sol_r[i][j];
		}
	}
	b_s->fitness=s->fitness;
}




//////////////////////////////////////////////////////////////////
void LS:: cross_exchange_2(){

	int pointer;improve=0;
	for (int i=0;i<=v_num-1;i++){
		pointer=s->sol[i][0];
		while (pointer!=0){
			s_t[pointer]=i;
			pointer=s->sol[i][pointer];
		}
	}
	double gi;int j;int in_num;int rand_order;
	int end2,end1;
	int better_move[6];
	int reverse;
	int identify;int identify2;
	double delta,min_delta,min_tabu_delta;
	int can_node[100][6];
	int can_tabu_node[100][6];
	int num_best;
	int num_tabu_best;
	while (1){
		min_delta=-Max;
		min_tabu_delta=-Max;
		num_best=0;
		num_tabu_best=0;
		for (int i=0;i<=v_num-1;i++){
			pointer=0;
			identify=1;
			while(1){
				if (pointer==0 && identify==0){identify=0;break;}
				else{
					//////////////////////////////////////////////////////
					for (j=1;j<=num_v;j++){
						in_num=-1;
						if(I_data->edge[pointer][j]==1){
							if (i!=s_t[j])
								in_num=j;
						}
					//////////////////////////////////////////////////////
						if (in_num==-1)continue;
						gi=0;//
						gi+=I_data->Distance[pointer][s->sol[i][pointer]];
						gi=gi-I_data->Distance[pointer][in_num];

						end1=pointer;identify2=1;
						for (int k=0;k<=length_s-1;k++){// carry the out row
							reverse=1;
							if (k>0){
								end1=s->sol[i][end1];identify2=0;
							}
							if (end1==0 &&identify2==0)break;//
							end2=in_num;
							for (int n=0;n<=length_s-1;n++){
								if (n==1){// determine the right or left
									if (s->sol[s_t[in_num]][in_num]==0)reverse=0;
									if (s->sol_r[s_t[in_num]][in_num]==0)reverse=1;
									if (s->sol_r[s_t[in_num]][in_num]!=0 && s->sol[s_t[in_num]][in_num]!=0){
										if (gain_fun(pointer,end1,i,in_num,s->sol[s_t[in_num]][in_num],s_t[in_num],k,1)>
											gain_fun(pointer,end1,i,in_num,s->sol_r[s_t[in_num]][in_num],s_t[in_num],k,0))
											reverse=1;
										else
											reverse=0;
									}
								}
								if (reverse==1 && n!=0)
									end2=s->sol[s_t[end2]][end2];
								if (reverse==0 && n!=0)
									end2=s->sol_r[s_t[end2]][end2];
								if (end2==0)break;
								if (pointer==end1 && (s->sol[s_t[end2]][end2]==0 || s->sol_r[s_t[end2]][end2]==0))break;
								if (pointer==0 && s->sol[i][end1]==0 && ( (s->sol[s_t[in_num]][end2]==0 &&s->sol_r[s_t[in_num]][in_num]==0 ) ||
										(s->sol_r[s_t[in_num]][end2]==0 &&s->sol[s_t[in_num]][in_num]==0)))
									break;
								delta=gi+gain_fun(pointer,end1,i,in_num,end2,s_t[in_num],k,reverse);
								if ((end1==0 && tabu_table[i][end2]<=iteration)
									|| (tabu_table[i][end2]<=iteration && tabu_table[s_t[end2]][end1]<=iteration)){
									if (delta>min_delta){
										min_delta=delta;
										can_node[0][0]=pointer;
										can_node[0][1]=end1;
										can_node[0][2]=in_num;
										can_node[0][3]=end2;
										can_node[0][4]=reverse;
										can_node[0][5]=i;
										num_best=1;
									}
									else if (min_delta+1.0e-7>delta && min_delta-1.0e-7<delta && num_best<100){
										can_node[num_best][0]=pointer;
										can_node[num_best][1]=end1;
										can_node[num_best][2]=in_num;
										can_node[num_best][3]=end2;
										can_node[num_best][4]=reverse;
										can_node[num_best][5]=i;
										num_best++;
									}
								}
								else{
									if (min_tabu_delta<delta){
										min_tabu_delta=delta;
										can_tabu_node[0][0]=pointer;
										can_tabu_node[0][1]=end1;
										can_tabu_node[0][2]=in_num;
										can_tabu_node[0][3]=end2;
										can_tabu_node[0][4]=reverse;
										can_tabu_node[0][5]=i;
										num_tabu_best=1;
									}
									else if (min_tabu_delta+1.0e-7>delta && min_tabu_delta-1.0e-7<delta && num_tabu_best<100){
										min_tabu_delta=delta;
										can_tabu_node[num_tabu_best][0]=pointer;
										can_tabu_node[num_tabu_best][1]=end1;
										can_tabu_node[num_tabu_best][2]=in_num;
										can_tabu_node[num_tabu_best][3]=end2;
										can_tabu_node[num_tabu_best][4]=reverse;
										can_tabu_node[num_tabu_best][5]=i;
										num_tabu_best++;
									}
								}
							}
						}
					}
				}
				pointer=s->sol[i][pointer];
				if (pointer==0)break;
			}
		}
		if ((num_tabu_best>0 && min_tabu_delta+1.0e-7>min_delta && (s->fitness-min_tabu_delta - 1.0e-7 <b_s->fitness)) || num_best==0){
			s->fitness=s->fitness-min_tabu_delta;
			rand_order=rand()%num_tabu_best;
			better_move[0]=can_tabu_node[rand_order][0];
			better_move[1]=can_tabu_node[rand_order][1];
			better_move[2]=can_tabu_node[rand_order][2];
			better_move[3]=can_tabu_node[rand_order][3];
			better_move[4]=can_tabu_node[rand_order][4];
			better_move[5]=can_tabu_node[rand_order][5];
		}
		else{
			s->fitness=s->fitness-min_delta;
			rand_order=rand()%num_best;
			better_move[0]=can_node[rand_order][0];
			better_move[1]=can_node[rand_order][1];
			better_move[2]=can_node[rand_order][2];
			better_move[3]=can_node[rand_order][3];
			better_move[4]=can_node[rand_order][4];
			better_move[5]=can_node[rand_order][5];
		}
		record_table[better_move[5]]=1;
		record_table[s_t[better_move[2]]]=1;
		replace_fun(better_move);
		if (s->fitness+1.0e-7<b_s->fitness){
			update_best_solution();
	//		break;
			improve=0;iteration_c=iteration;
			supply_edge();
		}
		else
			improve++;
		if (improve>threshold)
			break;
		iteration++;
		if (ceil((clock()-I_data->start)/static_cast<double>(CLOCKS_PER_SEC))>=time_length)
			break;
	}
}
void LS::insert_tabu(){
	int pointer;improve=0;
	int pointer_2;
	int longest_tour=0;
	int longest_third;
	double delta;
	int row_out,city_out,row_in,city_in;
	int can_node[100][4];
	int can_tabu_node[100][4];
	double min_delta,min_tabu_delta;
	int num_best,num_tabu_best;
	int rand_order; double delta_tabu;
	while (1){
		min_delta=Max;
		min_tabu_delta=Max;
		num_best=0;
		num_tabu_best=0;
		for (int i=0;i<=v_num-1;i++){
			pointer=s->sol[i][0];
			if (s->sol_r[i][pointer]==0 && s->sol[i][pointer]==0)
				continue;
			while(1){
				for (int j=0;j<=v_num-1;j++){
					if (j==i)continue;
					pointer_2=0;
					while(1){
						/////////////////////////////////////////////////////////////
						if (I_data->edge[pointer][pointer_2]!=1){
							pointer_2=s->sol[j][pointer_2];
							if (pointer_2==0)break;
							else continue;
						}
						//////////////////////////////////////////////////////////////
						delta=calculate_fit_insert(i,pointer,j,pointer_2);
						if(tabu_table[i][pointer]<iteration){
							min_delta=delta;
							can_node[0][0]=i;
							can_node[0][1]=pointer;
							can_node[0][2]=j;
							can_node[0][3]=pointer_2;
							num_best=1;
						}
						else if (min_delta+1.0e-7>delta && min_delta-1.0e-7<delta && num_best<100){
							can_node[num_best][0]=i;
							can_node[num_best][1]=pointer;
							can_node[num_best][2]=j;
							can_node[num_best][3]=pointer_2;
							num_best++;
						}
						else {
							if (min_tabu_delta<delta){
								min_tabu_delta=delta;
								can_tabu_node[0][0]=i;
								can_tabu_node[0][1]=pointer;
								can_tabu_node[0][2]=j;
								can_tabu_node[0][3]=pointer_2;
								num_tabu_best=1;
							}
							else if (min_tabu_delta+1.0e-7 >delta && min_tabu_delta-1.0e-7<delta && num_tabu_best<100){
								can_tabu_node[num_tabu_best][0]=i;
								can_tabu_node[num_tabu_best][1]=pointer;
								can_tabu_node[num_tabu_best][2]=j;
								can_tabu_node[num_tabu_best][3]=pointer_2;
								num_tabu_best++;
							}
						}
						pointer_2=s->sol[j][pointer_2];
						if (pointer_2==0)break;
					}
				}
				pointer=s->sol[i][pointer];
				if (pointer==0)break;
			}
		}
		if ((num_tabu_best>0 && min_tabu_delta+1.0e-7<min_delta && (s->fitness+min_tabu_delta+1.0e-7 <b_s->fitness))|| num_best==0){
			rand_order=rand()%num_tabu_best;
			delta_tabu=min_tabu_delta;
			row_out=can_tabu_node[rand_order][0];
			city_out=can_tabu_node[rand_order][1];
			row_in=can_tabu_node[rand_order][2];
			city_in=can_tabu_node[rand_order][3];
		}
		else{
			rand_order=rand()%num_best;
			delta_tabu=min_delta;
			row_out=can_node[rand_order][0];
			city_out=can_node[rand_order][1];
			row_in=can_node[rand_order][2];
			city_in=can_node[rand_order][3];
		}
		tabu_table[row_out][city_out]=iteration + tabu_l+rand()%tabu_l;
		replace_fun_insert(min_delta,row_out,city_out,row_in,city_in);
		record_table[row_out]=1;
		record_table[row_in]=1;
		if (s->fitness+1.0e-7<b_s->fitness){
			update_best_solution();
			improve=0;
			supply_edge();
//			break;
		}
		else
			improve++;
		if (improve>threshold)
			break;
		iteration++;
		if (ceil((clock()-I_data->start)/static_cast<double>(CLOCKS_PER_SEC))>=time_length)
			break;
	}
}

void LS::weak_perturb(){
	reverse_fun();// get value for sol_r;
	for (int i=0;i<=v_num-1;i++)
		for (int j=0;j<=num_v;j++)
			tabu_table[i][j]=0;
	iteration=1;
	double local_optima=s->fitness;
	int no_improve=0;
	while(1){
		if (ceil((clock()-I_data->start)/static_cast<double>(CLOCKS_PER_SEC))>=time_length)
			break;
		insert_tabu();
		iteration+=tabu_l*2;
		cross_exchange_2();
		iteration+=tabu_l*2;
		intra_route_optimization();
		if (s->fitness+1.0e-7<b_s->fitness)
			update_best_solution();
		if (local_optima+1.0e-7>b_s->fitness && local_optima-1.0e-7<b_s->fitness)
			no_improve++;
		else{
			local_optima=b_s->fitness;no_improve=0;
		}
		if (no_improve>50)break;
		cout<<b_s->fitness<<"  "<<s->fitness<<"   "<<no_improve<<endl;
	}
}

The file LS.h contains:
/*
 * LS.h
 *
 *  Created on: 18 Apr 2020
 *      Author: Peng
 */

#ifndef LS_H_
#define LS_H_
#include "Individual.h"
#include "read_data.h"
#include "Tstwoopt.h"
#include "environment.h"
class LS {
public:
	// methods
	LS(read_data * data);
	virtual ~LS();
	void local_search();
	void weak_perturb();
	// variables
	Individual* s;
	Individual*b_s;
	Individual * tem;
	read_data * I_data;
	Tstwoopt * each_route;
	TEnvironment * gEnv;
	int time_length;

private:
	void update_best_solution();
	void reverse_fun();
	void intra_route_optimization();
	void cross_exchange();
	// the methods for inter-routing methods 3
	double gain_fun(int st1,int end1,int row1,int st2,int end2,int row2,int k, int reverse);
	void replace_fun(int *move);
	void cross_exchange_1();
	void cross_exchange_2();
	void swap();
	double calculate_fit_swap(int row_out,int city_out,int row_in,int city_in);
	void replace_fun_swap(int row_out,int city_out,int row_in,int city_in);

	void insert();
	void insert_tabu();
	void replace_fun_insert(double min_delta,int row_out,int city_out,int row_in,int city_in);
	double calculate_fit_insert(int row_out,int city_out,int row_in,int city_in);
	void supply_edge();
	// general variables
	int num_v;
	int v_num;
	int* record_table;
	int * s_t;// this variable is used to record cities are belonged to which routes during in searching
	// variables for inter-routing methods 3
	int ** cand_str1;
	int ** cand_str2;
	double * cand_fit;
	int **near_cand1;
	double *near_fit;
	int *rever_list;
	// variables for tabu search.
	int iteration;
	int ** tabu_table;
	int **tabu_table_c;
	int iteration_c;
	int improve;
	//variables for tabu_strategry 3
	int c;

};
#endif /* LS_H_ */



/*

void LS::swap(){
	int pointer,pointer_2;
	int row_out,city_out,row_in,city_in;
	double delta,min_delta;
	while(1){
		min_delta=Max;
		for (int i=0;i<=v_num-1;i++){
			pointer=0;
			while(1){
				pointer=s->sol[i][pointer];
				if (pointer==0)break;
				for (int j=0;j<v_num-1;j++){
					if (j==i)continue;
					pointer_2=0;
					while(1){
						pointer_2=s->sol[j][pointer_2];
						if (pointer_2==0)break;
						delta=calculate_fit_swap(i,pointer,j,pointer_2);
						if (delta<min_delta){
							min_delta=delta;
							row_out=i;
							city_out=pointer;
							row_in=j;
							city_in=pointer_2;
						}
					}
				}
			}
		}
		if (min_delta+1.0e-7>0)break;
		s->fitness+=min_delta;
		replace_fun_swap(row_out,city_out,row_in,city_in);
		record_table[row_out]=1;
		record_table[row_in]=1;
	}
}
void LS::replace_fun_swap(int row_out,int city_out,int row_in,int city_in){
	int p_p,n_p;
	p_p=s->sol_r[row_out][city_out];
	n_p=s->sol[row_out][city_out];
	s->sol[row_out][p_p]=city_in;
	s->sol[row_out][city_in]=n_p;
	s->sol[row_out][city_out]=-1;
	s->sol_r[row_out][n_p]=city_in;
	s->sol_r[row_out][city_in]=p_p;
	s->sol_r[row_out][city_out]=-1;
	//
	p_p=s->sol_r[row_in][city_in];
	n_p=s->sol[row_in][city_in];
	s->sol[row_in][p_p]=city_out;
	s->sol[row_in][city_out]=n_p;
	s->sol[row_in][city_in]=-1;
	s->sol_r[row_in][n_p]=city_out;
	s->sol_r[row_in][city_out]=p_p;
	s->sol_r[row_in][city_in]=-1;
}
double LS::calculate_fit_swap(int row_out,int city_out,int row_in,int city_in){
	double delta=0;
	delta+=I_data->Distance[s->sol_r[row_out][city_out]][city_in]+I_data->Distance[city_in][s->sol[row_out][city_out]];
	delta=delta-I_data->Distance[s->sol_r[row_out][city_out]][city_out]-I_data->Distance[s->sol[row_out][city_out]][city_out];
	//
	delta+=I_data->Distance[s->sol_r[row_in][city_in]][city_out]+I_data->Distance[city_out][s->sol[row_in][city_in]];
	delta=delta-I_data->Distance[s->sol_r[row_in][city_in]][city_in]-I_data->Distance[s->sol[row_in][city_in]][city_in];
	return delta;
} */

The file main.cpp contains:
/*
 * main.cpp
 *
 *  Created on: 17 Apr 2020
 *      Author: Peng
 */
#include"solution.h"
#include"basic.h"
int main(int argc, char*argv[]){
	if (argc!=5){
		cout << "the input parameters in configuration are wrong" << endl;
		return 1;
	}
	int rand_num;
	int time_length;
	int num_v;
	sscanf(argv[2],"%d",&num_v);
	sscanf(argv[3],"%d",&time_length);
	sscanf(argv[4],"%d",&rand_num);
	solution* sol=new solution();// assign a new object for class solution.
	sol->define(argv[1],num_v,time_length);// initialization all data and assigning memory
	srand(rand_num);
	sol->main_loop(rand_num);// in this place the running time could be input
	delete sol;
	return 0;
}

The file Makefile contains:
# test.cpp tabu_search.cpp basic.h
tar = ils
obj = cross.o perturb.o environment.o evaluator.o indi.o Individual.o kopt.o LS.o randomize.o sort.o EAX.o LS.o read_data.o Tstwoopt.o initialsol.o solution.o main.o
deps = cross.h perturb.h environment.h evaluator.h indi.h Individual.h kopt.h LS.h randomize.h sort.h EAX.h LS.h  read_data.h Tstwoopt.h initialsol.h solution.h basic.h
cc = g++
RMRF :=rm -rf

$(tar): $(obj)      # transfer to exe files
	$(cc) $^ -o $@
#test: tabu_search.o test.o
#	g++ tabu_search.o test.o -o test
%.o: %.c $(deps)    # head files
	$(cc) -c %.c -o %.o   # transfer a file
#test.o: test.cpp
#	g++ -c test.cpp -o test.o
#tabu_search.o: tabu_search.cpp
#	g++ -c tabu_search.cpp -o tabu_search.o

.PHONY:
clearall:
	$(RMRF) $(obj) $(tar)
clear:
	$(RMRF) $(obj) 
The file my-directory-list.txt contains:
The file basic.h contains:
/*
 * basic.h
 *
 *  Created on: 18 Apr 2020
 *      Author: Peng
 */

#ifndef BASIC_H_
#define BASIC_H_
#include<algorithm>
#include <vector>
#include<math.h>
#include <iostream>
#include <time.h>
#include <string.h>
#include <fstream>
using namespace std;
///////////////////////////////////////////////////////////////////////////////

#define Max 100000000

#define num_initial 15
#define num_near_nodes 30
#define length_s 4 // the length of each string, the actual value is length_s-1
#define tabu_l  60
#define threshold 10
#define alpha_num 20







#define perturbation_num 80


//#define control_para 300

//#define Probability 400


#define cross_exchange_identify 2

// the parameters to select operators for intra-route and inter-route optimization in local search
#define intra_opt 3                // the number 1, 2 and 3    are 2-opt, tabu search and EAX, respectively
#define inter_opt 3          // the number 1, 2 and 3 are insert operators, solution based tabu search and cross-exchange
#define perturbation_method 1
////////////////////////////////////////////////////////////////

#endif /* BASIC_H_ */

The file cross.cpp contains:
/*
 * cross.cpp
 *   created on: April 24, 2013
 * last updated: June 13, 2013
 *       author: liushujia
 */

#ifndef __Cross__
#include "cross.h"
#endif

TCross::TCross( int N ){
	fMaxNumOfABcycle = 2000;	// 设置适当的值(2000)
	total_fN = N+100;
//	tBestTmp.define( total_fN );
	nearData = new int* [ total_fN ];
	for ( int j = 0; j < total_fN; ++j ) nearData[j] = new int [ 5 ];

	fABcycle = new int* [ fMaxNumOfABcycle ];
	for ( int j = 0; j < fMaxNumOfABcycle; ++j ) fABcycle[j] = new int [ 2*total_fN + 4 ];

	koritsu = new int [ total_fN ];
	bunki = new int [ total_fN ];
	koriInv = new int [ total_fN ];
	bunInv = new int [ total_fN ];
	checkKoritsu = new int [ total_fN ];
	fRoute = new int [ 2*total_fN + 1 ];
	fPermu = new int [ fMaxNumOfABcycle ];

	fC = new int [ 2*total_fN+4 ];
	fJun = new int[ total_fN+ 1 ];
	fOrd1 = new int [ total_fN ];
	fOrd2 = new int [ total_fN ];

	// Speed Up Start
	fOrder = new int [ total_fN ];
	fInv = new int [ total_fN ];
	fSegment = new int* [ total_fN ];
	for ( int j = 0; j < total_fN; ++j ) fSegment[ j ] = new int [ 2 ];

	fSegUnit = new int [ total_fN ];
	fSegPosiList = new int[ total_fN ];
	LinkAPosi = new int [ total_fN ];
	LinkBPosi = new int* [ total_fN ];
	for ( int j = 0; j < total_fN; ++j ) LinkBPosi[ j ] = new int [ 2 ];

	fPosiSeg = new int [ total_fN ];
	fNumOfElementInUnit = new int [ total_fN ];
	fCenterUnit = new int [ total_fN ];
	for ( int j = 0; j < total_fN; ++j ) fCenterUnit[ j ] = 0;

	fListOfCenterUnit = new int [ total_fN+2 ];
	fSegForCenter = new int [ total_fN ];
	fGainAB = new double [ total_fN ];
	//fGainAB = new int [ fN ];
	fModiEdge = new int* [ total_fN ];
	for ( int j = 0; j < total_fN; ++j ) fModiEdge[ j ] = new int [ 4 ];

	fBestModiEdge = new int* [ total_fN ];
	for ( int j = 0; j < total_fN; ++j ) fBestModiEdge[ j ] = new int [ 4 ];

	fAppliedCylce = new int [ total_fN ];
	fBestAppliedCylce = new int [ total_fN ];
	// Speed Up End

	// Block2
	fNumOfElementINAB = new int [ fMaxNumOfABcycle ];
	fInEffectNode = new int* [ total_fN ];
	for( int i = 0; i < total_fN; ++i ) fInEffectNode[ i ] = new int [ 2 ];

	fWeightRR = new int* [ fMaxNumOfABcycle ];
	for( int i = 0; i < fMaxNumOfABcycle; ++i ) fWeightRR[ i ] = new int [ fMaxNumOfABcycle ];

	fWeightSR = new int [ fMaxNumOfABcycle ];
	fWeightC = new int [ fMaxNumOfABcycle ];
	fUsedAB = new int [ total_fN ];
	fMovedAB = new int [ total_fN ];
	fABcycleInEset = new int [ fMaxNumOfABcycle ];
}

TCross::~TCross()
{
	delete [] koritsu;
	delete [] bunki;
	delete [] koriInv;
	delete [] bunInv;
	delete [] checkKoritsu;
	delete [] fRoute;
	delete [] fPermu;
	for ( int j = 0; j < total_fN; ++j ) delete[] nearData[ j ];

	delete[] nearData;
	for ( int j = 0; j < fMaxNumOfABcycle; ++j ) delete[] fABcycle[ j ];

	delete[] fABcycle;
	delete [] fC;
	delete [] fJun;
	delete [] fOrd1;
	delete [] fOrd2;

	// Speed Up Start
	delete [] fOrder;
	delete [] fInv;

	for ( int j = 0; j < total_fN; ++j ) delete[] fSegment[ j ];

	delete[] fSegment;
	delete[] fSegUnit;
	delete [] fSegPosiList;
	delete [] LinkAPosi;
	for ( int j = 0; j < total_fN; ++j ) delete[] LinkBPosi[ j ];

	delete [] LinkBPosi;
	delete [] fPosiSeg;
	delete [] fNumOfElementInUnit;
	delete [] fCenterUnit;
	delete [] fListOfCenterUnit;
	delete [] fSegForCenter;
	delete [] fGainAB;

	for ( int j = 0; j < total_fN; ++j ) delete[] fModiEdge[ j ];
	delete [] fModiEdge;
	for ( int j = 0; j < total_fN; ++j ) delete[] fBestModiEdge[ j ];
	delete [] fBestModiEdge;

	delete [] fAppliedCylce;
	delete [] fBestAppliedCylce;
	// Speed Up End

	// Block2
	delete [] fNumOfElementINAB;
	for ( int j = 0; j < total_fN; ++j ) delete [] fInEffectNode[ j ];

	delete [] fInEffectNode;
	for( int i = 0; i < fMaxNumOfABcycle; ++i ) delete [] fWeightRR[ i ];
	delete [] fWeightRR;
	
	delete [] fWeightSR;
	delete [] fWeightC;
	delete [] fUsedAB;
	delete [] fMovedAB;
	delete [] fABcycleInEset;
//	delete eval;
}

void TCross::input_data(int N)
{
	fN=N;
}
void TCross::setParents( const TIndi& tPa1, const TIndi& tPa2, int flagC[ 10 ], int numOfKids ){
	this->setABcycle( tPa1, tPa2, flagC, numOfKids );
	fDisAB = 0;
	int curr, next, st, pre;
	st = 0;
	curr=-1;
	next = st;
	for( int i = 0; i < fN; ++i ){
		pre=curr;
		curr=next;
		if( tPa1.fLink[curr][0] != pre ) next = tPa1.fLink[ curr ][ 0 ];
		else next=tPa1.fLink[curr][1];

		if( tPa2.fLink[ curr ][ 0 ] != next && tPa2.fLink[ curr ][ 1 ] != next ) ++fDisAB;
		fOrder[ i ] = curr;
		fInv[ curr ] = i;
	}
	if( flagC[ 1 ] == 2 ){
		fTmax = 10;
		fMaxStag = 20;                 //1:Greedy LS, 20:Tabu Search
		this->setWeight( tPa1, tPa2 );
	}
}

void TCross::doIt( TIndi& tKid, TIndi& tPa2, int numOfKids, int flagP, int flagC[ 10 ], int **fEdgeFreq ){
	int Num;
	int jnum, centerAB;
	//int gain;
	double gain;
	//int BestGain;
	double BestGain;
	double pointMax, point;
	double DLoss;

	fEvalType = flagC[ 0 ];              //1:Greedy, 2:---, 3:Distance, 4:Entropy
	fEsetType = flagC[ 1 ];              //1:Single-AB, 2:Block2

	if ( numOfKids <= fNumOfABcycle ) Num = numOfKids;
	else Num = fNumOfABcycle;

	if( fEsetType == 1 )		// Single-AB
	tRand->permutation( fPermu, fNumOfABcycle, fNumOfABcycle );

	else if( fEsetType == 2 ){  // Block2
		for( int k =0; k< fNumOfABcycle; ++k ) fNumOfElementINAB[ k ] = fABcycle[ k ][ 0 ];
		tSort->indexB( fNumOfElementINAB, fNumOfABcycle, fPermu, fNumOfABcycle );
	}
	fNumOfGeneratedCh = 0;
	pointMax = 0.0;
	BestGain = 0.0;
	fFlagImp = 0;
	for( int j =0; j < Num; ++j ){
		fNumOfABcycleInEset = 0;
		if( fEsetType == 1 ){         //Single-AB
			jnum = fPermu[ j ];
			fABcycleInEset[ fNumOfABcycleInEset++ ] = jnum;
		}
		else if( fEsetType == 2 ){    //Block2
			jnum = fPermu[ j ];
			centerAB = jnum;
			for( int s = 0; s < fNumOfABcycle; ++s ){
				if( s == centerAB ) fABcycleInEset[ fNumOfABcycleInEset++ ] = s;
				else{
					if( fWeightRR[ centerAB ][ s ] > 0 && fABcycle[ s ][ 0 ] < fABcycle[ centerAB ][ 0 ] )
					if( rand() %2 == 0 ) fABcycleInEset[ fNumOfABcycleInEset++ ] = s;
				}
			}
		this->searchEset( centerAB );
		}
		fNumOfSPL = 0;
		gain = 0.0;
		fNumOfAppliedCycle = 0;
		fNumOfModiEdge = 0;

		fNumOfAppliedCycle = fNumOfABcycleInEset;
		for( int k = 0; k < fNumOfAppliedCycle; ++k ){
			fAppliedCylce[ k ] = fABcycleInEset[ k ];
			jnum = fAppliedCylce[ k ];
			this->changeSol( tKid, jnum, flagP );
			gain += fGainAB[ jnum ];
		}

		this->makeUnit();
		this->makeCompleteSol( tKid );
		gain += fGainModi;

		++fNumOfGeneratedCh;

		if( fEvalType == 1 ) DLoss = 1.0;									//Greedy
		else if( fEvalType == 3 ) DLoss = this->calAdpLoss( fEdgeFreq );	// Distance preservation
		else if( fEvalType == 4 ) DLoss = this->calEntLoss( fEdgeFreq );	// Entropy preservation

		if( DLoss <= 0.0 ) DLoss = 0.00000001;

		point = (double)gain / DLoss;
		tKid.fEvaluationValue = tKid.fEvaluationValue - gain;

		if( pointMax < point && (2 * fBestNumE < fDisAB || tKid.fEvaluationValue != tPa2.fEvaluationValue ) ){
			pointMax = point;
			BestGain = gain;
			fFlagImp = 1;

			fNumOfBestAppliedCycle = fNumOfAppliedCycle;
			for( int s = 0; s < fNumOfBestAppliedCycle; ++s ) fBestAppliedCylce[ s ] = fAppliedCylce[ s ];

			fNumOfBestModiEdge = fNumOfModiEdge;
			for( int s = 0; s < fNumOfBestModiEdge; ++s ){
				fBestModiEdge[ s ][ 0 ] = fModiEdge[ s ][ 0 ];
				fBestModiEdge[ s ][ 1 ] = fModiEdge[ s ][ 1 ];
				fBestModiEdge[ s ][ 2 ] = fModiEdge[ s ][ 2 ];
				fBestModiEdge[ s ][ 3 ] = fModiEdge[ s ][ 3 ];
			}

		}
		this->backToPa1( tKid );
		tKid.fEvaluationValue = tKid.fEvaluationValue + gain;
	}
	if( fFlagImp == 1 ){
		this->goToBest( tKid );
		tKid.fEvaluationValue = tKid.fEvaluationValue - BestGain;
		this->incrementEdgeFreq( fEdgeFreq );
	}
}

void TCross::setABcycle( const TIndi& tPa1, const TIndi& tPa2, int flagC[ 10 ], int numOfKids ){
	bunkiMany=0; koritsuMany=0;
	for( int j = 0; j < fN ; ++j ){
		nearData[j][1]=tPa1.fLink[j][0];
		nearData[j][3]=tPa1.fLink[j][1];
		nearData[j][0] = 2;

		koritsu[koritsuMany]=j;
		koritsuMany++;

		nearData[j][2]=tPa2.fLink[j][0];
		nearData[j][4]=tPa2.fLink[j][1];
	}
	for(int j = 0; j < fN; ++j ){
		checkKoritsu[j]=-1;
		koriInv[koritsu[j]]=j;
	}
	fNumOfABcycle=0;
	flagSt=1;
	while(koritsuMany!=0){
		if(flagSt==1){
			fPosiCurr=0;
			r=rand()%koritsuMany;
			st=koritsu[r];
			checkKoritsu[st]=fPosiCurr;
			fRoute[fPosiCurr]=st;
			ci=st;
			prType=2;
		}
		else if(flagSt==0) ci=fRoute[fPosiCurr];

		flagCycle=0;
		while(flagCycle==0){
			fPosiCurr++;
			pr=ci;
			switch(prType){
			case 1:
				ci=nearData[pr][fPosiCurr%2+1];
			break;
			case 2:
				r=rand()%2;
				ci=nearData[pr][fPosiCurr%2+1+2*r];
				if(r==0) this->swap(nearData[pr][fPosiCurr%2+1],nearData[pr][fPosiCurr%2+3]);
			break;
			case 3:
				ci=nearData[pr][fPosiCurr%2+3];
			}
			fRoute[fPosiCurr]=ci;
			if(nearData[ci][0]==2){
				if(ci==st){
					if(checkKoritsu[st]==0){
					if((fPosiCurr-checkKoritsu[st])%2==0){
						if(nearData[st][fPosiCurr%2+1]==pr) this->swap(nearData[ci][fPosiCurr%2+1],nearData[ci][fPosiCurr%2+3]);

						stAppear = 1;
						this->formABcycle();
						if( flagC[ 1 ] == 1 && fNumOfABcycle == numOfKids ) goto RETURN;
						if( fNumOfABcycle == fMaxNumOfABcycle ) goto RETURN;

						flagSt=0;
						flagCycle=1;
						prType=1;
					}
					else{
						this->swap(nearData[ci][fPosiCurr%2+1],nearData[ci][fPosiCurr%2+3]);
						prType=2;
					}
					checkKoritsu[st]=fPosiCurr;
					}
					else{
					stAppear = 2;
					this->formABcycle();
					if( flagC[ 1 ] == 1 && fNumOfABcycle == numOfKids ) goto RETURN;
					if( fNumOfABcycle == fMaxNumOfABcycle ) goto RETURN;

					flagSt=1;
					flagCycle=1;
					}
				}
				else if(checkKoritsu[ci]==-1) {
					checkKoritsu[ci]=fPosiCurr;
					if(nearData[ci][fPosiCurr%2+1]==pr) this->swap(nearData[ci][fPosiCurr%2+1],nearData[ci][fPosiCurr%2+3]);
					prType=2;
				}
				else if(checkKoritsu[ci]>0){
					this->swap(nearData[ci][fPosiCurr%2+1],nearData[ci][fPosiCurr%2+3]);
					if((fPosiCurr-checkKoritsu[ci])%2==0){
						stAppear = 1;
						this->formABcycle();
						if( flagC[ 1 ] == 1 && fNumOfABcycle == numOfKids ) goto RETURN;
						if( fNumOfABcycle == fMaxNumOfABcycle ) goto RETURN;

						flagSt=0;
						flagCycle=1;
						prType=1;
					}
					else{
						this->swap(nearData[ci][(fPosiCurr+1)%2+1],nearData[ci][(fPosiCurr+1)%2+3]);
						prType=3;
					}
				}
			}
			else if(nearData[ci][0]==1){
				if(ci==st){
					stAppear = 1;
					this->formABcycle();
					if( flagC[ 1 ] == 1 && fNumOfABcycle == numOfKids ) goto RETURN;
					if( fNumOfABcycle == fMaxNumOfABcycle ) goto RETURN;
					flagSt=1;
					flagCycle=1;
				}
				else prType=1;
			}
		}
	}
	while(bunkiMany!=0){
		fPosiCurr=0;
		r=rand()%bunkiMany;
		st=bunki[r];
		fRoute[fPosiCurr]=st;
		ci=st;

		flagCycle=0;
		while(flagCycle==0){
			pr=ci;
			fPosiCurr++;
			ci=nearData[pr][fPosiCurr%2+1];
			fRoute[fPosiCurr]=ci;
			if(ci==st){
				stAppear = 1;
				this->formABcycle();
				if( flagC[ 1 ] == 1 && fNumOfABcycle == numOfKids ) goto RETURN;
				if( fNumOfABcycle == fMaxNumOfABcycle ) goto RETURN;

				flagCycle=1;
			}
		}
	}
RETURN:
	if( fNumOfABcycle == fMaxNumOfABcycle ){
		printf( "fMaxNumOfABcycle(%d) must be increased\n", fMaxNumOfABcycle );
		exit( 1 );
	}
}

void TCross::formABcycle(){
	int j;
	int st_count;
	int edge_type;
	int st,ci, stock;
	int cem;
	double diff;
	//int diff;

	if(fPosiCurr%2==0) edge_type=1;
	else edge_type=2;
	st=fRoute[fPosiCurr];
	cem=0;
	fC[cem]=st;

	st_count=0;
	while(1){
		cem++;
		fPosiCurr--;
		ci=fRoute[fPosiCurr];
		if(nearData[ci][0]==2){
			koritsu[koriInv[ci]]=koritsu[koritsuMany-1];
			koriInv[koritsu[koritsuMany-1]]=koriInv[ci];
			koritsuMany--;
			bunki[bunkiMany]=ci;
			bunInv[ci]=bunkiMany;
			bunkiMany++;
		}
		else if(nearData[ci][0]==1){
			bunki[bunInv[ci]]=bunki[bunkiMany-1];
			bunInv[bunki[bunkiMany-1]]=bunInv[ci];
			bunkiMany--;
		}

		nearData[ci][0]--;
		if(ci==st) st_count++;
		if(st_count==stAppear) break;
		fC[cem]=ci;
	}

	if(cem==2) return;

	fABcycle[fNumOfABcycle][0]=cem;

	if(edge_type==2){
		stock=fC[0];
		for( int j=0;j<cem-1;j++) fC[j]=fC[j+1];
		fC[cem-1]=stock;
	}

	for( int j=0;j<cem;j++) fABcycle[fNumOfABcycle][j+2]=fC[j];

	fABcycle[fNumOfABcycle][1]=fC[cem-1];
	fABcycle[fNumOfABcycle][cem+2]=fC[0];
	fABcycle[fNumOfABcycle][cem+3]=fC[1];

	fC[ cem ] = fC[ 0 ];
	fC[ cem+1 ] = fC[ 1 ];
	diff = 0.0;
	for( j = 0; j < cem/2; ++j ) diff = diff + eval->fEdgeDis[fC[2*j]][fC[1+2*j]] - eval->fEdgeDis[fC[1+2*j]][fC[2+2*j]];

	fGainAB[fNumOfABcycle] = diff;
	++fNumOfABcycle;
}

void TCross::swap(int &x, int &y){
	int s=x;
	x=y;
	y=s;
}

void TCross::changeSol( TIndi& tKid, int ABnum, int type ){
	int j;
	int cem, r1, r2, b1, b2;
	int po_r1, po_r2, po_b1, po_b2;

	cem=fABcycle[ABnum][0];
	fC[0]=fABcycle[ABnum][0];

	if(type==2) for(j=0;j<cem+3;j++) fC[cem+3-j]=fABcycle[ABnum][j+1];
	else for(j=1;j<=cem+3;j++) fC[j]=fABcycle[ABnum][j];

	for(j=0;j<cem/2;j++){
		r1=fC[2+2*j];r2=fC[3+2*j];
		b1=fC[1+2*j];b2=fC[4+2*j];

		if(tKid.fLink[r1][0]==r2) tKid.fLink[r1][0]=b1;
		else tKid.fLink[r1][1]=b1;
		if(tKid.fLink[r2][0]==r1) tKid.fLink[r2][0]=b2;
		else tKid.fLink[r2][1]=b2;

		po_r1 = fInv[ r1 ];
		po_r2 = fInv[ r2 ];
		po_b1 = fInv[ b1 ];
		po_b2 = fInv[ b2 ];

		if( po_r1 == 0 && po_r2 == fN-1 ) fSegPosiList[ fNumOfSPL++ ] = po_r1;
		else if( po_r1 == fN-1 && po_r2 == 0 ) fSegPosiList[ fNumOfSPL++ ] = po_r2;
		else if( po_r1 < po_r2 ) fSegPosiList[ fNumOfSPL++ ] = po_r2;
		else if( po_r2 < po_r1 ) fSegPosiList[ fNumOfSPL++ ] = po_r1;

		LinkBPosi[ po_r1 ][ 1 ] = LinkBPosi[ po_r1 ][ 0 ];
		LinkBPosi[ po_r2 ][ 1 ] = LinkBPosi[ po_r2 ][ 0 ];
		LinkBPosi[ po_r1 ][ 0 ] = po_b1;
		LinkBPosi[ po_r2 ][ 0 ] = po_b2;
	}
}

void TCross::makeCompleteSol( TIndi& tKid ){
	int j, j1, j2;
	int st ,pre, curr, next, a, b, c, d, aa, bb, a1, b1;
	int min_unit_city;
	int center_un, select_un;
	double diff, max_diff;
	//int diff, max_diff;
	int near_num, nearMax;

	fGainModi = 0;
	while( fNumOfUnit != 1 ){
		min_unit_city = fN + 12345;
		for( int u = 0; u < fNumOfUnit; ++u )
			if( fNumOfElementInUnit[ u ] < min_unit_city ){
				center_un = u;
				min_unit_city = fNumOfElementInUnit[ u ];
			}


		st = -1;
		fNumOfSegForCenter = 0;
		for( int s = 0; s < fNumOfSeg; ++s )
			if( fSegUnit[ s ] == center_un ){
				int posi = fSegment[ s ][ 0 ];
				st = fOrder[ posi ];
				fSegForCenter[  fNumOfSegForCenter++ ] = s;
			}
		curr = -1;
		next = st;
		fNumOfElementInCU = 0;
		while(1){
			pre = curr;
			curr = next;
			fCenterUnit[ curr ] = 1;
			fListOfCenterUnit[ fNumOfElementInCU ] = curr;
			++fNumOfElementInCU;
			if( tKid.fLink[ curr ][ 0 ] != pre ) next = tKid.fLink[ curr ][ 0 ];
			else next = tKid.fLink[ curr ][ 1 ];
			if( next == st ) break;
		}
		fListOfCenterUnit[ fNumOfElementInCU ] = fListOfCenterUnit[ 0 ];
		fListOfCenterUnit[ fNumOfElementInCU+1 ] = fListOfCenterUnit[ 1 ];

		max_diff = -999999999;
		a1 = -1; b1 = -1;
		nearMax = 10;	// N_near
						// nearMax <= eva->fNearNumMax (kopt.cpp)

	RESTART:
		for( int s = 1; s <= fNumOfElementInCU; ++s ){
			a = fListOfCenterUnit[ s ];

			for( near_num = 1; near_num <= nearMax; ++near_num ){
				c = eval->fNearCity[ a ][ near_num ];
				if( fCenterUnit[ c ] == 0 ){
					for( j1 = 0; j1 < 2; ++j1 ){
						b = fListOfCenterUnit[ s-1+2*j1 ];
						for( j2 = 0; j2 < 2; ++j2 ){
							d = tKid.fLink[ c ][ j2 ];
							diff = eval->fEdgeDis[a][b] + eval->fEdgeDis[c][d] - eval->fEdgeDis[a][c] - eval->fEdgeDis[b][d];
							if( diff > max_diff ){
								aa = a; bb = b; a1 = c; b1 = d;
								max_diff = diff;
							}
							diff = eval->fEdgeDis[a][b] + eval->fEdgeDis[d][c] -
								eval->fEdgeDis[a][d] - eval->fEdgeDis[b][c];
							if( diff > max_diff ){
								aa = a; bb = b; a1 = d; b1 = c;
								max_diff = diff;
							}
						}
					}
				}
			}
		}

		if( a1 == -1 && nearMax == 10 ){
			nearMax = 50;
			goto RESTART;
		}
		else if( a1 == -1 && nearMax == 50  ){
			int r = rand() % ( fNumOfElementInCU - 1 );
			a = fListOfCenterUnit[ r ];
			b = fListOfCenterUnit[ r+1 ];
			for( j = 0; j < fN; ++j ){
				if( fCenterUnit[ j ] == 0 ){
					aa = a; bb = b;
					a1 = j;
					b1 = tKid.fLink[ j ][ 0 ];
					break;
				}
			}
			max_diff = eval->fEdgeDis[aa][bb] + eval->fEdgeDis[a1][b1] - eval->fEdgeDis[a][a1] - eval->fEdgeDis[b][b1];
		}

		if( tKid.fLink[aa][0] == bb ) tKid.fLink[aa][0]=a1;
		else tKid.fLink[aa][1] = a1;
		if( tKid.fLink[bb][0] == aa ) tKid.fLink[bb][0] = b1;
		else tKid.fLink[bb][1] = b1;
		if( tKid.fLink[a1][0] == b1 ) tKid.fLink[a1][0] = aa;
		else tKid.fLink[a1][1] = aa;
		if( tKid.fLink[b1][0] == a1 ) tKid.fLink[b1][0] = bb;
		else tKid.fLink[b1][1] = bb;

		fModiEdge[ fNumOfModiEdge ][ 0 ] = aa;
		fModiEdge[ fNumOfModiEdge ][ 1 ] = bb;
		fModiEdge[ fNumOfModiEdge ][ 2 ] = a1;
		fModiEdge[ fNumOfModiEdge ][ 3 ] = b1;
		++fNumOfModiEdge;

		fGainModi += max_diff;

		int posi_a1 = fInv[ a1 ];
		select_un = -1;
		for( int s = 0; s < fNumOfSeg; ++s )
			if( fSegment[ s ][ 0 ] <= posi_a1 && posi_a1 <=  fSegment[ s ][ 1 ] ){
				select_un = fSegUnit[ s ];
				break;
			}


		for( int s = 0; s < fNumOfSeg; ++s )
			if( fSegUnit[ s ] == select_un ) fSegUnit[ s ] = center_un;

		fNumOfElementInUnit[ center_un ] += fNumOfElementInUnit[ select_un ];

		for( int s = 0; s < fNumOfSeg; ++s )
			if( fSegUnit[ s ] == fNumOfUnit - 1 ) fSegUnit[ s ] = select_un;

		fNumOfElementInUnit[ select_un ] = fNumOfElementInUnit[ fNumOfUnit - 1 ];
		--fNumOfUnit;

		for( int s = 0; s < fNumOfElementInCU; ++s ){
			c = fListOfCenterUnit[ s ];
			fCenterUnit[ c ] = 0;
		}
	}
}

void TCross::makeUnit(){
	int flag = 1;
	for( int s = 0; s < fNumOfSPL; ++s ){
		if( fSegPosiList[ s ] == 0 ){
			flag = 0;
			break;
		}
	}
	if( flag == 1 ){
		fSegPosiList[ fNumOfSPL++ ] = 0;
		LinkBPosi[ fN-1 ][ 1 ]  = LinkBPosi[ fN-1 ][ 0 ];
		LinkBPosi[ 0 ][ 1 ] = LinkBPosi[ 0 ][ 0 ];
		LinkBPosi[ fN-1 ][ 0 ] = 0;
		LinkBPosi[ 0 ][ 0 ] = fN-1;
	}

	tSort->sort( fSegPosiList, fNumOfSPL );
	fNumOfSeg = fNumOfSPL;
	for( int s = 0; s < fNumOfSeg-1; ++s ){
		fSegment[ s ][ 0 ] = fSegPosiList[ s ];
		fSegment[ s ][ 1 ] = fSegPosiList[ s+1 ]-1;
	}

	fSegment[ fNumOfSeg-1 ][ 0 ] = fSegPosiList[ fNumOfSeg-1 ];
	fSegment[ fNumOfSeg-1 ][ 1 ] = fN - 1;

	for( int s = 0; s < fNumOfSeg; ++s ){
		LinkAPosi[ fSegment[ s ][ 0 ] ] = fSegment[ s ][ 1 ];
		LinkAPosi[ fSegment[ s ][ 1 ] ] = fSegment[ s ][ 0 ];
		fPosiSeg[ fSegment[ s ][ 0 ] ] = s;
		fPosiSeg[ fSegment[ s ][ 1 ] ] = s;
	}

	for( int s = 0; s < fNumOfSeg; ++s ) fSegUnit[ s ] = -1;
	fNumOfUnit = 0;

	int p_st, p1, p2, p_next, p_pre;
	int segNum;
	while(1){
		flag = 0;
		for( int s = 0; s < fNumOfSeg; ++s ){
			if( fSegUnit[ s ] == -1 ){
				p_st = fSegment[ s ][ 0 ];
				p_pre = -1;
				p1 = p_st;
				flag = 1;
				break;
			}
		}
		if( flag == 0 ) break;

		while(1){
			segNum = fPosiSeg[ p1 ];
			fSegUnit[ segNum ] = fNumOfUnit;

			p2 = LinkAPosi[ p1 ];
			p_next = LinkBPosi[ p2 ][ 0 ];
			if( p1 == p2 )
				if( p_next == p_pre ) p_next = LinkBPosi[ p2 ][ 1 ];

			if( p_next == p_st ){
				++fNumOfUnit;
				break;
			}

			p_pre = p2;
			p1 = p_next;
		}
	}

	for( int s = 0; s < fNumOfUnit; ++s ) fNumOfElementInUnit[ s ] = 0;

	int unitNum = -1;
	int tmpNumOfSeg = -1;
	for( int s = 0; s < fNumOfSeg; ++s ){
		if( fSegUnit[ s ] != unitNum ){
			++tmpNumOfSeg;
			fSegment[ tmpNumOfSeg ][ 0 ] = fSegment[ s ][ 0 ];
			fSegment[ tmpNumOfSeg ][ 1 ] = fSegment[ s ][ 1 ];
			unitNum = fSegUnit[ s ];
			fSegUnit[ tmpNumOfSeg ] = unitNum;
			fNumOfElementInUnit[ unitNum ] +=
			fSegment[ s ][ 1 ] - fSegment[ s ][ 0 ] + 1;
		}
		else{
			fSegment[ tmpNumOfSeg ][ 1 ] = fSegment[ s ][ 1 ];
			fNumOfElementInUnit[ unitNum ] +=
			fSegment[ s ][ 1 ] - fSegment[ s ][ 0 ] + 1;
		}
	}
	fNumOfSeg = tmpNumOfSeg + 1;
}

void TCross::backToPa1( TIndi& tKid ){
	int aa, bb, a1, b1;
	int jnum;

	for( int s = fNumOfModiEdge -1; s >= 0; --s ){
		aa = fModiEdge[ s ][ 0 ];
		a1 = fModiEdge[ s ][ 1 ];
		bb = fModiEdge[ s ][ 2 ];
		b1 = fModiEdge[ s ][ 3 ];

		if( tKid.fLink[aa][0] == bb ) tKid.fLink[aa][0] = a1;
		else tKid.fLink[aa][1] = a1;
		if( tKid.fLink[b1][0] == a1 ) tKid.fLink[b1][0] = bb;
		else tKid.fLink[b1][1] = bb;
		if( tKid.fLink[bb][0] == aa ) tKid.fLink[bb][0] = b1;
		else tKid.fLink[bb][1] = b1;
		if( tKid.fLink[a1][0] == b1 ) tKid.fLink[a1][0] = aa;
		else tKid.fLink[a1][1] = aa;
	}

	for( int s = 0; s < fNumOfAppliedCycle; ++s ){
		jnum = fAppliedCylce[ s ];
		this->changeSol( tKid, jnum, 2 );
	}
}

void TCross::goToBest( TIndi& tKid ){
	int aa, bb, a1, b1;
	int jnum;

	for( int s = 0; s < fNumOfBestAppliedCycle; ++s ){
		jnum = fBestAppliedCylce[ s ];
		this->changeSol( tKid, jnum, 1 );
	}

	 for( int s = 0; s < fNumOfBestModiEdge; ++s ){
		aa = fBestModiEdge[ s ][ 0 ];
		bb = fBestModiEdge[ s ][ 1 ];
		a1 = fBestModiEdge[ s ][ 2 ];
		b1 = fBestModiEdge[ s ][ 3 ];

		if( tKid.fLink[aa][0] == bb ) tKid.fLink[aa][0]=a1;
		else tKid.fLink[aa][1] = a1;
		if( tKid.fLink[bb][0] == aa ) tKid.fLink[bb][0] = b1;
		else tKid.fLink[bb][1] = b1;
		if( tKid.fLink[a1][0] == b1 ) tKid.fLink[a1][0] = aa;
		else tKid.fLink[a1][1] = aa;
		if( tKid.fLink[b1][0] == a1 ) tKid.fLink[b1][0] = bb;
		else tKid.fLink[b1][1] = bb;
	}
}

void TCross::incrementEdgeFreq( int **fEdgeFreq ){
	int j, jnum, cem;
	int r1, r2, b1, b2;
	int aa, bb, a1;

	for( int s = 0; s < fNumOfBestAppliedCycle; ++s ){
		jnum = fBestAppliedCylce[ s ];

		cem = fABcycle[ jnum ][ 0 ];
		fC[ 0 ] = fABcycle[ jnum ][ 0 ];

		for( j = 1; j <= cem+3; ++j )
			fC[ j ] = fABcycle[ jnum ][ j ];

		for( j = 0; j <cem/2; ++j ){
			r1 = fC[2+2*j]; r2 = fC[3+2*j];
			b1 = fC[1+2*j]; b2 = fC[4+2*j];

			++fEdgeFreq[ r1 ][ b1 ];
			--fEdgeFreq[ r1 ][ r2 ];
			--fEdgeFreq[ r2 ][ r1 ];
			++fEdgeFreq[ r2 ][ b2 ];
		}
	}
	for( int s = 0; s < fNumOfBestModiEdge; ++s ){
		aa = fBestModiEdge[ s ][ 0 ];
		bb = fBestModiEdge[ s ][ 1 ];
		a1 = fBestModiEdge[ s ][ 2 ];
		b1 = fBestModiEdge[ s ][ 3 ];

		--fEdgeFreq[ aa ][ bb ];
		--fEdgeFreq[ a1 ][ b1 ];
		++fEdgeFreq[ aa ][ a1 ];
		++fEdgeFreq[ bb ][ b1 ];
		--fEdgeFreq[ bb ][ aa ];
		--fEdgeFreq[ b1 ][ a1 ];
		++fEdgeFreq[ a1 ][ aa ];
		++fEdgeFreq[ b1 ][ bb ];
	}
}

int TCross::calAdpLoss( int **fEdgeFreq ){
	int j, jnum, cem;
	int r1, r2, b1, b2;
	int aa, bb, a1;
	double DLoss;

	DLoss = 0;
	for( int s = 0; s < fNumOfAppliedCycle; ++s ){
		jnum = fAppliedCylce[ s ];

		cem = fABcycle[ jnum ][ 0 ];
		fC[ 0 ] = fABcycle[ jnum ][ 0 ];

		for( j = 1; j <= cem+3; ++j ) fC[ j ] = fABcycle[ jnum ][ j ];

		for( j = 0; j <cem/2; ++j ){
			r1 = fC[2+2*j]; r2 = fC[3+2*j];
			b1 = fC[1+2*j]; b2 = fC[4+2*j];


			DLoss -= (fEdgeFreq[ r1 ][ r2 ]-1);
			DLoss -= (fEdgeFreq[ r2 ][ r1 ]-1);
			DLoss += fEdgeFreq[ r2 ][ b2 ];
			DLoss += fEdgeFreq[ b2 ][ r2 ];


			--fEdgeFreq[ r1 ][ r2 ];
			--fEdgeFreq[ r2 ][ r1 ];
			++fEdgeFreq[ r2 ][ b2 ];
			++fEdgeFreq[ b2 ][ r2 ];
		}
	}
	for( int s = 0; s < fNumOfModiEdge; ++s ){
		aa = fModiEdge[ s ][ 0 ];
		bb = fModiEdge[ s ][ 1 ];
		a1 = fModiEdge[ s ][ 2 ];
		b1 = fModiEdge[ s ][ 3 ];

		DLoss -= (fEdgeFreq[ aa ][ bb ]-1);
		DLoss -= (fEdgeFreq[ bb ][ aa ]-1);
		DLoss -= (fEdgeFreq[ a1 ][ b1 ]-1);
		DLoss -= (fEdgeFreq[ b1 ][ a1 ]-1);

		DLoss += fEdgeFreq[ aa ][ a1 ];
		DLoss += fEdgeFreq[ a1 ][ aa ];
		DLoss += fEdgeFreq[ bb ][ b1 ];
		DLoss += fEdgeFreq[ b1 ][ bb ];

		--fEdgeFreq[ aa ][ bb ];
		--fEdgeFreq[ bb ][ aa ];
		--fEdgeFreq[ a1 ][ b1 ];
		--fEdgeFreq[ b1 ][ a1 ];

		++fEdgeFreq[ aa ][ a1 ];
		++fEdgeFreq[ a1 ][ aa ];
		++fEdgeFreq[ bb ][ b1 ];
		++fEdgeFreq[ b1 ][ bb ];
	}
	for( int s = 0; s < fNumOfAppliedCycle; ++s ){
		jnum = fAppliedCylce[ s ];
		cem = fABcycle[ jnum ][ 0 ];
		fC[ 0 ] = fABcycle[ jnum ][ 0 ];
		for( j = 1; j <= cem+3; ++j ) fC[ j ] = fABcycle[ jnum ][ j ];

		for( j = 0; j <cem/2; ++j ){
			r1 = fC[2+2*j]; r2 = fC[3+2*j];
			b1 = fC[1+2*j]; b2 = fC[4+2*j];

			++fEdgeFreq[ r1 ][ r2 ];
			++fEdgeFreq[ r2 ][ r1 ];
			--fEdgeFreq[ r2 ][ b2 ];
			--fEdgeFreq[ b2 ][ r2 ];
		}
	}
	for( int s = 0; s < fNumOfModiEdge; ++s ){
		aa = fModiEdge[ s ][ 0 ];
		bb = fModiEdge[ s ][ 1 ];
		a1 = fModiEdge[ s ][ 2 ];
		b1 = fModiEdge[ s ][ 3 ];

		++fEdgeFreq[ aa ][ bb ];
		++fEdgeFreq[ bb ][ aa ];
		++fEdgeFreq[ a1 ][ b1 ];
		++fEdgeFreq[ b1 ][ a1 ];

		--fEdgeFreq[ aa ][ a1 ];
		--fEdgeFreq[ a1 ][ aa ];
		--fEdgeFreq[ bb ][ b1 ];
		--fEdgeFreq[ b1 ][ bb ];
	}
	return int(DLoss / 2);
}

double TCross::calEntLoss( int **fEdgeFreq ){
	int j, jnum, cem;
	int r1, r2, b1, b2;
	int aa, bb, a1;
	double DLoss;
	double h1, h2;

	DLoss = 0;	// AB-cycle
	for( int s = 0; s < fNumOfAppliedCycle; ++s ){
		jnum = fAppliedCylce[ s ];
		cem = fABcycle[ jnum ][ 0 ];
		fC[ 0 ] = fABcycle[ jnum ][ 0 ];

		for( j = 1; j <= cem+3; ++j ) fC[ j ] = fABcycle[ jnum ][ j ];

		for( j = 0; j <cem/2; ++j ){
			r1 = fC[2+2*j]; r2 = fC[3+2*j];
			b1 = fC[1+2*j]; b2 = fC[4+2*j];

		  h1 = (double)( fEdgeFreq[ r1 ][ r2 ] - 1 )/(double)Npop;
		  h2 = (double)( fEdgeFreq[ r1 ][ r2 ] )/(double)Npop;
		  if( fEdgeFreq[ r1 ][ r2 ] - 1 != 0 ) DLoss -= h1 * log( h1 );
		  DLoss += h2 * log( h2 );
		  --fEdgeFreq[ r1 ][ r2 ];
		  --fEdgeFreq[ r2 ][ r1 ];

		  h1 = (double)( fEdgeFreq[ r2 ][ b2 ] + 1 )/(double)Npop;
		  h2 = (double)( fEdgeFreq[ r2 ][ b2 ])/(double)Npop;
		  DLoss -= h1 * log( h1 );
		  if( fEdgeFreq[ r2 ][ b2 ] != 0 ) DLoss += h2 * log( h2 );
		  ++fEdgeFreq[ r2 ][ b2 ];
		  ++fEdgeFreq[ b2 ][ r2 ];
		}
	}

	for( int s = 0; s < fNumOfModiEdge; ++s ){
		aa = fModiEdge[ s ][ 0 ];
		bb = fModiEdge[ s ][ 1 ];
		a1 = fModiEdge[ s ][ 2 ];
		b1 = fModiEdge[ s ][ 3 ];

		h1 = (double)( fEdgeFreq[ aa ][ bb ] - 1 )/(double)Npop;
		h2 = (double)( fEdgeFreq[ aa ][ bb ] )/(double)Npop;
		if( fEdgeFreq[ aa ][ bb ] - 1 != 0 )
		  DLoss -= h1 * log( h1 );
		DLoss += h2 * log( h2 );
		--fEdgeFreq[ aa ][ bb ];
		--fEdgeFreq[ bb ][ aa ];

		h1 = (double)( fEdgeFreq[ a1 ][ b1 ] - 1 )/(double)Npop;
		h2 = (double)( fEdgeFreq[ a1 ][ b1 ] )/(double)Npop;
		if( fEdgeFreq[ a1 ][ b1 ] - 1 != 0 )
		  DLoss -= h1 * log( h1 );
		DLoss += h2 * log( h2 );
		--fEdgeFreq[ a1 ][ b1 ];
		--fEdgeFreq[ b1 ][ a1 ];

		h1 = (double)( fEdgeFreq[ aa ][ a1 ] + 1 )/(double)Npop;
		h2 = (double)( fEdgeFreq[ aa ][ a1 ])/(double)Npop;
		DLoss -= h1 * log( h1 );
		if( fEdgeFreq[ aa ][ a1 ] != 0 )
		  DLoss += h2 * log( h2 );
		++fEdgeFreq[ aa ][ a1 ];
		++fEdgeFreq[ a1 ][ aa ];

		h1 = (double)( fEdgeFreq[ bb ][ b1 ] + 1 )/(double)Npop;
		h2 = (double)( fEdgeFreq[ bb ][ b1 ])/(double)Npop;
		DLoss -= h1 * log( h1 );
		if( fEdgeFreq[ bb ][ b1 ] != 0 )
		  DLoss += h2 * log( h2 );
		++fEdgeFreq[ bb ][ b1 ];
		++fEdgeFreq[ b1 ][ bb ];
	}
	DLoss = -DLoss;

	// 更新 EdgeFreq
	for( int s = 0; s < fNumOfAppliedCycle; ++s ){
		jnum = fAppliedCylce[ s ];

		cem = fABcycle[ jnum ][ 0 ];
		fC[ 0 ] = fABcycle[ jnum ][ 0 ];

		for( j = 1; j <= cem+3; ++j ) fC[ j ] = fABcycle[ jnum ][ j ];

		for( j = 0; j <cem/2; ++j ){
		  r1 = fC[2+2*j]; r2 = fC[3+2*j];
		  b1 = fC[1+2*j]; b2 = fC[4+2*j];

		  ++fEdgeFreq[ r1 ][ r2 ];
		  ++fEdgeFreq[ r2 ][ r1 ];
		  --fEdgeFreq[ r2 ][ b2 ];
		  --fEdgeFreq[ b2 ][ r2 ];
		}
	}
	for( int s = 0; s < fNumOfModiEdge; ++s ){
		aa = fModiEdge[ s ][ 0 ];
		bb = fModiEdge[ s ][ 1 ];
		a1 = fModiEdge[ s ][ 2 ];
		b1 = fModiEdge[ s ][ 3 ];

		++fEdgeFreq[ aa ][ bb ];
		++fEdgeFreq[ bb ][ aa ];
		++fEdgeFreq[ a1 ][ b1 ];
		++fEdgeFreq[ b1 ][ a1 ];

		--fEdgeFreq[ aa ][ a1 ];
		--fEdgeFreq[ a1 ][ aa ];
		--fEdgeFreq[ bb ][ b1 ];
		--fEdgeFreq[ b1 ][ bb ];
	}
  return DLoss;
}

void TCross::setWeight( const TIndi& tPa1, const TIndi& tPa2 ){
	int cem;
	int r1, r2, v1, v2, v_p;
	int AB_num;

	for( int i = 0; i < fN; ++i ){
		fInEffectNode[ i ][ 0 ] = -1;
		fInEffectNode[ i ][ 1 ] = -1;
	}

	// Step 1:
	for( int s = 0; s < fNumOfABcycle; ++s ){
		cem = fABcycle[ s ][ 0 ];
		for( int j = 0; j < cem/2; ++j ){
			r1 = fABcycle[ s ][ 2*j+2 ];  // red edge
			r2 = fABcycle[ s ][ 2*j+3 ];

			if( fInEffectNode[ r1 ][ 0 ] == -1 ) fInEffectNode[ r1 ][ 0 ] = s;
			else if ( fInEffectNode[ r1 ][ 1 ] == -1 ) fInEffectNode[ r1 ][ 1 ] = s;


			if( fInEffectNode[ r2 ][ 0 ] == -1 ) fInEffectNode[ r2 ][ 0 ] = s;
			else if ( fInEffectNode[ r2 ][ 1 ] == -1 ) fInEffectNode[ r2 ][ 1 ] = s;

		}
	}

	// Step 2:
	for( int i = 0; i < fN; ++i ){
		if( fInEffectNode[ i ][ 0 ] != -1 && fInEffectNode[ i ][ 1 ] == -1 ){
			AB_num = fInEffectNode[ i ][ 0 ];
			v1 = i;

			if( tPa1.fLink[ v1 ][ 0 ] != tPa2.fLink[ v1 ][ 0 ] && tPa1.fLink[ v1 ][ 0 ] != tPa2.fLink[ v1 ][ 1 ] )
				v_p = tPa1.fLink[ v1 ][ 0 ];
			else if( tPa1.fLink[ v1 ][ 1 ] != tPa2.fLink[ v1 ][ 0 ] && tPa1.fLink[ v1 ][ 1 ] != tPa2.fLink[ v1 ][ 1 ] )
				v_p = tPa1.fLink[ v1 ][ 1 ];


			while( 1 ){
				fInEffectNode[ v1 ][ 1 ] = AB_num;

				if( tPa1.fLink[ v1 ][ 0 ] != v_p ) v2 = tPa1.fLink[ v1 ][ 0 ];
				else if( tPa1.fLink[ v1 ][ 1 ] != v_p ) v2 = tPa1.fLink[ v1 ][ 1 ];


				if( fInEffectNode[ v2 ][ 0 ] == -1 ) fInEffectNode[ v2 ][ 0 ] = AB_num;
				else if( fInEffectNode[ v2 ][ 1 ] == -1 ) fInEffectNode[ v2 ][ 1 ] = AB_num;


				if( fInEffectNode[ v2 ][ 1 ] != -1 ) break;
				v_p = v1;
				v1 = v2;
			}
		}
	}

	// Step 3:

	for( int s1 = 0; s1 < fNumOfABcycle; ++s1 ){
		fWeightC[ s1 ] = 0;
		for( int s2 = 0; s2 < fNumOfABcycle; ++s2 ) fWeightRR[ s1 ][ s2 ] = 0;
	}

	for( int i = 0; i < fN; ++i ){

		if( fInEffectNode[ i ][ 0 ] != -1 && fInEffectNode[ i ][ 1 ] != -1 ){
			++fWeightRR[ fInEffectNode[ i ][ 0 ] ][ fInEffectNode[ i ][ 1 ] ];
			++fWeightRR[ fInEffectNode[ i ][ 1 ] ][ fInEffectNode[ i ][ 0 ] ];
		}
		if( fInEffectNode[ i ][ 0 ] != fInEffectNode[ i ][ 1 ] ){
			++fWeightC[ fInEffectNode[ i ][ 0 ] ];
			++fWeightC[ fInEffectNode[ i ][ 1 ] ];
		}
	}
	for( int s1 = 0; s1 < fNumOfABcycle; ++s1 ) fWeightRR[ s1 ][ s1 ] = 0;
}

int TCross::calCNaive(){
	int count_C;
	int tt;

	count_C = 0;

	for( int i = 0; i < fN; ++i ){
		if( fInEffectNode[ i ][ 0 ] != -1 && fInEffectNode[ i ][ 1 ] != -1 ){
			tt = 0;
			if( fUsedAB[ fInEffectNode[ i ][ 0 ] ] == 1 ) ++tt;
			if( fUsedAB[ fInEffectNode[ i ][ 1 ] ] == 1 ) ++tt;
			if( tt == 1 ) ++count_C;
		}
	}
	return count_C;
}

void TCross::searchEset( int centerAB ){
	int nIter, stagImp;
	int delta_weight, min_delta_weight_nt;
	int flag_AddDelete, flag_AddDelete_nt;
	int selected_AB, selected_AB_nt;
	int jnum;

	fNumC = 0;  // Number of C nodes in E-set
	fNumE = 0;  // Number of Edges in E-set

	fNumOfUsedAB = 0;
	for( int s1 = 0; s1 < fNumOfABcycle; ++s1 ){
		fUsedAB[ s1 ] = 0;
		fWeightSR[ s1 ] = 0;
		fMovedAB[ s1 ] = 0;
	}

	for( int s = 0; s < fNumOfABcycleInEset; ++s ){
		jnum = fABcycleInEset[ s ];
		this->addAB( jnum );
	}
	fBestNumC = fNumC;
	fBestNumE = fNumE;

	stagImp = 0;
	nIter = 0;
	while( 1 ){
		++nIter;
		min_delta_weight_nt = 99999999;
		flag_AddDelete = 0;
		flag_AddDelete_nt = 0;
		for( int s1 = 0; s1 < fNumOfABcycle; ++s1 ){
			if( fUsedAB[ s1 ] == 0 && fWeightSR[ s1 ] > 0 ){
				delta_weight = fWeightC[ s1 ] - 2 * fWeightSR[ s1 ];
				if( fNumC + delta_weight < fBestNumC ){
					selected_AB = s1;
					flag_AddDelete = 1;
					fBestNumC = fNumC + delta_weight;
				}
				if( delta_weight < min_delta_weight_nt && nIter > fMovedAB[ s1 ] ){
					selected_AB_nt = s1;
					flag_AddDelete_nt = 1;
					min_delta_weight_nt = delta_weight;
				}
			}
			else if( fUsedAB[ s1 ] == 1 && s1 != centerAB ){
				delta_weight = - fWeightC[ s1 ] + 2 * fWeightSR[ s1 ];
				if( fNumC + delta_weight < fBestNumC ){
					selected_AB = s1;
					flag_AddDelete = -1;
					fBestNumC = fNumC + delta_weight;
				}
				if( delta_weight < min_delta_weight_nt && nIter > fMovedAB[ s1 ] ){
					selected_AB_nt = s1;
					flag_AddDelete_nt = -1;
					min_delta_weight_nt = delta_weight;
				}
			}
		}

		if( flag_AddDelete != 0 ){
			if( flag_AddDelete == 1 ) this->addAB( selected_AB );
			else if( flag_AddDelete == -1 ) this->deleteAB( selected_AB );

			fMovedAB[ selected_AB ] = nIter + tRand->Integer( 1, fTmax );

			fBestNumE = fNumE;

			fNumOfABcycleInEset = 0;
			for( int s1 = 0; s1 < fNumOfABcycle; ++s1 )
				if( fUsedAB[ s1 ] == 1 ) fABcycleInEset[ fNumOfABcycleInEset++ ] = s1;

			stagImp = 0;
		}
		else if( flag_AddDelete_nt != 0 ) {
			if( flag_AddDelete_nt == 1 ) this->addAB( selected_AB_nt );
			else if( flag_AddDelete_nt == -1 )

			this->deleteAB( selected_AB_nt );
			fMovedAB[ selected_AB_nt ] = nIter + tRand->Integer( 1, fTmax );
		}
		if( flag_AddDelete == 0 ) ++stagImp;
		if( stagImp == fMaxStag ) break;
	}
}

void TCross::addAB( int num ){
	fNumC += fWeightC[ num ] - 2 * fWeightSR[ num ];
	fNumE += fABcycle[ num ][ 0 ] / 2;

	fUsedAB[ num ] = 1;
	++fNumOfUsedAB;
	for( int s1 = 0; s1 < fNumOfABcycle; ++s1 ) fWeightSR[ s1 ] += fWeightRR[ s1 ][ num ];
}

void TCross::deleteAB( int num ){
	fNumC -= fWeightC[ num ] - 2 * fWeightSR[ num ];
	fNumE -= fABcycle[ num ][ 0 ] / 2;

	fUsedAB[ num ] = 0;
	--fNumOfUsedAB;
	for( int s1 = 0; s1 < fNumOfABcycle; ++s1 ) fWeightSR[ s1 ] -= fWeightRR[ s1 ][ num ];
}

The file cross.h contains:
/*
 * cross.h
 *   created on: April 24, 2013
 * last updated: June 13, 2013
 *       author: liushujia
 */

#ifndef __Cross__
#define __Cross__

#ifndef __RAND__
#include "randomize.h"
#endif

#ifndef __Sort__
#include "sort.h"
#endif

#ifndef __INDI__
#include "indi.h"
#endif

#ifndef __EVALUATOR__
#include "evaluator.h"
#endif

#include <stdio.h>
#include <stdlib.h>
#include <assert.h>

class TCross{
public:
	TCross( int N );
	~TCross();
	void input_data(int N);
	void doIt( TIndi& tKid, TIndi& tPa2, int numOfKids, int flagP, int flagC[ 10 ], int** fEdgeFreq );	// EAXÃ¤Â¸Â»Ã§Â¨â€¹Ã¥Âºï¿½
	void setParents( const TIndi& tPa1, const TIndi& tPa2, int flagC[ 10 ], int numOfKids );			// Ã¨Â®Â¾Ã§Â½Â®Ã§Ë†Â¶Ã¦Å“Â¬Ã¤Â¸Å½Ã¦Â¯ï¿½Ã¦Å“Â¬
	void setABcycle( const TIndi& parent1, const TIndi& parent2, int flagC[ 10 ], int numOfKids );		// Ã¨Â®Â¾Ã§Â½Â®ABcycle

	void swap(int &x, int &y);
	void formABcycle();																// Ã¤Â¿ï¿½Ã¥Â­ËœABcycle
	void changeSol( TIndi& tKid, int ABnum, int type );								// Ã§â€�Â¨ABcycleÃ¤ÂºÂ§Ã§â€�Å¸Ã¤Â¸Â­Ã©â€”Â´Ã¨Â§Â£

	void makeCompleteSol( TIndi& tKid );					// EAXÃ§Â¬Â¬5Ã¦Â­Â¥
	void makeUnit();										// EAXÃ§Â¬Â¬5-1Ã¦Â­Â¥
	void backToPa1( TIndi& tKid );							// Ã¥â€ºÅ¾Ã¦Â»Å¡p_A
	void goToBest( TIndi& tKid );							// Ã¤Â¿Â®Ã¦â€�Â¹tKidÃ¤Â¸ÂºÃ¥Â­ï¿½Ã¤Â»Â£Ã¦Å“â‚¬Ã¤Â¼ËœÃ¨Â§Â£

	void incrementEdgeFreq( int **fEdgeFreq );				// Ã¥Â¢Å¾Ã¥Å Â fEdgeFreq[][]
	int calAdpLoss( int **fEdgeFreq );						// Ã¨Â®Â¡Ã§Â®â€”Ã¥Â¹Â³Ã¥ï¿½â€¡Ã¨Â·Â¯Ã§Â¨â€¹Ã§Å¡â€žÃ¥Â·Â®
	double calEntLoss( int **fEdgeFreq );					// Ã¨Â®Â¡Ã§Â®â€”Ã¨Â¾Â¹Ã§â€ ÂµÃ§Å¡â€žÃ¥Â·Â®

	void setWeight( const TIndi& parent1, const TIndi& parent2 );	// Block2
	int	calCNaive();
	void searchEset( int num );
	void addAB( int num );
	void deleteAB( int num );

	int fNumOfGeneratedCh;
	TEvaluator* eval;
	int Npop;

private:
//	TIndi tBestTmp;
	int fFlagImp;
	int fN;
	int total_fN;////////////////////////////////
	int r;
	int exam;
	int examFlag;
	int flagSt;
	int flagCycle;
	int prType;
	int chDis;
	int koritsuMany;
	int bunkiMany;
	int st;
	int ci;
	int pr;
	int stock;
	int stAppear;
	int fEvalType;
	int fEsetType;
	int fNumOfABcycleInESet;
	int fNumOfABcycle;
	int fPosiCurr;
	int fMaxNumOfABcycle;

	int *koritsu;
	int *bunki;
	int *koriInv;
	int *bunInv;
	int *checkKoritsu;
	int *fRoute;
	int *fPermu;
	int *fC;
	int *fJun;
	int *fOrd1;
	int *fOrd2;

	int **nearData;
	int **fABcycle;

	// Speed Up Start
	int fNumOfUnit;
	int fNumOfSeg;
	int fNumOfSPL;
	int fNumOfElementInCU;
	int fNumOfSegForCenter;
	double fGainModi;
	//int fGainModi;
	int fNumOfModiEdge;
	int fNumOfBestModiEdge;
	int fNumOfAppliedCycle;
	int fNumOfBestAppliedCycle;

	int *fOrder;
	int *fInv;
	int *fSegUnit;
	int *fSegPosiList;
	int *LinkAPosi;
	int *fPosiSeg;
	int *fNumOfElementInUnit;
	int *fCenterUnit;
	int *fListOfCenterUnit;
	int *fSegForCenter;
	//int *fGainAB;
	double *fGainAB;
	int *fAppliedCylce;
	int *fBestAppliedCylce;

	int **fSegment;
	int **LinkBPosi;
	int **fModiEdge;
	int **fBestModiEdge;
	// Speed Up End

	// Block2
	int fNumOfUsedAB;
	int fNumC;
	int fNumE;
	int fTmax;
	int fMaxStag;
	int fNumOfABcycleInEset;
	int fDisAB;
	int fBestNumC;
	int fBestNumE;

	int *fNumOfElementINAB;
	int *fWeightSR;
	int *fWeightC;
	int *fUsedAB;
	int *fMovedAB;
	int *fABcycleInEset;

	int **fInEffectNode;
	int **fWeightRR;
};

#endif

The file EAX.cpp contains:
/*
 *
 *
 *
 *
 */

#ifndef __ENVIRONMENT__
#include "environment.h"
#endif
#include<iostream>
#include <time.h>
#include <stdio.h>
#include <stdlib.h>
using namespace std;

void EAX(TEnvironment* gEnv, int * given_sol,int count, double *x_coor,double *y_coor){// given a initial tour and coordiantion
//	InitURandom(); //
	int maxNumOfTrial;
	maxNumOfTrial=1;					// repeated times
//	gEnv->Npop=100;						// number of items
//	gEnv->Nch=30;						// number of offsprings

	int opt_tour[count];
	int cc[count];
	for (int i=0;i<=count-1;i++)
		cc[i]=given_sol[i];
//	cout<<"Initializing ..."<<endl;
//	clock_t start = clock();
	gEnv->input_data(given_sol,count,x_coor,y_coor);
//	cout<<"Building solution ..."<<endl;
	for ( int n = 0; n < maxNumOfTrial; ++n ){
		gEnv->doIt();
		gEnv->writeBest(opt_tour);
	}
	int best_sol[count];
	for (int i=0;i<count;i++)
	{
		best_sol[i]=given_sol[opt_tour[i]-1];
	}
	for (int i=0;i<=count;i++)
		given_sol[i]=best_sol[i];
}

The file EAX.h contains:
/*
 * EAX.h
 *
 *  Created on: 13 Apr 2020
 *      Author: Peng
 */

#ifndef EAX_H_
#define EAX_H_

#ifndef __ENVIRONMENT__
#include "environment.h"
#endif




int EAX(TEnvironment* gEnv, int * given_sol,int count, double *x_coor,double *y_coor);





#endif /* EAX_H_ */

The file environment.cpp contains:
/*
 * environment.cpp
 *   created on: April 24, 2013
 * last updated: June 13, 2013
 *       author: liushujia
 */

#ifndef __ENVIRONMENT__
#include "environment.h"
#endif
#include "basic.h"
#include <math.h>
#include<iostream>
using namespace std;

void MakeRandSol(TEvaluator* eval, TIndi& indi);
void Make2optSol(TEvaluator* eval, TIndi& indi);

TEnvironment::TEnvironment(){
	fEvaluator = new TEvaluator();
}

TEnvironment::~TEnvironment(){
	delete [] fIndexForMating;
	delete [] tCurPop;
	int N = fEvaluator->totalCity;
	delete fEvaluator;
	delete tCross;
	delete tKopt;
	for( int i = 0; i < N; ++i ) delete [] fEdgeFreq[ i ];
	delete [] fEdgeFreq;
}
void TEnvironment::input_data(int * given_sol,int count,double *x_coor,double *y_coor)
{
	fEvaluator->setInstance1(given_sol, count,x_coor,y_coor);
	for ( int i = 0; i < Npop; ++i ) tCurPop[i].define1(count);
	tBest.define1(count);// define the best solution
	tCross->input_data(count);
	tKopt->input_data(count);
	tKopt->setInvNearList();
	tCross->Npop = Npop;
	num_nodes=count;
}

void TEnvironment::define(int count,int graph_type){
	fEvaluator->setInstance(count,graph_type);
	int N_c = fEvaluator->totalCity;//æ€»å…±ç‚¹çš„æ•°é‡�
	fIndexForMating = new int [ Npop + 1 ];
	tCurPop = new TIndi [ Npop ];// define the number of population
	for ( int i = 0; i < Npop; ++i ) tCurPop[i].define( N_c );
	tBest.define( N_c );// define the best solution
	tCross = new TCross( N_c );// define a crossover objective by using parameter N which is the number cities
	tCross->eval = fEvaluator;// probe directs it
	tKopt = new TKopt(N_c );
	tKopt->eval = fEvaluator;
	fEdgeFreq = new int* [ N_c ];
	for( int i = 0; i < N_c; ++i ) fEdgeFreq[ i ] = new int [ N_c ];
}

void TEnvironment::doIt(){
	this->fTimeStart = clock();// to calculate the initial time
	this->initPop();				// åˆ�å§‹åŒ–ç§�ç¾¤
	if (num_nodes<10){// in this place, if the number of cities is too small, the k-optis used
		this->setAverageBest();
		return;
	}
	this->fTimeInit = clock();    // initial time
	this->init();
	this->getEdgeFreq();
	no_improve=0;
	change=Max;
	while( 1 ){
		this->setAverageBest();
		if ((change-1.0e-7)>tBest.fEvaluationValue){// indicate the improvement
			change=tBest.fEvaluationValue;
			no_improve=0;
		}
		else
			no_improve++;
//		printf( "%d:\t%f\t%lf\n", fCurNumOfGen, fBestValue, fAverageValue );
		if( this->terminationCondition() || no_improve>100) break;

		this->selectForMating();
		for( int s =0; s < Npop; ++s ) this->generateKids( s );

		++fCurNumOfGen;
	}
	this->fTimeEnd = clock();
}

void TEnvironment::init(){
	fAccumurateNumCh = 0;
	fCurNumOfGen = 0;
	fStagBest = 0;
	fMaxStagBest = 0;
	fStage = 1;				// é˜¶æ®µ1
	fFlagC[ 0 ] = 4;		// ç»´æŒ�ç§�ç¾¤å¤šæ ·æ€§	1:Greedy, 2:---, 3:Distance, 4:Entropy
	fFlagC[ 1 ] = 1;		// Esetç±»åž‹			1:Single-AB, 2:Block2
}

bool TEnvironment::terminationCondition(){
	if ( fAverageValue - fBestValue < 0.00001 )  return true;
	if( fStage == 1 ){
		if( fStagBest == int(1500/Nch) && fMaxStagBest == 0 )			// 1500/Nch
			fMaxStagBest =int( fCurNumOfGen / 10 );						// fMaxStagBest = G/10
		else if( fMaxStagBest != 0 && fMaxStagBest <= fStagBest ){
			fStagBest = 0;
			fMaxStagBest = 0;
			fCurNumOfGen1 = fCurNumOfGen;
			fFlagC[ 1 ] = 2;
			fStage = 2;
		}
		return false;
	}
	if( fStage == 2 ){
		if( fStagBest == int(1500/Nch) && fMaxStagBest == 0 )			// 1500/Nch
			fMaxStagBest = int( (fCurNumOfGen - fCurNumOfGen1) / 10 );	// fMaxStagBest = G/10
		else if( fMaxStagBest != 0 && fMaxStagBest <= fStagBest ) return true;
		return false;
	}

	return true;
}

void TEnvironment::setAverageBest(){
	double stockBest = tBest.fEvaluationValue;
	//int stockBest = tBest.fEvaluationValue;
	fAverageValue = 0.0;
	fBestIndex = 0;
	fBestValue = tCurPop[0].fEvaluationValue;
	for(int i = 0; i < Npop; ++i ){
		fAverageValue += tCurPop[i].fEvaluationValue;
		if( tCurPop[i].fEvaluationValue < fBestValue ){
			fBestIndex = i;
			fBestValue = tCurPop[i].fEvaluationValue;
		}
	}
	tBest = tCurPop[ fBestIndex ];
	fAverageValue /= (double)Npop;
	if( tBest.fEvaluationValue < stockBest ){
		fStagBest = 0;
		fBestNumOfGen = fCurNumOfGen;
		fBestAccumeratedNumCh = fAccumurateNumCh;
	}
	else ++fStagBest;
}

void TEnvironment::initPop(){
	for ( int i = 0; i < Npop; ++i ){
		tKopt->makeRandSol( tCurPop[ i ] );		// è®¾ç½®ä¸€ä¸ªéš�æœºè·¯ç¨‹
		tKopt->doIt( tCurPop[ i ] );			// å±€éƒ¨æ�œç´¢(2-opt neighborhood)
	}
}

void TEnvironment::selectForMating(){
	tRand->permutation( fIndexForMating, Npop, Npop );
	fIndexForMating[ Npop ] = fIndexForMating[ 0 ];
}

void TEnvironment::generateKids( int s ){
	// tCurPop[fIndexForMating[s]] è¢«æ›¿æ�¢ä¸ºtCross->DoIt()ä¸­å­�ä»£çš„ä¸€ä¸ªæœ€ä¼˜è§£
	// fEdgeFreq[][] å�Œæ—¶è¢«æ›´æ–°
	tCross->setParents( tCurPop[fIndexForMating[s]], tCurPop[fIndexForMating[s+1]], fFlagC, Nch );
	tCross->doIt( tCurPop[fIndexForMating[s]], tCurPop[fIndexForMating[s+1]], Nch, 1, fFlagC, fEdgeFreq );
	fAccumurateNumCh += tCross->fNumOfGeneratedCh;
}

void TEnvironment::getEdgeFreq(){
	int  k0, k1, N = fEvaluator->Ncity;
	for( int j1 = 0; j1 < N; ++j1 )
		for( int j2 = 0; j2 < N; ++j2 )
			fEdgeFreq[ j1 ][ j2 ] = 0;

	for( int i = 0; i < Npop; ++i )
		for(int j = 0; j < N; ++j ){
			k0 = tCurPop[ i ].fLink[ j ][ 0 ];
			k1 = tCurPop[ i ].fLink[ j ][ 1 ];
			++fEdgeFreq[ j ][ k0 ];
			++fEdgeFreq[ j ][ k1 ];
		}
}

void TEnvironment::printOn( int n ){
	printf( "n = %d val = %f Gen = %d Time = %d %d\n" , n, tBest.fEvaluationValue, fCurNumOfGen,
		(int)((double)(this->fTimeInit - this->fTimeStart)/(double)CLOCKS_PER_SEC),
		(int)((double)(this->fTimeEnd - this->fTimeStart)/(double)CLOCKS_PER_SEC) );
//	fflush(stdout);

}

void TEnvironment::writeBest(int *given_sol){
//	FILE *fp;
//	char filename[ 80 ];

//	sprintf( filename, "bestSolution.txt" );
//	fp = fopen( filename, "a");
	fEvaluator->writeTo(given_sol, tBest );
//	fclose( fp );
}

The file environment.h contains:

/*
 * environment.h
 *   created on: April 24, 2013
 * last updated: June 13, 2013
 *       author: liushujia
 */

#ifndef __ENVIRONMENT__
#define __ENVIRONMENT__

#ifndef __INDI__
#include "indi.h"
#endif

#ifndef __RAND__
#include "randomize.h"
#endif

#ifndef __EVALUATOR__
#include "evaluator.h"
#endif

#ifndef __Cross__
#include "cross.h"
#endif

#ifndef __KOPT__
#include "kopt.h"
#endif

#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <string.h>
#include <time.h>

class TEnvironment{
public:
	TEnvironment();
	~TEnvironment();
	void input_data(int * given_sol,int count,double *x_coor,double *y_coor);
	void define(int count,int graph_type);						// ÃƒÂ¥Ã‹â€ Ã¯Â¿Â½ÃƒÂ¥Ã‚Â§Ã¢â‚¬Â¹ÃƒÂ¥Ã…â€™Ã¢â‚¬â€œ
	//void define();						// ÃƒÂ¥Ã‹â€ Ã¯Â¿Â½ÃƒÂ¥Ã‚Â§Ã¢â‚¬Â¹ÃƒÂ¥Ã…â€™Ã¢â‚¬â€œ
	void doIt();						// GAÃƒÂ¤Ã‚Â¸Ã‚Â»ÃƒÂ§Ã‚Â¨Ã¢â‚¬Â¹ÃƒÂ¥Ã‚ÂºÃ¯Â¿Â½
	void init();						// GAÃƒÂ¥Ã‹â€ Ã¯Â¿Â½ÃƒÂ¥Ã‚Â§Ã¢â‚¬Â¹ÃƒÂ¥Ã…â€™Ã¢â‚¬â€œ
	bool terminationCondition();		// ÃƒÂ©Ã¢â€šÂ¬Ã¢â€šÂ¬ÃƒÂ¥Ã¢â‚¬Â¡Ã‚ÂºÃƒÂ¦Ã¯Â¿Â½Ã‚Â¡ÃƒÂ¤Ã‚Â»Ã‚Â¶
	void setAverageBest();				// ÃƒÂ¨Ã‚Â®Ã‚Â¡ÃƒÂ§Ã‚Â®Ã¢â‚¬â€�ÃƒÂ§Ã‚Â§Ã¯Â¿Â½ÃƒÂ§Ã‚Â¾Ã‚Â¤ÃƒÂ¥Ã‚Â¹Ã‚Â³ÃƒÂ¥Ã¯Â¿Â½Ã¢â‚¬Â¡TSPÃƒÂ©Ã¢â‚¬Â¢Ã‚Â¿ÃƒÂ¥Ã‚ÂºÃ‚Â¦ÃƒÂ¤Ã‚Â¸Ã…Â½ÃƒÂ§Ã‚Â§Ã¯Â¿Â½ÃƒÂ§Ã‚Â¾Ã‚Â¤ÃƒÂ¦Ã…â€œÃ¢â€šÂ¬ÃƒÂ¤Ã‚Â¼Ã‹Å“TSPÃƒÂ©Ã¢â‚¬Â¢Ã‚Â¿ÃƒÂ¥Ã‚ÂºÃ‚Â¦

	void initPop();						// ÃƒÂ¥Ã‹â€ Ã¯Â¿Â½ÃƒÂ¥Ã‚Â§Ã¢â‚¬Â¹ÃƒÂ¥Ã…â€™Ã¢â‚¬â€œÃƒÂ§Ã‚Â§Ã¯Â¿Â½ÃƒÂ§Ã‚Â¾Ã‚Â¤
	void selectForMating();				// ÃƒÂ©Ã¢â€šÂ¬Ã¢â‚¬Â°ÃƒÂ¦Ã¢â‚¬Â¹Ã‚Â©ÃƒÂ§Ã‹â€ Ã‚Â¶ÃƒÂ¦Ã…â€œÃ‚Â¬ÃƒÂ¤Ã‚Â¸Ã…Â½ÃƒÂ¦Ã‚Â¯Ã¯Â¿Â½ÃƒÂ¦Ã…â€œÃ‚Â¬
	void generateKids( int s );			// ÃƒÂ¤Ã‚ÂºÃ‚Â§ÃƒÂ§Ã¢â‚¬ï¿½Ã…Â¸ÃƒÂ¥Ã‚Â¹Ã‚Â¶ÃƒÂ©Ã¢â€šÂ¬Ã¢â‚¬Â°ÃƒÂ¦Ã¢â‚¬Â¹Ã‚Â©ÃƒÂ¥Ã‚Â­Ã¯Â¿Â½ÃƒÂ¤Ã‚Â»Ã‚Â£
	void getEdgeFreq();					// ÃƒÂ¨Ã‚Â®Ã‚Â¡ÃƒÂ§Ã‚Â®Ã¢â‚¬â€�ÃƒÂ§Ã‚Â§Ã¯Â¿Â½ÃƒÂ§Ã‚Â¾Ã‚Â¤ÃƒÂ¤Ã‚Â¸Ã‚Â­ÃƒÂ¦Ã‚Â¯Ã¯Â¿Â½ÃƒÂ¦Ã¯Â¿Â½Ã‚Â¡ÃƒÂ¨Ã‚Â¾Ã‚Â¹ÃƒÂ§Ã…Â¡Ã¢â‚¬Å¾ÃƒÂ©Ã‚Â¢Ã¢â‚¬ËœÃƒÂ§Ã…Â½Ã¢â‚¬Â¡

	void printOn( int n );				// ÃƒÂ¨Ã‚Â¾Ã¢â‚¬Å“ÃƒÂ¥Ã¢â‚¬Â¡Ã‚ÂºÃƒÂ§Ã‚Â»Ã¢â‚¬Å“ÃƒÂ¦Ã…Â¾Ã…â€œ
	void writeBest(int *given_sol);					// ÃƒÂ¨Ã‚Â¾Ã¢â‚¬Å“ÃƒÂ¥Ã¢â‚¬Â¡Ã‚ÂºÃƒÂ¦Ã…â€œÃ¢â€šÂ¬ÃƒÂ¤Ã‚Â¼Ã‹Å“TSPÃƒÂ¨Ã‚Â·Ã‚Â¯ÃƒÂ¥Ã‚Â¾Ã¢â‚¬Å¾
	//void writeBest();					// ÃƒÂ¨Ã‚Â¾Ã¢â‚¬Å“ÃƒÂ¥Ã¢â‚¬Â¡Ã‚ÂºÃƒÂ¦Ã…â€œÃ¢â€šÂ¬ÃƒÂ¤Ã‚Â¼Ã‹Å“TSPÃƒÂ¨Ã‚Â·Ã‚Â¯ÃƒÂ¥Ã‚Â¾Ã¢â‚¬Å¾

	TEvaluator* fEvaluator;				// ÃƒÂ¨Ã‚Â¾Ã‚Â¹ÃƒÂ¨Ã‚Â·Ã¯Â¿Â½ÃƒÂ§Ã‚Â¦Ã‚Â»
	TCross* tCross;						// ÃƒÂ¨Ã‚Â¾Ã‚Â¹ÃƒÂ©Ã¢â‚¬ÂºÃ¢â‚¬Â ÃƒÂ¥Ã¯Â¿Â½Ã‹â€ ÃƒÂ¤Ã‚ÂºÃ‚Â¤ÃƒÂ¥Ã¯Â¿Â½Ã¢â‚¬Â°
	TKopt* tKopt;						// ÃƒÂ¥Ã‚Â±Ã¢â€šÂ¬ÃƒÂ©Ã†â€™Ã‚Â¨ÃƒÂ¦Ã¯Â¿Â½Ã…â€œÃƒÂ§Ã‚Â´Ã‚Â¢(2-opt neighborhood)
//	char *fFileNameTSP;					// TSPÃƒÂ¦Ã¢â‚¬â€œÃ¢â‚¬Â¡ÃƒÂ¤Ã‚Â»Ã‚Â¶ÃƒÂ¥Ã¯Â¿Â½Ã¯Â¿Â½

	int Npop;							// ÃƒÂ§Ã‚Â§Ã¯Â¿Â½ÃƒÂ§Ã‚Â¾Ã‚Â¤ÃƒÂ¦Ã¢â‚¬Â¢Ã‚Â°ÃƒÂ©Ã¢â‚¬Â¡Ã¯Â¿Â½
	int Nch;							// ÃƒÂ¦Ã‚Â¯Ã¯Â¿Â½ÃƒÂ¤Ã‚Â¸Ã‚ÂªÃƒÂ§Ã‹â€ Ã‚Â¶ÃƒÂ¦Ã…â€œÃ‚Â¬(ÃƒÂ¦Ã‚Â¯Ã¯Â¿Â½ÃƒÂ¦Ã…â€œÃ‚Â¬)ÃƒÂ¤Ã‚ÂºÃ‚Â§ÃƒÂ§Ã¢â‚¬ï¿½Ã…Â¸ÃƒÂ§Ã…Â¡Ã¢â‚¬Å¾ÃƒÂ¥Ã‚Â­Ã¯Â¿Â½ÃƒÂ¤Ã‚Â»Ã‚Â£ÃƒÂ¦Ã¢â‚¬Â¢Ã‚Â°ÃƒÂ©Ã¢â‚¬Â¡Ã¯Â¿Â½
	TIndi* tCurPop;						// ÃƒÂ¥Ã‚Â½Ã¢â‚¬Å“ÃƒÂ¥Ã¢â‚¬Â°Ã¯Â¿Â½ÃƒÂ§Ã‚Â§Ã¯Â¿Â½ÃƒÂ§Ã‚Â¾Ã‚Â¤ÃƒÂ¦Ã‹â€ Ã¯Â¿Â½ÃƒÂ¥Ã¢â‚¬ËœÃ‹Å“
	TIndi tBest;						// ÃƒÂ¥Ã‚Â½Ã¢â‚¬Å“ÃƒÂ¥Ã¢â‚¬Â°Ã¯Â¿Â½ÃƒÂ§Ã‚Â§Ã¯Â¿Â½ÃƒÂ§Ã‚Â¾Ã‚Â¤ÃƒÂ¦Ã…â€œÃ¢â€šÂ¬ÃƒÂ¤Ã‚Â¼Ã‹Å“ÃƒÂ¨Ã‚Â§Ã‚Â£
	int fCurNumOfGen;					// ÃƒÂ¥Ã‚Â½Ã¢â‚¬Å“ÃƒÂ¥Ã¢â‚¬Â°Ã¯Â¿Â½ÃƒÂ§Ã‚Â§Ã¯Â¿Â½ÃƒÂ§Ã‚Â¾Ã‚Â¤ÃƒÂ¤Ã‚Â»Ã‚Â£ÃƒÂ¦Ã¢â‚¬Â¢Ã‚Â°
	long int fAccumurateNumCh;			// ÃƒÂ¥Ã‚Â­Ã¯Â¿Â½ÃƒÂ¤Ã‚Â»Ã‚Â£ÃƒÂ§Ã‚Â´Ã‚Â¯ÃƒÂ¨Ã‚Â®Ã‚Â¡ÃƒÂ¦Ã¢â‚¬Â¢Ã‚Â°ÃƒÂ§Ã¢â‚¬ÂºÃ‚Â®

	int fBestNumOfGen;					// ÃƒÂ¥Ã‚Â½Ã¢â‚¬Å“ÃƒÂ¥Ã¢â‚¬Â°Ã¯Â¿Â½ÃƒÂ¦Ã…â€œÃ¢â€šÂ¬ÃƒÂ¤Ã‚Â¼Ã‹Å“ÃƒÂ¨Ã‚Â§Ã‚Â£ÃƒÂ¦Ã¢â‚¬Â°Ã¢â€šÂ¬ÃƒÂ¥Ã…â€œÃ‚Â¨ÃƒÂ§Ã…Â¡Ã¢â‚¬Å¾ÃƒÂ¤Ã‚Â»Ã‚Â£ÃƒÂ¦Ã¢â‚¬Â¢Ã‚Â°
	long int fBestAccumeratedNumCh;		// ÃƒÂ¥Ã‚Â½Ã¢â‚¬Å“ÃƒÂ¥Ã¢â‚¬Â°Ã¯Â¿Â½ÃƒÂ¦Ã…â€œÃ¢â€šÂ¬ÃƒÂ¤Ã‚Â¼Ã‹Å“ÃƒÂ¨Ã‚Â§Ã‚Â£ÃƒÂ§Ã…Â¡Ã¢â‚¬Å¾ÃƒÂ¥Ã‚Â­Ã¯Â¿Â½ÃƒÂ¤Ã‚Â»Ã‚Â£ÃƒÂ§Ã‚Â´Ã‚Â¯ÃƒÂ¨Ã‚Â®Ã‚Â¡ÃƒÂ¦Ã¢â‚¬Â¢Ã‚Â°ÃƒÂ§Ã¢â‚¬ÂºÃ‚Â®
	int **fEdgeFreq;					// ÃƒÂ§Ã‚Â§Ã¯Â¿Â½ÃƒÂ§Ã‚Â¾Ã‚Â¤ÃƒÂ§Ã…Â¡Ã¢â‚¬Å¾ÃƒÂ¨Ã‚Â¾Ã‚Â¹ÃƒÂ©Ã‚Â¢Ã¢â‚¬ËœÃƒÂ§Ã…Â½Ã¢â‚¬Â¡
	double fAverageValue;				// ÃƒÂ§Ã‚Â§Ã¯Â¿Â½ÃƒÂ§Ã‚Â¾Ã‚Â¤TSPÃƒÂ¨Ã‚Â·Ã‚Â¯ÃƒÂ¥Ã‚Â¾Ã¢â‚¬Å¾ÃƒÂ§Ã…Â¡Ã¢â‚¬Å¾ÃƒÂ¥Ã‚Â¹Ã‚Â³ÃƒÂ¥Ã¯Â¿Â½Ã¢â‚¬Â¡ÃƒÂ©Ã¢â‚¬Â¢Ã‚Â¿ÃƒÂ¥Ã‚ÂºÃ‚Â¦
	double fBestValue;						// ÃƒÂ§Ã‚Â§Ã¯Â¿Â½ÃƒÂ§Ã‚Â¾Ã‚Â¤ÃƒÂ¦Ã…â€œÃ¢â€šÂ¬ÃƒÂ¤Ã‚Â¼Ã‹Å“ÃƒÂ¨Ã‚Â§Ã‚Â£ÃƒÂ§Ã…Â¡Ã¢â‚¬Å¾ÃƒÂ¨Ã‚Â·Ã‚Â¯ÃƒÂ¥Ã‚Â¾Ã¢â‚¬Å¾ÃƒÂ©Ã¢â‚¬Â¢Ã‚Â¿ÃƒÂ¥Ã‚ÂºÃ‚Â¦  //int fBestValue;						// ÃƒÂ§Ã‚Â§Ã¯Â¿Â½ÃƒÂ§Ã‚Â¾Ã‚Â¤ÃƒÂ¦Ã…â€œÃ¢â€šÂ¬ÃƒÂ¤Ã‚Â¼Ã‹Å“ÃƒÂ¨Ã‚Â§Ã‚Â£ÃƒÂ§Ã…Â¡Ã¢â‚¬Å¾ÃƒÂ¨Ã‚Â·Ã‚Â¯ÃƒÂ¥Ã‚Â¾Ã¢â‚¬Å¾ÃƒÂ©Ã¢â‚¬Â¢Ã‚Â¿ÃƒÂ¥Ã‚ÂºÃ‚Â¦
	int fBestIndex;						// ÃƒÂ¦Ã…â€œÃ¢â€šÂ¬ÃƒÂ¤Ã‚Â¼Ã‹Å“ÃƒÂ§Ã‚Â§Ã¯Â¿Â½ÃƒÂ§Ã‚Â¾Ã‚Â¤ÃƒÂ§Ã…Â¡Ã¢â‚¬Å¾ÃƒÂ¤Ã‚Â¸Ã¢â‚¬Â¹ÃƒÂ¦Ã‚Â Ã¢â‚¬Â¡

	int* fIndexForMating;				// ÃƒÂ¤Ã‚ÂºÃ‚Â¤ÃƒÂ¥Ã¯Â¿Â½Ã¢â‚¬Â°ÃƒÂ¥Ã‹â€ Ã¢â‚¬â€�ÃƒÂ¨Ã‚Â¡Ã‚Â¨(r[])
	int fStagBest;						// ÃƒÂ¥Ã‚Â­Ã¯Â¿Â½ÃƒÂ¤Ã‚Â»Ã‚Â£ÃƒÂ¦Ã…â€œÃ¢â€šÂ¬ÃƒÂ¤Ã‚Â¼Ã‹Å“ÃƒÂ¨Ã‚Â§Ã‚Â£ÃƒÂ¦Ã‚Â²Ã‚Â¡ÃƒÂ¦Ã…â€œÃ¢â‚¬Â°ÃƒÂ¦Ã¯Â¿Â½Ã¯Â¿Â½ÃƒÂ¥Ã¯Â¿Â½Ã¢â‚¬Â¡ÃƒÂ§Ã…Â¡Ã¢â‚¬Å¾ÃƒÂ§Ã‚Â´Ã‚Â¯ÃƒÂ¨Ã‚Â®Ã‚Â¡ÃƒÂ¤Ã‚Â»Ã‚Â£ÃƒÂ¦Ã¢â‚¬Â¢Ã‚Â°
	int fFlagC[ 10 ];					// EAXÃƒÂ¦Ã¢â‚¬â€œÃ‚Â¹ÃƒÂ¥Ã‚Â¼Ã¯Â¿Â½ÃƒÂ¤Ã‚Â¸Ã…Â½ÃƒÂ©Ã¢â€šÂ¬Ã¢â‚¬Â°ÃƒÂ¦Ã¢â‚¬Â¹Ã‚Â©ÃƒÂ§Ã‚Â­Ã¢â‚¬â€œÃƒÂ§Ã¢â‚¬Â¢Ã‚Â¥
	int fStage;							// ÃƒÂ¥Ã‚Â½Ã¢â‚¬Å“ÃƒÂ¥Ã¢â‚¬Â°Ã¯Â¿Â½ÃƒÂ©Ã‹Å“Ã‚Â¶ÃƒÂ¦Ã‚Â®Ã‚Âµ
	int fMaxStagBest;					// fStagBest==fMaxStagBestÃƒÂ¦Ã¢â‚¬â€�Ã‚Â¶ÃƒÂ¦Ã¢â‚¬Â°Ã‚Â§ÃƒÂ¨Ã‚Â¡Ã…â€™ÃƒÂ¤Ã‚Â¸Ã¢â‚¬Â¹ÃƒÂ¤Ã‚Â¸Ã¢â€šÂ¬ÃƒÂ©Ã‹Å“Ã‚Â¶ÃƒÂ¦Ã‚Â®Ã‚Âµ
	int fCurNumOfGen1;					// Stage IÃƒÂ§Ã‚Â»Ã¢â‚¬Å“ÃƒÂ¦Ã¯Â¿Â½Ã…Â¸ÃƒÂ¦Ã¢â‚¬â€�Ã‚Â¶ÃƒÂ§Ã…Â¡Ã¢â‚¬Å¾ÃƒÂ§Ã‚Â§Ã¯Â¿Â½ÃƒÂ§Ã‚Â¾Ã‚Â¤ÃƒÂ¤Ã‚Â»Ã‚Â£ÃƒÂ¦Ã¢â‚¬Â¢Ã‚Â°

	clock_t fTimeStart, fTimeInit, fTimeEnd;	// ÃƒÂ¤Ã‚Â¿Ã¯Â¿Â½ÃƒÂ¥Ã‚Â­Ã‹Å“ÃƒÂ¨Ã‚Â®Ã‚Â¡ÃƒÂ§Ã‚Â®Ã¢â‚¬â€�ÃƒÂ¦Ã¢â‚¬â€�Ã‚Â¶ÃƒÂ©Ã¢â‚¬â€�Ã‚Â´
private:
	int no_improve;
	double change;
	int num_nodes;
};

#endif

The file evaluator.cpp contains:
/*
 * evaluator.cpp
 *   created on: April 24, 2013
 * last updated: June 13, 2013
 *       author: liushujia
 */

#ifndef __EVALUATOR__
#include "evaluator.h"
#endif
TEvaluator::TEvaluator(){
	fEdgeDis = NULL;
	fNearCity = NULL;
	Ncity = 0;
	fNearNumMax = 50;
}

TEvaluator::~TEvaluator(){
	for ( int i = 0; i < totalCity; ++i ) delete[] fEdgeDis[ i ];
	delete[] fEdgeDis;

	for ( int i = 0; i < totalCity; ++i ) delete[] fNearCity[ i ];
	delete[] fNearCity;

	delete [] x;
	delete [] y;
}
void TEvaluator::setInstance(int count ,int graph_type){
	totalCity=count;
	graph_t=graph_type;
	x = new double [ totalCity ];
	y = new double [ totalCity ];
	fEdgeDis = new double * [totalCity];
	for( int i = 0; i < totalCity; ++i ) fEdgeDis[ i ] = new double [ totalCity ];//fEdgeDis[ i ] = new int [ Ncity ];
	fNearCity = new int* [ totalCity ];
	for( int i = 0; i < totalCity; ++i ) fNearCity[ i ] = new int [ fNearNumMax+1 ];
}
void TEvaluator::setInstance1( int * given_sol,int count,double *x_coor,double *y_coor){
	Ncity=count;
	int *checkedN = new int[Ncity];// dynamic array with a probe
	for (int i=0;i<Ncity;++i)
	{
		x[i]=x_coor[given_sol[i]];
		y[i]=y_coor[given_sol[i]];
	}
	// calculate the distance matrix
	if (graph_t==1){
		for( int i = 0; i < Ncity ; ++i )
			for( int j = 0; j < Ncity ; ++j )
				fEdgeDis[ i ][ j ]=(sqrt((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j])));
	}
	if (graph_t==2){
		for( int i = 0; i < Ncity ; ++i )
			for( int j = 0; j < Ncity ; ++j ){
				double r = (sqrt(((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j]))/10.0));
				int t = (int)r;
				if( (double)t < r ) {
					fEdgeDis[ i ][ j ] = t+1;
				}
				else {
					fEdgeDis[ i ][ j ] = t;
				}
				//fEdgeDis[ i ][ j ]=ceil(sqrt((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j])));
			}
	}
	if (graph_t==3){
		for( int i = 0; i < Ncity ; ++i )
			for( int j = 0; j < Ncity ; ++j )
				fEdgeDis[ i ][ j ]=ceil(sqrt((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j])));
	}

	if (graph_t==4){
		double q1,q2,q3;
		double RRR = 6378.388;
		double latitude[Ncity];
		double longitude[Ncity];
		double min;
		double deg;
		double PI=3.141592;
		for (int i=0;i<Ncity;i++){
			deg=int(x[i]);
			min=x[i]-deg;
			latitude[i]=PI * (deg + 5.0 * min / 3.0 ) / 180.0;
			deg=int(y[i]);
			min=y[i]-deg;
			longitude[i]=PI * (deg + 5.0 * min / 3.0 ) / 180.0;
		}
		for (int i=0;i<Ncity;i++)
			for (int j=0;j<Ncity;j++){
				q1 = cos( longitude[i] - longitude[j] );
				q2 = cos( latitude[i] - latitude[j] );
				q3 = cos( latitude[i] + latitude[j] );
				fEdgeDis[i][j] = (int) ( RRR * acos( 0.5*((1.0+q1)*q2 - (1.0-q1)*q3) ) + 1.0);
			}
	}


	int ci, j1, j2, j3;
	int cityNum = 0;
	double minDis;
	//int minDis;
	for( ci = 0; ci < Ncity; ++ci ){      // find the neareat nodes for all nodes
		for( j3 = 0; j3 < Ncity; ++j3 ) checkedN[ j3 ] = 0;
		checkedN[ ci ] = 1;
		fNearCity[ ci ][ 0 ] = ci;
		for( j1 = 1; j1 <= fNearNumMax; ++j1 ) {
			minDis = 100000000;
			for( j2 = 0; j2 < Ncity; ++j2 ){
				if( fEdgeDis[ ci ][ j2 ] <= minDis && checkedN[ j2 ] == 0 ){
					cityNum = j2;
					minDis = fEdgeDis[ ci ][ j2 ];
				}
			}
			fNearCity[ ci ][ j1 ] = cityNum;
			checkedN[ cityNum ] = 1;
		}
	}
	delete [] checkedN;
}

void TEvaluator::doIt( TIndi& indi ){
	double d = 0;
	//int d = 0;
	for( int i = 0; i < Ncity; ++i ) d += fEdgeDis[ i ][ indi.fLink[i][0] ] + fEdgeDis[ i ][ indi.fLink[i][1] ];
	indi.fEvaluationValue = d/2;
}

void TEvaluator::writeTo( int * given_sol, TIndi& indi ){
	int *Array=new int[Ncity];
	int curr=0, st=0, count=0, pre=-1, next;
	while( 1 ){
		Array[ count++ ] = curr + 1;
		if( count > Ncity ){
			printf( "Invalid\n" );
			return;
		}
		if( indi.fLink[ curr ][ 0 ] == pre ) next = indi.fLink[ curr ][ 1 ];
		else next = indi.fLink[ curr ][ 0 ];

		pre = curr;
		curr = next;
		if( curr == st ) break;
	}
	if( this->checkValid( Array, indi.fEvaluationValue ) == false )
		printf( "Individual is invalid \n" );
	for( int i = 0; i < indi.fN; ++i )
		given_sol[i]=Array[i];
	delete [] Array;
}

bool TEvaluator::checkValid( int* array, double value ){
	int *check=new int[Ncity];
	for( int i = 0; i < Ncity; ++i ) check[ i ] = 0;
	for( int i = 0; i < Ncity; ++i ) ++check[ array[ i ]-1 ];
	for( int i = 0; i < Ncity; ++i )
		if( check[ i ] != 1 ) return false;
	double distance = 0;
	for( int i = 0; i < Ncity-1; ++i )
		distance += fEdgeDis[ array[ i ]-1 ][ array[ i+1 ]-1 ];

	distance += fEdgeDis[ array[ Ncity-1 ]-1 ][ array[ 0 ]-1 ];

	delete [] check;
	if( abs(distance - value)>1.0e-7 ) return false;
	//if( distance != value ) return false;
	return true;
}


The file evaluator.h contains:
/*
 * evaluator.h
 *   created on: April 24, 2013
 * last updated: June 13, 2013
 *       author: liushujia
 */

#ifndef __EVALUATOR__
#define __EVALUATOR__

#ifndef __INDI__
#include "indi.h"
#endif

#include <string.h>
#include <assert.h>

class TEvaluator{
public:
	TEvaluator();
	~TEvaluator();
	void setInstance(int count,int graph_type);		// è®¾ç½®å�˜é‡�
	void setInstance1( int * given_sol,int count,double *x_coor,double *y_coor);		// è®¾ç½®å�˜é‡�
	//void setInstance( char filename[] );		// è®¾ç½®å�˜é‡�
	void doIt( TIndi& indi );					// è®¾ç½®indi.fEvaluationValue
	void writeTo( int * given_sol, TIndi& indi );		// è¾“å‡ºTSPè·¯å¾„
	bool checkValid( int* array, double value );	// æ£€æŸ¥TSPè·¯å¾„å�ˆæ³•æ€§

	int fNearNumMax;	// è¿‘é‚»ç‚¹æ•°ç›®çš„æœ€å¤§å€¼
	int **fNearCity;	// NearCity[i][k]è¡¨ç¤ºè·�ç¦»iæœ€è¿‘çš„ç¬¬kä¸ªåŸŽå¸‚
	double **fEdgeDis;		// EdgeDis[i][j]è¡¨ç¤ºåŸŽå¸‚iåˆ°jçš„è·�ç¦»
	int Ncity;			// åŸŽå¸‚æ•°ç›®
	int totalCity;
	double *x;			// x[i]è¡¨ç¤ºç¬¬iä¸ªåŸŽå¸‚çš„xå��æ ‡
	double *y;			// y[i]è¡¨ç¤ºç¬¬iä¸ªåŸŽå¸‚çš„yå��æ ‡

	int graph_t;
//	int *Array;			// æœ€ä¼˜è§£çš„èŠ‚ç‚¹æ ‡å�·
};

#endif

The file indi.cpp contains:
/*
 * indi.cpp
 *   created on: April 24, 2013
 * last updated: June 13, 2013
 *       author: liushujia
 */


#ifndef __INDI__
#include "indi.h"
#endif

TIndi::TIndi(){
	fN = 0;
	fLink = NULL;
	fEvaluationValue = 0;
}

TIndi::~TIndi(){
	for ( int i = 0; i < total_fN; ++i ) delete[] fLink[ i ];
	delete[] fLink;
}
void TIndi::define1( int N ){
	fN = N;
}
void TIndi::define( int N ){
	total_fN=N;
	fLink = new int* [ total_fN ];
	for( int i = 0; i < total_fN; ++i ) fLink[ i ] = new int [ 2 ];
}

TIndi& TIndi::operator = ( const TIndi& src ){
	fN = src.fN;
	for ( int i = 0; i < fN; ++i )
		for ( int j = 0; j < 2; ++j ) fLink[i][j] = src.fLink[i][j];
	fEvaluationValue = src.fEvaluationValue;
	return *this;
}

bool TIndi::operator == ( const TIndi& src ){
	int curr, next, pre, flag_identify;

	if( fN != src.fN ) return false;
	if( fEvaluationValue != src.fEvaluationValue ) return false;

	curr = 0;
	pre = -1;
	for( int i = 0; i < fN; ++i ){
		if( fLink[curr][0] == pre ) next = fLink[curr][1];
		else next = fLink[curr][0];

		if( src.fLink[curr][0] != next && src.fLink[curr][1] != next ) return false;
		pre = curr;
		curr = next;
	}
	return true;
}


The file indi.h contains:
/*
 * indi.h
 *   created on: April 24, 2013
 * last updated: June 13, 2013
 *       author: liushujia
 */

#ifndef __INDI__
#define __INDI__

#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>

class TIndi{
public:
	TIndi();
	~TIndi();
	void define1( int N );
	void define( int N );
	TIndi& operator = ( const TIndi& src );
	bool operator == (  const TIndi& indi2 );	// åˆ¤æ–­ä¸¤è·¯å¾„æ˜¯å�¦ç›¸å�Œ

	int total_fN;
	int fN;						// åŸŽå¸‚æ•°ç›®
	int** fLink;				// fLink[i][]è¡¨ç¤ºè·¯å¾„ä¸­içš„ä¸¤ä¸ªç›¸é‚»çš„åŸŽå¸‚     double linked list
	double fEvaluationValue;		// TSPè·¯å¾„é•¿åº¦
	//int fEvaluationValue;		// TSPè·¯å¾„é•¿åº¦
};

#endif

The file Individual.cpp contains:
/*
 * Indi.cpp
 *
 *  Created on: 18 Apr 2020
 *      Author: Peng
 */

#include "Individual.h"

Individual::Individual() {

}
Individual::~Individual() {
	for (int i=0;i<=v_num-1;i++)
	{
		delete [] sol[i];
		delete [] sol_r[i];
	}
	delete [] sol;
	delete [] sol_r;
}
void Individual::define(int number_nodes,int number_vehicles){
	num_v=number_nodes;
	v_num=number_vehicles;
	sol=new int *[v_num];
	sol_r=new int *[v_num];
	for (int i=0;i<=v_num-1;i++)
	{
		sol[i]=new int [num_v+1];
		sol_r[i]=new int [num_v+1];
	}
}

The file Individual.h contains:
/*
 * Indi.h
 *
 *  Created on: 18 Apr 2020
 *      Author: Peng
 */

#ifndef INDIVIDUAL_H_
#define INDIVIDUAL_H_

class Individual {
public:
	Individual();
	virtual ~Individual();
	void define(int number_nodes,int number_vehicles);
	int ** sol;
	int ** sol_r;
	int num_v;
	int v_num;
	int num_s;
	double fitness;

};

#endif /* INDI_H_ */

The file initialsol.cpp contains:
/*
 * initialsol.cpp
 *
 *  Created on: 17 Apr 2020
 *      Author: Pengfei He
 */
#include "basic.h"
#include "initialsol.h"
initial_sol::initial_sol() {
}

initial_sol::~initial_sol() {
	// TODO Auto-generated destructor stub
}
void initial_sol::greedy_fun(){
	for (int i=0;i<=I_data->v_num-1;i++){
		for (int j=0;j<=I_data->num_v;j++)
			s->sol[i][j]=-1;
		s->sol[i][0]=0;
	}
	vector <  int > node;
	for (int i=1;i<=I_data->num_v;i++)
		node.push_back(i);
	random_shuffle(node.begin(), node.end());
	for (int i=0;i<=I_data->v_num-1;i++){
		s->sol[i][0]=node[i];
		s->sol[i][node[i]]=0;
	}
	int pointer,tem;
	int row,pos;double delta,delta_tem;
	int size_node=node.size();
	for (int i=I_data->v_num;i<=size_node-1;i++){
		delta=Max;
		int j=0;
//		for (int j=0;j<=I_data->v_num-1;j++){
			pointer=0;
			while(1){
				delta_tem=I_data->Distance[node[i]][pointer]+I_data->Distance[node[i]][s->sol[j][pointer]]-
						I_data->Distance[pointer][s->sol[j][pointer]];
				if (delta>delta_tem){
					row=j;
					pos=pointer;
					delta=delta_tem;
				}
				pointer=s->sol[j][pointer];
				if (pointer==0)break;
			}
//		}
		tem=s->sol[row][pos];
		s->sol[row][pos]=node[i];
		s->sol[row][node[i]]=tem;
	}
	s->fitness=0;
	for (int i=0;i<=I_data->v_num-1;i++){
		pointer=0;
		while (1){
			s->fitness+=I_data->Distance[s->sol[i][pointer]][pointer];
	//		cout<<pointer<<"  ";
			pointer=s->sol[i][pointer];
			if (pointer==0)
				break;
		}
//		cout<<endl;
	}
//	cout<<endl;





//	cout<<"the actuall cost is "<<s->fitness<<endl;

	// check the solution
	int count=0;
	for (int i=0;i<=I_data->v_num-1;i++){
		pointer=0;
		while(1){
			pointer=s->sol[i][pointer];
			if (pointer>0)count++;
			else break;
		}
	}
	if (!(count==I_data->num_v)){
		cout<<"initial solution is wrong"<<endl;
		exit(0);
	}
}

The file initialsol.h contains:
/*
 * initialsol.h
 *
 *  Created on: 17 Apr 2020
 *      Author: Peng
 */

#ifndef INITIALSOL_H_
#define INITIALSOL_H_
#include "read_data.h"
#include "Individual.h"
class initial_sol {
public:
	initial_sol();
	virtual ~initial_sol();
	void greedy_fun();
	Individual * s;
	read_data * I_data;
};

#endif /* INITIALSOL_H_ */

The file kopt.cpp contains:
/*
 * kopt.cpp
 *   created on: April 24, 2013
 * last updated: June 13, 2013
 *       author: liushujia
 */



#ifndef __KOPT__
#include "kopt.h"
#endif

TKopt::TKopt( int N ){
	total_fN = N;
	fLink = new int* [ total_fN ];
	for( int i = 0; i < total_fN; ++i ) fLink[ i ] = new int [ 2 ];

	fOrdCity = new int [ total_fN ];
	fOrdSeg = new int [ total_fN ];
	fSegCity = new int [ total_fN ];
	fOrient = new int [ total_fN ];
	fLinkSeg = new int* [ total_fN ];
	for( int i = 0; i < total_fN; ++i ) fLinkSeg[ i ] = new int [ 2 ];

	fSizeSeg = new int [ total_fN ];
	fCitySeg = new int* [ total_fN ];
	for( int i = 0; i < total_fN; ++i ) fCitySeg[ i ] = new int [ 2 ];

	fT = new int [ 5 ];
	fActiveV = new int [ total_fN ];
	fInvNearList = new int* [ total_fN ];
	for( int i = 0; i < total_fN; ++i ) fInvNearList[ i ] = new int [ 500 ];

	fNumOfINL = new int [ total_fN ];
	fArray = new int [ total_fN+2 ];
	fCheckN = new int [ total_fN ];
	fB = new int [ total_fN ];
	fGene = new int [ total_fN ];
}

TKopt::~TKopt(){
	for( int i = 0; i < total_fN; ++i ) delete [] fLink[ i ];
	delete [] fLink;

	for( int i = 0; i < total_fN; ++i ) delete [] fLinkSeg[ i ];
	delete [] fLinkSeg;

	for( int i = 0; i < total_fN; ++i ) delete [] fCitySeg[ i ];
	delete [] fCitySeg;

	for( int i = 0; i < total_fN; ++i ) delete [] fInvNearList[ i ];
	delete [] fInvNearList;

	delete [] fOrdCity;
	delete [] fOrdSeg;
	delete [] fSegCity;
	delete [] fOrient;
	delete [] fSizeSeg;
	delete [] fT;
	delete [] fActiveV;
	delete [] fNumOfINL;
	delete [] fArray;
	delete [] fCheckN;
	delete [] fB;
	delete [] fGene;
//	delete eval;
}
void TKopt::input_data(int N)
{
	fN=N;
}
void TKopt::setInvNearList(){
	for( int i = 0; i < fN; ++i ) fNumOfINL[ i ] = 0;
	int c;
	for( int i = 0; i < fN; ++i ){
		for( int k = 0; k < 50; ++k ){
			c = eval->fNearCity[i][k];
			if( fNumOfINL[c] < 500 ) fInvNearList[ c ][ fNumOfINL[c]++ ] = i;
			else{
				//printf( "Check fNumOfINL[c] < 500 ) in kopt.cpp \n" );
				//fflush( stdout );
			}
		}
	}
}

void TKopt::transIndiToTree( TIndi& indi ){
	int num, size, orient;
	fArray[1] = 0;
	for( int i = 2; i <= fN; ++i ) fArray[i] = indi.fLink[ fArray[i-1] ][ 1 ];

	fArray[0] = fArray[fN];
	fArray[fN+1] = fArray[1];
	num = 1;
	fNumOfSeg = 0;
	while(1){
		orient = 1;
		size = 0;
		fOrient[ fNumOfSeg ] = orient;
		fOrdSeg[ fNumOfSeg ] = fNumOfSeg;

		fLink[ fArray[ num ] ][ 0 ] = -1;
		fLink[ fArray[ num ] ][ 1 ] = fArray[ num+1 ];
		fOrdCity[ fArray[ num ] ] = size;
		fSegCity[ fArray[ num ] ] = fNumOfSeg;
		fCitySeg[ fNumOfSeg ][ this->turn(orient) ] = fArray[ num ];
		++num;
		++size;
		for( int i = 0; i < (int)sqrt( fN*1.0 )-1; ++i ){
			if( num == fN ) break;
			fLink[ fArray[ num ] ][ 0 ] = fArray[ num-1 ];
			fLink[ fArray[ num ] ][ 1 ] = fArray[ num+1 ];
			fOrdCity[ fArray[ num ] ] = size;
			fSegCity[ fArray[ num ] ] = fNumOfSeg;
			++num;
			++size;
		}
		if( num == fN-1 ){
			fLink[ fArray[ num ] ][ 0 ] = fArray[ num-1 ];
			fLink[ fArray[ num ] ][ 1 ] = fArray[ num+1 ];
			fOrdCity[ fArray[ num ] ] = size;
			fSegCity[ fArray[ num ] ] = fNumOfSeg;
			++num;
			++size;
		}
		fLink[ fArray[ num ] ][ 0 ] = fArray[ num-1 ];
		fLink[ fArray[ num ] ][ 1 ] = -1;
		fOrdCity[ fArray[ num ] ] = size;
		fSegCity[ fArray[ num ] ] = fNumOfSeg;
		fCitySeg[ fNumOfSeg ][ orient ] = fArray[ num ];
		++num;
		++size;
		fSizeSeg[ fNumOfSeg ] = size;
		++fNumOfSeg;
		if( num == fN+1 ) break;
	}
	for( int s = 1; s < fNumOfSeg-1; ++s ){
		fLinkSeg[ s ][ 0 ] = s-1;
		fLinkSeg[ s ][ 1 ] = s+1;
	}
	fLinkSeg[ 0 ][ 0 ] = fNumOfSeg-1;
	fLinkSeg[ 0 ][ 1 ] = 1;
	fLinkSeg[ fNumOfSeg-1 ][ 0 ] = fNumOfSeg-2;
	fLinkSeg[ fNumOfSeg-1 ][ 1 ] = 0;
	fTourLength = indi.fEvaluationValue;
	fFixNumOfSeg = fNumOfSeg;
}

void TKopt::transTreeToIndi( TIndi& indi ){
	int t_p, t_n;
	for( int t = 0; t < fN; ++t ){
		t_p = this->getPrev( t );
		t_n = this->getNext( t );
		indi.fLink[ t ][ 0 ] = t_p;
		indi.fLink[ t ][ 1 ] = t_n;
	}
	eval->doIt( indi );
}

void TKopt::doIt( TIndi& tIndi ){
	this->transIndiToTree( tIndi );
	this->sub();
	this->transTreeToIndi( tIndi );
}

void TKopt::sub(){
	int t1_st;
	double dis1, dis2;
	//int dis1, dis2;
	for( int t = 0; t < fN; ++t ) fActiveV[ t ] = 1;
BEGIN:
	t1_st = rand()%fN;// select a node randomly
	fT[1] = t1_st;
	//t1's loop
	while(1){
		fT[1] = this->getNext( fT[1] );
		if( fActiveV[ fT[1] ] == 0 ) goto RETURN;
		fFlagRev = 0;
		fT[2] = this->getPrev( fT[1] );
		for( int num1 = 1; num1 < 50; ++num1 ){
			fT[4] = eval->fNearCity[ fT[1] ][ num1 ];
			fT[3] = this->getPrev( fT[4] );
			dis1 = eval->fEdgeDis[fT[1]][fT[2]] - eval->fEdgeDis[fT[1]][fT[4]];
			if( dis1 > 1.0e-7 ){
				dis2 = dis1 + eval->fEdgeDis[fT[3]][fT[4]] - eval->fEdgeDis[fT[3]][fT[2]];
				if( dis2 > 1.0e-7 ){
					this->incrementImp( fFlagRev );// implement swap
					for( int a = 1; a <= 4; ++a )
						for( int k = 0; k < fNumOfINL[fT[a]]; ++k )
							fActiveV[ this->fInvNearList[fT[a]][k] ] = 1;
					goto BEGIN;
				}
			}
			else break;
		}
		fFlagRev = 1;
		fT[2] = this->getNext( fT[1] );
		for( int num1 = 1; num1 < 50; ++num1 ){
			fT[4] = eval->fNearCity[ fT[1] ][ num1 ];
			fT[3] = this->getNext( fT[4] );
			dis1 = eval->fEdgeDis[fT[1]][fT[2]] - eval->fEdgeDis[fT[1]][fT[4]];
			if( dis1 > 1.0e-7 ){
				dis2 = dis1 + eval->fEdgeDis[fT[3]][fT[4]] - eval->fEdgeDis[fT[3]][fT[2]];
				if( dis2 > 1.0e-7 ){
					this->incrementImp( fFlagRev );
					for( int a = 1; a <= 4; ++a )
						for( int k = 0; k < fNumOfINL[fT[a]]; ++k )
							fActiveV[ this->fInvNearList[fT[a]][k] ] = 1;
					goto BEGIN;
				}
			}
			else break;
		}
		fActiveV[ fT[1] ] = 0;
RETURN:
		if( fT[1] == t1_st ) break;
	}
}

int TKopt::getNext( int t ){
	int t_n, seg, orient;
	seg = fSegCity[ t ];
	orient = fOrient[ seg ];
	t_n = fLink[ t ][ orient ];
	if( t_n == -1 ){
		seg = fLinkSeg[ seg ][ orient ];
		orient = turn( fOrient[ seg ] );
		t_n = fCitySeg[ seg ][ orient ];
	}
	return t_n;
}

int TKopt::getPrev( int t ){
	int t_p, seg, orient;
	seg = fSegCity[ t ];
	orient = fOrient[ seg ];
	t_p = fLink[ t ][ this->turn( orient ) ];
	if( t_p == -1 ){
		seg = fLinkSeg[ seg ][ turn(orient) ];
		orient = fOrient[ seg ];
		t_p = fCitySeg[ seg ][ orient ];
	}
	return t_p;
}

void TKopt::swap(int &x, int &y){
	int s=x;
	x=y;
	y=s;
}

int TKopt::turn( int &orient ){
	return 1-orient;
}

void TKopt::incrementImp( int flagRev ){
	int t1_s, t1_e, t2_s, t2_e;
	int seg_t1_s, seg_t1_e, seg_t2_s, seg_t2_e;
	int ordSeg_t1_s, ordSeg_t1_e, ordSeg_t2_s, ordSeg_t2_e;
	int orient_t1_s, orient_t1_e, orient_t2_s, orient_t2_e;
	int numOfSeg1, numOfSeg2;
	int curr;
	int ord;

	int flag_t2e_t1s;
	int flag_t2s_t1e;
	int length_t1s_seg;
	int length_t1e_seg;
	int seg;

	if( fFlagRev == 0 ){
		t1_s = fT[1];
		t1_e = fT[3];
		t2_s = fT[4];
		t2_e = fT[2];
	}
	else if( fFlagRev == 1 ){
		t1_s = fT[2];
		t1_e = fT[4];
		t2_s = fT[3];
		t2_e = fT[1];
	}

	seg_t1_s = fSegCity[ t1_s ];
	ordSeg_t1_s = fOrdSeg[ seg_t1_s ];
	orient_t1_s = fOrient[ seg_t1_s ];
	seg_t1_e = fSegCity[ t1_e ];
	ordSeg_t1_e = fOrdSeg[ seg_t1_e ];
	orient_t1_e = fOrient[ seg_t1_e ];
	seg_t2_s = fSegCity[ t2_s ];
	ordSeg_t2_s = fOrdSeg[ seg_t2_s ];
	orient_t2_s = fOrient[ seg_t2_s ];
	seg_t2_e = fSegCity[ t2_e ];
	ordSeg_t2_e = fOrdSeg[ seg_t2_e ];
	orient_t2_e = fOrient[ seg_t2_e ];

	//////////////////// Type1 ////////////////////////
	if( ( seg_t1_s == seg_t1_e ) && ( seg_t1_s == seg_t2_s ) && ( seg_t1_s == seg_t2_e ) ){
		if( (fOrient[seg_t1_s] == 1 && (fOrdCity[ t1_s ] > fOrdCity[ t1_e ])) ||
			(fOrient[seg_t1_s] == 0 && (fOrdCity[ t1_s ] < fOrdCity[ t1_e ]))){
			this->swap( t1_s, t2_s );
			this->swap( t1_e, t2_e );
			this->swap( seg_t1_s, seg_t2_s );
			this->swap( seg_t1_e, seg_t2_e );
			this->swap( ordSeg_t1_s, ordSeg_t2_s );
			this->swap( ordSeg_t1_e, ordSeg_t2_e );
			this->swap( orient_t1_s, orient_t2_s );
			this->swap( orient_t1_e, orient_t2_e );
		}
		curr = t1_s;
		ord = fOrdCity[ t1_e ];
		while(1){
			this->swap( fLink[curr][0], fLink[curr][1] );
			fOrdCity[ curr ] = ord;
			if( curr == t1_e ) break;
			curr = fLink[curr][turn(orient_t1_s)];
			if( orient_t1_s == 0 ) ++ord;
			else --ord;
		}

		fLink[t2_e][orient_t1_s] = t1_e;
		fLink[t2_s][turn(orient_t1_s)] = t1_s;
		fLink[t1_s][orient_t1_s] = t2_s;
		fLink[t1_e][turn(orient_t1_s)] = t2_e;

		return;
	}
	//////////////////// Type1 ///////////////////////


	if( ordSeg_t1_e >= ordSeg_t1_s )	numOfSeg1 = ordSeg_t1_e - ordSeg_t1_s + 1;
	else								numOfSeg1 = ordSeg_t1_e - ordSeg_t1_s + 1 + fNumOfSeg;
	if( ordSeg_t2_e >= ordSeg_t2_s )	numOfSeg2 = ordSeg_t2_e - ordSeg_t2_s + 1;
	else								numOfSeg2 = ordSeg_t2_e - ordSeg_t2_s + 1 + fNumOfSeg;

	if( numOfSeg1 > numOfSeg2 ){
		this->swap( numOfSeg1, numOfSeg2 );
		this->swap( t1_s, t2_s );
		this->swap( t1_e, t2_e );
		this->swap( seg_t1_s, seg_t2_s );
		this->swap( seg_t1_e, seg_t2_e );
		this->swap( ordSeg_t1_s, ordSeg_t2_s );
		this->swap( ordSeg_t1_e, ordSeg_t2_e );
		this->swap( orient_t1_s, orient_t2_s );
		this->swap( orient_t1_e, orient_t2_e );
	}
	if( fLink[ t2_e ][ orient_t2_e ] == -1 ) flag_t2e_t1s = 1;
	else flag_t2e_t1s = 0;

	if( fLink[ t2_s ][ this->turn(orient_t2_s) ] == -1 ) flag_t2s_t1e = 1;
	else flag_t2s_t1e = 0;

	length_t1s_seg = abs( fOrdCity[ t2_e ] - fOrdCity[ fCitySeg[ seg_t2_e ][ orient_t2_e ] ] );
	length_t1e_seg = abs( fOrdCity[ t2_s ] - fOrdCity[ fCitySeg[ seg_t2_s ][ this->turn(orient_t2_s) ] ] );

	///////////////////// Type2 /////////////////
	if( seg_t1_s == seg_t1_e ){
		if( flag_t2e_t1s == 1 && flag_t2s_t1e == 1 ){
			orient_t1_s = turn( fOrient[ seg_t1_s ] );
			fOrient[ seg_t1_s ] = orient_t1_s;
			fCitySeg[ seg_t1_s ][ orient_t1_s ] = t1_s;
			fCitySeg[ seg_t1_s ][ turn(orient_t1_s) ] = t1_e;
			fLinkSeg[ seg_t1_s ][ orient_t1_s ] = seg_t2_s;
			fLinkSeg[ seg_t1_s ][ turn(orient_t1_s) ] = seg_t2_e;
			return;
		}
		if( flag_t2e_t1s == 0 && flag_t2s_t1e == 1 ){
			curr = t1_e;
			ord = fOrdCity[ t1_s ];
			while(1){
				this->swap( fLink[curr][0], fLink[curr][1] );
				fOrdCity[ curr ] = ord;
				if( curr == t1_s ) break;

				curr = fLink[curr][orient_t2_e];
				if( orient_t2_e == 0 ) --ord;
				else ++ord;
			}
			fLink[t2_e][orient_t2_e] = t1_e;
			fLink[t1_s][orient_t2_e] = -1;
			fLink[t1_e][turn(orient_t2_e)] = t2_e;
			fCitySeg[seg_t2_e][orient_t2_e] = t1_s;
			return;
		}
		if( flag_t2e_t1s == 1 && flag_t2s_t1e == 0 ){
			curr = t1_s;
			ord = fOrdCity[ t1_e ];
			while(1){
				this->swap( fLink[curr][0], fLink[curr][1] );
				fOrdCity[ curr ] = ord;
				if( curr == t1_e ) break;

				curr = fLink[curr][turn(orient_t2_s)];
				if( orient_t2_s == 0 ) ++ord;
				else --ord;
			}
			fLink[t2_s][turn(orient_t2_s)] = t1_s;
			fLink[t1_e][turn(orient_t2_s)] = -1;
			fLink[t1_s][orient_t2_s] = t2_s;
			fCitySeg[seg_t2_s][turn(orient_t2_s)] = t1_e;
			return;
		}
	}

	///////////////////// Type3 /////////////////

	if( flag_t2e_t1s == 1 ) fLinkSeg[seg_t1_s][turn(orient_t1_s)] = seg_t2_s;
	else{
		seg_t1_s = fNumOfSeg++;
		orient_t1_s = orient_t2_e;
		fLink[ t1_s ][turn(orient_t1_s)] = -1;
		fLink[ fCitySeg[seg_t2_e][orient_t2_e]][orient_t1_s] = -1;
		fOrient[seg_t1_s] = orient_t1_s;
		fSizeSeg[seg_t1_s] = length_t1s_seg;
		fCitySeg[seg_t1_s][turn(orient_t1_s)] = t1_s;
		fCitySeg[seg_t1_s][orient_t1_s] = fCitySeg[seg_t2_e][orient_t2_e];
		fLinkSeg[seg_t1_s][turn(orient_t1_s)] = seg_t2_s;
		fLinkSeg[seg_t1_s][orient_t1_s] = fLinkSeg[seg_t2_e][orient_t2_e];
		seg = fLinkSeg[seg_t2_e][orient_t2_e];
		fLinkSeg[seg][turn(fOrient[seg])] = seg_t1_s;
	}

	if( flag_t2s_t1e == 1 ) fLinkSeg[seg_t1_e][orient_t1_e] = seg_t2_e;
	else{
		seg_t1_e = fNumOfSeg++;
		orient_t1_e = orient_t2_s;
		fLink[ t1_e ][orient_t1_e] = -1;
		fLink[ fCitySeg[seg_t2_s][turn(orient_t2_s)] ][turn(orient_t1_e)] = -1;
		fOrient[seg_t1_e] = orient_t1_e;
		fSizeSeg[seg_t1_e] = length_t1e_seg;
		fCitySeg[seg_t1_e][orient_t1_e] = t1_e;
		fCitySeg[seg_t1_e][turn(orient_t1_e)] = fCitySeg[seg_t2_s][turn(orient_t2_s)];
		fLinkSeg[seg_t1_e][orient_t1_e] = seg_t2_e;
		fLinkSeg[seg_t1_e][turn(orient_t1_e)] = fLinkSeg[seg_t2_s][turn(orient_t2_s)];
		seg = fLinkSeg[seg_t2_s][turn(orient_t2_s)];
		fLinkSeg[seg][fOrient[seg]] = seg_t1_e;
	}

	fLink[t2_e][orient_t2_e] = -1;
	fSizeSeg[seg_t2_e] -= length_t1s_seg;
	fCitySeg[seg_t2_e][orient_t2_e] = t2_e;
	fLinkSeg[seg_t2_e][orient_t2_e] = seg_t1_e;
	fLink[t2_s][turn(orient_t2_s)] = -1;
	fSizeSeg[seg_t2_s] -= length_t1e_seg;
	fCitySeg[seg_t2_s][turn(orient_t2_s)] = t2_s;
	fLinkSeg[seg_t2_s][turn(orient_t2_s)] = seg_t1_s;

	seg = seg_t1_e;
	while(1){
		fOrient[seg] = turn(fOrient[seg]);
		if( seg == seg_t1_s ) break;
		seg = fLinkSeg[seg][fOrient[seg]];
	}

	if( fSizeSeg[seg_t2_e] < length_t1s_seg ){
		seg = fLinkSeg[seg_t2_e][turn(fOrient[seg_t2_e])];
		fLinkSeg[seg][fOrient[seg]] = seg_t1_s;
		seg = fLinkSeg[seg_t2_e][fOrient[seg_t2_e]];
		fLinkSeg[seg][turn(fOrient[seg])] = seg_t1_s;
		seg = fLinkSeg[seg_t1_s][turn(fOrient[seg_t1_s])];
		fLinkSeg[seg][fOrient[seg]] = seg_t2_e;
		seg = fLinkSeg[seg_t1_s][fOrient[seg_t1_s]];
		fLinkSeg[seg][turn(fOrient[seg])] = seg_t2_e;

		this->swap( fOrient[seg_t2_e], fOrient[seg_t1_s] );
		this->swap( fSizeSeg[seg_t2_e], fSizeSeg[seg_t1_s] );
		this->swap( fCitySeg[seg_t2_e][0], fCitySeg[seg_t1_s][0] );
		this->swap( fCitySeg[seg_t2_e][1], fCitySeg[seg_t1_s][1] );
		this->swap( fLinkSeg[seg_t2_e][0], fLinkSeg[seg_t1_s][0] );
		this->swap( fLinkSeg[seg_t2_e][1], fLinkSeg[seg_t1_s][1] );
		this->swap( seg_t2_e, seg_t1_s );
	}

	if( fSizeSeg[seg_t2_s] < length_t1e_seg ){
		seg = fLinkSeg[seg_t2_s][turn(fOrient[seg_t2_s])];
		fLinkSeg[seg][fOrient[seg]] = seg_t1_e;
		seg = fLinkSeg[seg_t2_s][fOrient[seg_t2_s]];
		fLinkSeg[seg][turn(fOrient[seg])] = seg_t1_e;
		seg = fLinkSeg[seg_t1_e][turn(fOrient[seg_t1_e])];
		fLinkSeg[seg][fOrient[seg]] = seg_t2_s;
		seg = fLinkSeg[seg_t1_e][fOrient[seg_t1_e]];
		fLinkSeg[seg][turn(fOrient[seg])] = seg_t2_s;

		this->swap( fOrient[seg_t2_s], fOrient[seg_t1_e] );
		this->swap( fSizeSeg[seg_t2_s], fSizeSeg[seg_t1_e] );
		this->swap( fCitySeg[seg_t2_s][0], fCitySeg[seg_t1_e][0] );
		this->swap( fCitySeg[seg_t2_s][1], fCitySeg[seg_t1_e][1] );
		this->swap( fLinkSeg[seg_t2_s][0], fLinkSeg[seg_t1_e][0] );
		this->swap( fLinkSeg[seg_t2_s][1], fLinkSeg[seg_t1_e][1] );
		this->swap( seg_t2_s, seg_t1_e );
	}

	while( fNumOfSeg > fFixNumOfSeg ){
	if( fSizeSeg[ fLinkSeg[fNumOfSeg-1][0] ] <
		fSizeSeg[ fLinkSeg[fNumOfSeg-1][1] ] )
		this->combineSeg( fLinkSeg[fNumOfSeg-1][0], fNumOfSeg-1 );
	else
		this->combineSeg( fLinkSeg[fNumOfSeg-1][1], fNumOfSeg-1 );
	}
	int ordSeg = 0;
	seg = 0;
	while(1){
		fOrdSeg[seg] = ordSeg;
		++ordSeg;
		seg = fLinkSeg[seg][ fOrient[seg] ];
		if( seg == 0 ) break;
	}
  return;
}

void TKopt::combineSeg( int segL, int segS ){
	int seg;
	int t_s, t_e, direction; t_s = 0; t_e = 0; direction = 0;
	int ord; ord = 0;
	int increment; increment = 0;
	int curr, next;

	if( fLinkSeg[segL][fOrient[segL]] == segS ){
		fLink[fCitySeg[segL][fOrient[segL]]][fOrient[segL]] = fCitySeg[segS][turn(fOrient[segS])];
		fLink[fCitySeg[segS][turn(fOrient[segS])]][turn(fOrient[segS])] = fCitySeg[segL][fOrient[segL]];
		ord = fOrdCity[fCitySeg[segL][fOrient[segL]]];

		fCitySeg[segL][fOrient[segL]] = fCitySeg[segS][fOrient[segS]];
		fLinkSeg[segL][fOrient[segL]] = fLinkSeg[segS][fOrient[segS]];
		seg = fLinkSeg[segS][fOrient[segS]];
		fLinkSeg[seg][turn(fOrient[seg])] = segL;

		t_s = fCitySeg[segS][turn(fOrient[segS])];
		t_e = fCitySeg[segS][fOrient[segS]];
		direction = fOrient[segS];

		if( fOrient[segL] == 1 ) increment = 1;
		else increment = -1;
	}
	else if( fLinkSeg[segL][turn(fOrient[segL])] == segS ){
		fLink[fCitySeg[segL][turn(fOrient[segL])]][turn(fOrient[segL])] = fCitySeg[segS][fOrient[segS]];
		fLink[fCitySeg[segS][fOrient[segS]]][fOrient[segS]] = fCitySeg[segL][turn(fOrient[segL])];
		ord = fOrdCity[fCitySeg[segL][turn(fOrient[segL])]];

		fCitySeg[segL][turn(fOrient[segL])] = fCitySeg[segS][turn(fOrient[segS])];
		fLinkSeg[segL][turn(fOrient[segL])] = fLinkSeg[segS][turn(fOrient[segS])];
		seg = fLinkSeg[segS][turn(fOrient[segS])];
		fLinkSeg[seg][fOrient[seg]] = segL;

		t_s = fCitySeg[segS][fOrient[segS]];
		t_e = fCitySeg[segS][turn(fOrient[segS])];
		direction = turn(fOrient[segS]);

		if( fOrient[segL] == 1 ) increment = -1;
		else increment = 1;
	}
	curr = t_s;
	ord = ord + increment;
	while(1){
		fSegCity[curr] = segL;
		fOrdCity[curr] = ord;

		next = fLink[curr][direction];
		if( fOrient[segL] != fOrient[segS] ) this->swap( fLink[curr][0], fLink[curr][1] );

		if( curr == t_e ) break;
		curr = next;
		ord += increment;
	}
	fSizeSeg[segL] += fSizeSeg[segS];
	--fNumOfSeg;
}

void TKopt::checkDetail(){
	int seg, seg_p, seg_n;
	int ord, ord_p, ord_n;
	int orient;
	int curr;

	seg = 0;
	for( int s = 0; s < fNumOfSeg; ++s ){
		seg = s;
		orient = fOrient[ seg ];
		seg_p = fLinkSeg[ seg ][ this->turn(orient) ];
		seg_n = fLinkSeg[ seg ][ orient ];

		ord = fOrdSeg[ seg ];
		ord_p = ord - 1 ;
		if( ord_p < 0 ) ord_p = fNumOfSeg - 1;

		ord_n = ord + 1;
		if( ord_n >= fNumOfSeg ) ord_n = 0;

		curr = fCitySeg[ s ][ 0 ];
		int count = 0;

		while(1){
			++count;
			if( curr == fCitySeg[ s ][1] ) break;
			curr = fLink[curr][1];
		}
	}
	int t, t_n, t_p, t_s, t_e;
	for( t = 0; t < fN; ++t ){
		seg = fSegCity[ t ];
		orient = fOrient[ seg ];
		t_s = fCitySeg[ seg ][ 0 ];
		t_e = fCitySeg[ seg ][ 1 ];

		t_p = fLink[ t ][ 0 ];
		t_n = fLink[ t ][ 1 ];
	}
}

void TKopt::checkValid(){
	int t_st, t_c, t_n, count, seg, orient, Invalid = 0;
	for( int i = 0; i < fN; ++i ) fCheckN[ i ] = 0;

	t_st = rand() % fN;
	t_n = t_st;
	count = 0;
	while(1){
		t_c = t_n;
		fCheckN[ t_c ] = 1;
		++count;

		seg = fSegCity[ t_c ];
		orient = fOrient[ seg ];
		t_n = this->getNext( t_c );

		if( t_n == t_st ) break;

		if( count == fN+1 ){
			Invalid = 1;
			break;
		}
	}
	for( int i = 0; i < fN; ++i )
		if( fCheckN[ i ] == 0 ) Invalid = 1;

	if( Invalid == 1 ) printf( "Invalid \n" ); fflush( stdout );

}

void TKopt::makeRandSol( TIndi& indi ){
	for( int j = 0; j < fN; ++j ) fB[j] = j;
	int r;
	for( int i = 0; i < fN; ++i ){
		r = rand() % (fN-i);
		fGene[i] = fB[r];
		fB[r] = fB[fN-i-1];
	}

	for( int j2 = 1 ; j2 < fN-1; ++j2 ){
		indi.fLink[fGene[j2]][0] = fGene[j2-1];
		indi.fLink[fGene[j2]][1] = fGene[j2+1];
	}
	indi.fLink[fGene[0]][0] = fGene[fN-1];
	indi.fLink[fGene[0]][1] = fGene[1];
	indi.fLink[fGene[fN-1]][0] = fGene[fN-2];
	indi.fLink[fGene[fN-1]][1] = fGene[0];

	eval->doIt( indi );
}


The file kopt.h contains:
/*
 * kopt.h
 *   created on: April 24, 2013
 * last updated: June 13, 2013
 *       author: liushujia
 */

#ifndef __KOPT__
#define __KOPT__

#ifndef __RAND__
#include "randomize.h"
#endif

#ifndef __Sort__
#include "sort.h"
#endif

#ifndef __INDI__
#include "indi.h"
#endif

#ifndef __EVALUATOR__
#include "evaluator.h"
#endif

#include <stdio.h>
#include <stdlib.h>
#include <assert.h>

class TKopt{
public:
	TKopt( int N );
	~TKopt();
	void input_data(int N);
	void setInvNearList();
	void transIndiToTree( TIndi& indi );
	void transTreeToIndi( TIndi& indi );
	void doIt( TIndi& tIndi );			// å±€éƒ¨æ�œç´¢(2-opt neighborhood)

	int getNext( int t );
	int getPrev( int t );
	int turn( int &orient );

	void sub();
	void incrementImp( int flagRev );
	void combineSeg( int segL, int segS );

	void checkDetail();
	void checkValid();
	void swap(int &x, int &y);
	void makeRandSol( TIndi& indi );		// è®¾ç½®éš�æœºè·¯ç¨‹

	TEvaluator* eval;

private:
	int fN;
	int total_fN;
	int fFixNumOfSeg;
	int fNumOfSeg;
	int fFlagRev;
	double fTourLength;
	//int fTourLength;

	int **fLink;
	int **fLinkSeg;
	int **fCitySeg;
	int **fInvNearList;

	int *fT;
	int *fB;
	int *fSegCity;
	int *fOrdCity;
	int *fOrdSeg;
	int *fOrient;
	int *fSizeSeg;
	int *fActiveV;
	int *fNumOfINL;
	int *fArray;
	int *fCheckN;
	int *fGene;
};

#endif

The file LS.cpp contains:
/*
 * LS.cpp
 *
 *  Created on: 18 Apr 2020
 *      Author: Peng
 */

#include "LS.h"
#include "basic.h"
#include "Tstwoopt.h"
#include "EAX.h"
#include "environment.h"
#include "Individual.h"
LS::LS(read_data * data) {
	num_v=data->num_v;
	v_num=data->v_num;
	tem=new Individual();
	tem->define(num_v,v_num);
	each_route=new Tstwoopt (data);
	each_route->I_data=data;
	record_table=new int [v_num];
	s_t=new int [num_v+1];
	cand_str1=new int *[length_s*length_s];
	cand_str2=new int *[length_s*length_s];
	for (int i=0;i<=length_s*length_s-1;i++){
		cand_str1[i]=new int [length_s];
		cand_str2[i]=new int [length_s];
	}
	cand_fit=new double [length_s*length_s];
	near_cand1=new int *[num_near_nodes];
	for (int i=0;i<=num_near_nodes-1;i++)
		near_cand1[i]=new int [6];
	near_fit=new double [num_near_nodes];
	rever_list=new int [length_s*length_s];
	// tabu search variables
	tabu_table=new int *[v_num];
	tabu_table_c=new int *[v_num];
	for (int i=0;i<=v_num-1;i++){
		tabu_table[i]=new int [num_v+1];
		tabu_table_c[i]=new int [num_v+1];
	}
}
LS::~LS() {
	delete tem;
	delete each_route;
	delete [] record_table;
	delete [] s_t;
	for (int i=0;i<=length_s*length_s-1;i++){
		delete [] cand_str1[i];
		delete [] cand_str2[i];
	}
	delete [] cand_str1;
	delete [] cand_str2;
	delete [] cand_fit;
	for (int i=0;i<=num_near_nodes-1;i++)
		delete [] near_cand1[i];
	delete [] near_cand1;
	delete [] near_fit;
	delete [] rever_list;
	for (int i=0;i<=v_num-1;i++){
		delete [] tabu_table[i];
		delete [] tabu_table_c[i];
	}
	delete [] tabu_table;
	delete [] tabu_table_c;
}
void LS::update_best_solution(){
	if (s->fitness < b_s->fitness){
		for (int i=0;i<=v_num-1;i++)
			for (int j=0;j<=num_v;j++){
				b_s->sol[i][j]=s->sol[i][j];
				b_s->sol_r[i][j]=s->sol_r[i][j];
			}
		b_s->fitness=s->fitness;
	}
}
void LS::supply_edge(){
	int p;
	for (int i=0;i<v_num;i++){
		p=0;
		while(1){
			I_data->edge[p][b_s->sol[i][p]]=1;
			p=b_s->sol[i][p];
			if (p==0)break;
		}
	}
}
void LS::reverse_fun(){// get value for sol_r;
	int pointer;
	vector<int >tour;
	for (int i=0;i<=v_num-1;i++)	{
		pointer=s->sol[i][0];
		while (pointer!=0)		{
			tour.push_back(pointer);
			pointer=s->sol[i][pointer];
		}
		s->sol_r[i][0]=tour.back();
		tour.pop_back();
		pointer=s->sol_r[i][0];
		while (tour.size())		{
			s->sol_r[i][pointer]=tour.back();
			pointer=s->sol_r[i][pointer];
			tour.pop_back();
		}
		s->sol_r[i][pointer]=0;
	}
}
void LS::replace_fun(int *move){
	int string1[length_s];
	int string2[length_s];
	for (int i=0;i<=length_s-1;i++){
		string1[i]=-1;
		string2[i]=-1;
	}
	int count1=0;
	int row1=move[5];
	int row2=s_t[move[2]];
	while(1){
		if (move[0]!=move[1]){
			string1[count1]=move[0];
			count1++;
			move[0]=s->sol[row1][move[0]];
		}
		else{
			string1[count1]=move[1];count1++;
			break;
		}
	}
	int count2=0;
	while (1){
		if (move[2]!=move[3]){
			string2[count2]=move[2];
			count2++;
			if (move[4]==1)
				move[2]=s->sol[row2][move[2]];
			else
				move[2]=s->sol_r[row2][move[2]];
		}
		else{
			string2[count2]=move[3];count2++;
			break;
		}
	}
	I_data->use_frequency[count1-1][count2-1]=I_data->use_frequency[count1-1][count2-1]+1;
	if (cross_exchange_identify==1){
		for (int i=1;i<=count1-1;i++){
			s_t[string1[i]]=row2;
		}
		for (int i=0;i<=count2-1;i++){
			s_t[string2[i]]=row1;
		}
	}
	if (cross_exchange_identify==2){
		for (int i=1;i<=count1-1;i++){
			tabu_table[s_t[string1[i]]][string1[i]]=iteration + tabu_l+rand()%tabu_l;// tabu
			s_t[string1[i]]=row2;
		}
		for (int i=0;i<=count2-1;i++){
			tabu_table[s_t[string2[i]]][string2[i]]=iteration + tabu_l+rand()%tabu_l;// tabu
			s_t[string2[i]]=row1;
		}
	}

	int start1=string1[0];
	int start11=start1;
	int end1=s->sol[row1][string1[count1-1]];
	int end11=end1;
	int start2,end2,start22;
	if (move[4]==1){//whether reverse 1 is not and 0 is true
		start2=s->sol_r[row2][string2[0]];
		end2=s->sol[row2][string2[count2-1]];
		start22=start2;
		for (int i=1;i<=count1-1;i++){
			s->sol[row1][string1[i]]=-1;
			s->sol_r[row1][string1[i]]=-1;
		}
		for (int i=0;i<=count2-1;i++){
			s->sol[row2][string2[i]]=-1;
			s->sol_r[row2][string2[i]]=-1;
		}
		for (int i=0;i<=count2-1;i++){
			s->sol[row1][start1]=string2[i];
			start1=string2[i];
		}
		s->sol[row1][start1]=end11;
		for(int i=1;i<=count1-1;i++){
			s->sol[row2][start2]=string1[i];
			start2=string1[i];
		}
		s->sol[row2][start2]=end2;
		// for sol_r
		for (int i=count2-1;i>=0;i--){
			s->sol_r[row1][end1]=string2[i];
			end1=string2[i];
		}
		s->sol_r[row1][end1]=start11;
		for (int i=count1-1;i>=1;i--){
			s->sol_r[row2][end2]=string1[i];
			end2=string1[i];
		}
		s->sol_r[row2][end2]=start22;
	}
	else{
		start2=s->sol[row2][string2[0]];
		end2=s->sol_r[row2][string2[count2-1]];
		start22=start2;
		for (int i=1;i<=count1-1;i++){
			s->sol[row1][string1[i]]=-1;
			s->sol_r[row1][string1[i]]=-1;
		}
		for (int i=0;i<=count2-1;i++){
			s->sol[row2][string2[i]]=-1;
			s->sol_r[row2][string2[i]]=-1;
		}
		for (int i=0;i<=count2-1;i++){
			s->sol[row1][start1]=string2[i];
			start1=string2[i];
		}
		s->sol[row1][start1]=end11;
		for(int i=1;i<=count1-1;i++){
			s->sol_r[row2][start2]=string1[i];
			start2=string1[i];
		}
		s->sol_r[row2][start2]=end2;
		// for sol_r
		for (int i=count2-1;i>=0;i--){
			s->sol_r[row1][end1]=string2[i];
			end1=string2[i];
		}
		s->sol_r[row1][end1]=start11;
		for (int i=count1-1;i>=1;i--){
			s->sol[row2][end2]=string1[i];
			end2=string1[i];
		}
		s->sol[row2][end2]=start22;
	}
}
void LS::intra_route_optimization(){// this method will include many methods to optimize each route, such as 2-opt, Lk and EAX.
	int pointer;
	tem->fitness=s->fitness;
	for (int i=0;i<=v_num-1;i++)
		for (int j=0;j<=num_v;j++){
			tem->sol[i][j]=s->sol[i][j];
			tem->sol_r[i][j]=s->sol_r[i][j];
		}
	int number_routes[v_num];
	int route[num_v+1];
	for (int i=0;i<=v_num-1;i++){
		if (record_table[i]==1){
			record_table[i]=0;
			pointer=s->sol[i][0];number_routes[i]=0;
			route[number_routes[i]]=0;number_routes[i]++;
			while (1){
				if (pointer==0)
					break;
				else{
					route[number_routes[i]]=pointer;
					number_routes[i]++;
					pointer=s->sol[i][pointer];
				}
			}
			int sub_route[number_routes[i]];
			for (int j=0;j<=number_routes[i]-1;j++)
				sub_route[j]=route[j];
			if (intra_opt==1)
				each_route->twoopt(sub_route,number_routes[i]);
			if (intra_opt==3 && number_routes[i]>4){
					EAX(gEnv, sub_route,number_routes[i],I_data->x,I_data->y);
			}
			pointer=0;
			for (int j=1;j<=number_routes[i]-1;j++){
				tem->sol[i][pointer]=sub_route[j];
				pointer=tem->sol[i][pointer];
			}
			tem->sol[i][pointer]=0;
			pointer=0;
			for (int j=number_routes[i]-1;j>=1;j--){
				tem->sol_r[i][pointer]=sub_route[j];
				pointer=tem->sol_r[i][pointer];
			}
			tem->sol_r[i][pointer]=0;
		}
		else
			continue;
	}
	double current_cost=0;
	for (int i=0;i<=v_num-1;i++){
		pointer=0;
		while (1){
			current_cost+=I_data->Distance[pointer][tem->sol[i][pointer]];
			if (tem->sol[i][pointer]==0)
				break;
			else
				pointer=tem->sol[i][pointer];
		}
	}
	if (current_cost<s->fitness){
		s->fitness=current_cost;
		for (int i=0;i<=v_num-1;i++)
			for (int j=0;j<=num_v;j++){
				s->sol[i][j]=tem->sol[i][j];
				s->sol_r[i][j]=tem->sol_r[i][j];
			}
	}
	//update_best_solution();
}
void LS::replace_fun_insert(double min_delta,int row_out,int city_out,int row_in,int city_in){
	int n_p,p_p;
	s->fitness+=min_delta;
	n_p=s->sol[row_out][city_out];
	p_p=s->sol_r[row_out][city_out];
	s->sol[row_out][p_p]=n_p;
	s->sol_r[row_out][n_p]=p_p;
	s->sol[row_out][city_out]=-1;
	s->sol_r[row_out][city_out]=-1;
	//
	n_p=s->sol[row_in][city_in];
	s->sol[row_in][city_in]=city_out;
	s->sol[row_in][city_out]=n_p;
	s->sol_r[row_in][n_p]=city_out;
	s->sol_r[row_in][city_out]=city_in;
}
double LS::calculate_fit_insert(int row_out,int city_out,int row_in,int city_in){
	double delta=0;
	delta+=I_data->Distance[s->sol_r[row_out][city_out]][s->sol[row_out][city_out]];
	delta=delta-I_data->Distance[s->sol_r[row_out][city_out]][city_out];
	delta=delta-I_data->Distance[s->sol[row_out][city_out]][city_out];
	//
	delta+=I_data->Distance[city_in][city_out]+I_data->Distance[city_out][s->sol[row_in][city_in]];
	delta=delta-I_data->Distance[city_in][s->sol[row_in][city_in]];
	return delta;
}
void LS::insert(){// this function is used to implement a simple inserting operation
	int pointer,pointer_2;
	int row_out,city_out,row_in,city_in;
	double delta,min_delta;
	while (1){
		min_delta=Max;
		for (int i=0;i<=v_num-1;i++){
			pointer=s->sol[i][0];
			if (s->sol_r[i][pointer]==0 && s->sol[i][pointer]==0)
				continue;
			while(1){
				for (int j=0;j<=v_num-1;j++){
					if (j==i)continue;
					pointer_2=0;
					while(1){
						//////////////
						if (I_data->edge[pointer][pointer_2]!=1){
							pointer_2=s->sol[j][pointer_2];
							if (pointer_2==0)break;
							else continue;
						}
						//////////////
						delta=calculate_fit_insert(i,pointer,j,pointer_2);
						if (delta<min_delta){
							min_delta=delta;
							row_out=i;
							city_out=pointer;
							row_in=j;
							city_in=pointer_2;
						}
						pointer_2=s->sol[j][pointer_2];
						if (pointer_2==0)break;
					}
				}
				pointer=s->sol[i][pointer];
				if (pointer==0)break;
			}
		}
		if (min_delta+1.0e-7>0)break;
		replace_fun_insert(min_delta,row_out,city_out,row_in,city_in);
		record_table[row_out]=1;
		record_table[row_in]=1;
		if (ceil((clock()-I_data->start)/static_cast<double>(CLOCKS_PER_SEC))>=time_length)
			break;
	}
}

double LS::gain_fun(int st1,int end1,int row1,int st2,int end2,int row2,int k, int reverse){
	double fitn=0;
	if (k==0 && reverse==1)// forward
		fitn+=I_data->Distance[st2][s->sol_r[s_t[st2]][st2]]+I_data->Distance[end2][s->sol[s_t[end2]][end2]]-
			I_data->Distance[s->sol_r[s_t[st2]][st2]][s->sol[s_t[end2]][end2]]-I_data->Distance[end2][s->sol[row1][st1]];
	if (k==0 && reverse==0)// reverse
		fitn+=I_data->Distance[st2][s->sol[s_t[st2]][st2]]+I_data->Distance[end2][s->sol_r[s_t[end2]][end2]]-
			I_data->Distance[s->sol[s_t[st2]][st2]][s->sol_r[s_t[end2]][end2]]-I_data->Distance[end2][s->sol[row1][st1]];
	if (k!=0 && reverse==1)
		fitn+=I_data->Distance[st2][s->sol_r[s_t[st2]][st2]]+I_data->Distance[end2][s->sol[s_t[end2]][end2]]+
			I_data->Distance[end1][s->sol[s_t[end1]][end1]]-I_data->Distance[s->sol_r[s_t[st2]][st2]][s->sol[row1][st1]]-
			I_data->Distance[s->sol[s_t[end2]][end2]][end1]-I_data->Distance[end2][s->sol[s_t[end1]][end1]];
	if (k!=0 && reverse==0)
		fitn+=I_data->Distance[st2][s->sol[s_t[st2]][st2]]+I_data->Distance[end2][s->sol_r[s_t[end2]][end2]]+
			I_data->Distance[end1][s->sol[s_t[end1]][end1]]-I_data->Distance[s->sol[s_t[st2]][st2]][s->sol[row1][st1]]-
			I_data->Distance[s->sol_r[s_t[end2]][end2]][end1]-I_data->Distance[end2][s->sol[s_t[end1]][end1]];
	return fitn;
}

void LS:: cross_exchange_1(){
	int pointer;
	for (int i=0;i<=v_num-1;i++){
		pointer=s->sol[i][0];
		while (pointer!=0){
			s_t[pointer]=i;
			pointer=s->sol[i][pointer];
		}
	}
	double gi;int j;int in_num;
	int end2,end1;int count;double tem;
	int better_move[6];double better_fit;
	int reverse;
	int step=0;
	int identify;int identify2;
	while (1){
		better_fit=0;step++;
		for (int i=0;i<=v_num-1;i++){
			//pointer=s->sol[i][0];
			pointer=0;
			identify=1;
			while(1){
				if (pointer==0 && identify==0){identify=0;break;}
				else{
					c=0;
					//////////////////////////////////////////////////////
					for (j=1;j<=num_v;j++){
						in_num=-1;
						if(I_data->edge[pointer][j]==1){
							if (i!=s_t[j])
								in_num=j;
						}
					//////////////////////////////////////////////////////
						if (in_num==-1)continue;
						count=0;
						gi=0;//
						gi+=I_data->Distance[pointer][s->sol[i][pointer]];
						gi=gi-I_data->Distance[pointer][in_num];
						if (1){// case 1
							end1=pointer;identify2=1;
							for (int k=0;k<=length_s-1;k++){// carry the out row
								reverse=1;
								if (k>0){
									end1=s->sol[i][end1];identify2=0;
								}
								if (end1==0 &&identify2==0)break;//
								end2=in_num;
								for (int n=0;n<=length_s-1;n++){
									if (n==1){// determine the right or left
										if (s->sol[s_t[in_num]][in_num]==0)reverse=0;
										if (s->sol_r[s_t[in_num]][in_num]==0)reverse=1;
										if (s->sol_r[s_t[in_num]][in_num]!=0 && s->sol[s_t[in_num]][in_num]!=0){
											if (gain_fun(pointer,end1,i,in_num,s->sol[s_t[in_num]][in_num],s_t[in_num],k,1)>
												gain_fun(pointer,end1,i,in_num,s->sol_r[s_t[in_num]][in_num],s_t[in_num],k,0))
												reverse=1;
											else
												reverse=0;
										}
									}
									if (reverse==1 && n!=0){
										end2=s->sol[s_t[end2]][end2];
										}
									if (reverse==0 && n!=0){
										end2=s->sol_r[s_t[end2]][end2];
										}
									if (end2==0)break;
									if (pointer==end1 && (s->sol[s_t[end2]][end2]==0 || s->sol_r[s_t[end2]][end2]==0))break;
									if (gi+gain_fun(pointer,end1,i,in_num,end2,s_t[in_num],k,reverse)>0){
										count++;
										cand_str1[count-1][0]=pointer;
										cand_str1[count-1][1]=end1;
										cand_str1[count-1][2]=i;
										cand_str2[count-1][0]=in_num;
										cand_str2[count-1][1]=end2;
										rever_list[count-1]=reverse;
										cand_fit[count-1]=gi+gain_fun(pointer,end1,i,in_num,end2,s_t[in_num],k,reverse);
									}
								}
							}
						}
						if (count==0){continue;}
						tem=0;
						for (int k=0;k<=count-1;k++)
							if (tem<cand_fit[k]){
								near_cand1[c][0]=cand_str1[k][0];
								near_cand1[c][1]=cand_str1[k][1];
								near_cand1[c][2]=cand_str2[k][0];
								near_cand1[c][3]=cand_str2[k][1];
								near_cand1[c][4]=rever_list[k];
								near_cand1[c][5]=cand_str1[k][2];
								near_fit[c]=cand_fit[k];
								tem=cand_fit[k];////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							}
						c++;
					}
					for (j=1;j<=c-1;j++){
						if (better_fit<near_fit[j]){
							better_fit=near_fit[j];
							better_move[0]=near_cand1[j][0];
							better_move[1]=near_cand1[j][1];
							better_move[2]=near_cand1[j][2];
							better_move[3]=near_cand1[j][3];
							better_move[4]=near_cand1[j][4];
							better_move[5]=near_cand1[j][5];
						}
					}
				}
				pointer=s->sol[i][pointer];
				if (pointer==0)break;
			}
		}

		if (better_fit<1.0e-7)
			break;
		s->fitness=s->fitness-better_fit;
		record_table[better_move[5]]=1;
		record_table[s_t[better_move[2]]]=1;
		replace_fun(better_move);
		if (ceil((clock()-I_data->start)/static_cast<double>(CLOCKS_PER_SEC))>=time_length)
			break;
	}
	//update_best_solution();
}

void LS::cross_exchange(){
	insert();

	cross_exchange_1();
}
void LS::local_search(){
	reverse_fun();// get value for sol_r;
	iteration_c=0;
	// to iterate all steps
	for (int i=0;i<=v_num-1;i++)
		record_table[i]=1;
	double local_optima;
	//intra_route_optimization();
	//cross_exchange();
	local_optima=s->fitness;
	//intra_route_optimization();

	while (1){
		cross_exchange();
		if (local_optima-1.0e-7<s->fitness && local_optima+1.0e-7>s->fitness)
			break;
		else{
			local_optima=s->fitness;
			intra_route_optimization();
		}
		if(ceil((clock() - I_data->start)/static_cast<double>(CLOCKS_PER_SEC))>=time_length)
			break;
	}
	for (int i=0;i<=v_num-1;i++){
		for (int j=0;j<=num_v;j++){
			b_s->sol[i][j]=s->sol[i][j];
			b_s->sol_r[i][j]=s->sol_r[i][j];
		}
	}
	b_s->fitness=s->fitness;
}




//////////////////////////////////////////////////////////////////
void LS:: cross_exchange_2(){

	int pointer;improve=0;
	for (int i=0;i<=v_num-1;i++){
		pointer=s->sol[i][0];
		while (pointer!=0){
			s_t[pointer]=i;
			pointer=s->sol[i][pointer];
		}
	}
	double gi;int j;int in_num;int rand_order;
	int end2,end1;
	int better_move[6];
	int reverse;
	int identify;int identify2;
	double delta,min_delta,min_tabu_delta;
	int can_node[100][6];
	int can_tabu_node[100][6];
	int num_best;
	int num_tabu_best;
	while (1){
		min_delta=-Max;
		min_tabu_delta=-Max;
		num_best=0;
		num_tabu_best=0;
		for (int i=0;i<=v_num-1;i++){
			pointer=0;
			identify=1;
			while(1){
				if (pointer==0 && identify==0){identify=0;break;}
				else{
					//////////////////////////////////////////////////////
					for (j=1;j<=num_v;j++){
						in_num=-1;
						if(I_data->edge[pointer][j]==1){
							if (i!=s_t[j])
								in_num=j;
						}
					//////////////////////////////////////////////////////
						if (in_num==-1)continue;
						gi=0;//
						gi+=I_data->Distance[pointer][s->sol[i][pointer]];
						gi=gi-I_data->Distance[pointer][in_num];

						end1=pointer;identify2=1;
						for (int k=0;k<=length_s-1;k++){// carry the out row
							reverse=1;
							if (k>0){
								end1=s->sol[i][end1];identify2=0;
							}
							if (end1==0 &&identify2==0)break;//
							end2=in_num;
							for (int n=0;n<=length_s-1;n++){
								if (n==1){// determine the right or left
									if (s->sol[s_t[in_num]][in_num]==0)reverse=0;
									if (s->sol_r[s_t[in_num]][in_num]==0)reverse=1;
									if (s->sol_r[s_t[in_num]][in_num]!=0 && s->sol[s_t[in_num]][in_num]!=0){
										if (gain_fun(pointer,end1,i,in_num,s->sol[s_t[in_num]][in_num],s_t[in_num],k,1)>
											gain_fun(pointer,end1,i,in_num,s->sol_r[s_t[in_num]][in_num],s_t[in_num],k,0))
											reverse=1;
										else
											reverse=0;
									}
								}
								if (reverse==1 && n!=0)
									end2=s->sol[s_t[end2]][end2];
								if (reverse==0 && n!=0)
									end2=s->sol_r[s_t[end2]][end2];
								if (end2==0)break;
								if (pointer==end1 && (s->sol[s_t[end2]][end2]==0 || s->sol_r[s_t[end2]][end2]==0))break;
								if (pointer==0 && s->sol[i][end1]==0 && ( (s->sol[s_t[in_num]][end2]==0 &&s->sol_r[s_t[in_num]][in_num]==0 ) ||
										(s->sol_r[s_t[in_num]][end2]==0 &&s->sol[s_t[in_num]][in_num]==0)))
									break;
								delta=gi+gain_fun(pointer,end1,i,in_num,end2,s_t[in_num],k,reverse);
								if ((end1==0 && tabu_table[i][end2]<=iteration)
									|| (tabu_table[i][end2]<=iteration && tabu_table[s_t[end2]][end1]<=iteration)){
									if (delta>min_delta){
										min_delta=delta;
										can_node[0][0]=pointer;
										can_node[0][1]=end1;
										can_node[0][2]=in_num;
										can_node[0][3]=end2;
										can_node[0][4]=reverse;
										can_node[0][5]=i;
										num_best=1;
									}
									else if (min_delta+1.0e-7>delta && min_delta-1.0e-7<delta && num_best<100){
										can_node[num_best][0]=pointer;
										can_node[num_best][1]=end1;
										can_node[num_best][2]=in_num;
										can_node[num_best][3]=end2;
										can_node[num_best][4]=reverse;
										can_node[num_best][5]=i;
										num_best++;
									}
								}
								else{
									if (min_tabu_delta<delta){
										min_tabu_delta=delta;
										can_tabu_node[0][0]=pointer;
										can_tabu_node[0][1]=end1;
										can_tabu_node[0][2]=in_num;
										can_tabu_node[0][3]=end2;
										can_tabu_node[0][4]=reverse;
										can_tabu_node[0][5]=i;
										num_tabu_best=1;
									}
									else if (min_tabu_delta+1.0e-7>delta && min_tabu_delta-1.0e-7<delta && num_tabu_best<100){
										min_tabu_delta=delta;
										can_tabu_node[num_tabu_best][0]=pointer;
										can_tabu_node[num_tabu_best][1]=end1;
										can_tabu_node[num_tabu_best][2]=in_num;
										can_tabu_node[num_tabu_best][3]=end2;
										can_tabu_node[num_tabu_best][4]=reverse;
										can_tabu_node[num_tabu_best][5]=i;
										num_tabu_best++;
									}
								}
							}
						}
					}
				}
				pointer=s->sol[i][pointer];
				if (pointer==0)break;
			}
		}
		if ((num_tabu_best>0 && min_tabu_delta+1.0e-7>min_delta && (s->fitness-min_tabu_delta - 1.0e-7 <b_s->fitness)) || num_best==0){
			s->fitness=s->fitness-min_tabu_delta;
			rand_order=rand()%num_tabu_best;
			better_move[0]=can_tabu_node[rand_order][0];
			better_move[1]=can_tabu_node[rand_order][1];
			better_move[2]=can_tabu_node[rand_order][2];
			better_move[3]=can_tabu_node[rand_order][3];
			better_move[4]=can_tabu_node[rand_order][4];
			better_move[5]=can_tabu_node[rand_order][5];
		}
		else{
			s->fitness=s->fitness-min_delta;
			rand_order=rand()%num_best;
			better_move[0]=can_node[rand_order][0];
			better_move[1]=can_node[rand_order][1];
			better_move[2]=can_node[rand_order][2];
			better_move[3]=can_node[rand_order][3];
			better_move[4]=can_node[rand_order][4];
			better_move[5]=can_node[rand_order][5];
		}
		record_table[better_move[5]]=1;
		record_table[s_t[better_move[2]]]=1;
		replace_fun(better_move);
		if (s->fitness+1.0e-7<b_s->fitness){
			update_best_solution();
	//		break;
			improve=0;iteration_c=iteration;
			supply_edge();
		}
		else
			improve++;
		if (improve>threshold)
			break;
		iteration++;
		if (ceil((clock()-I_data->start)/static_cast<double>(CLOCKS_PER_SEC))>=time_length)
			break;
	}
}
void LS::insert_tabu(){
	int pointer;improve=0;
	int pointer_2;
	int longest_tour=0;
	int longest_third;
	double delta;
	int row_out,city_out,row_in,city_in;
	int can_node[100][4];
	int can_tabu_node[100][4];
	double min_delta,min_tabu_delta;
	int num_best,num_tabu_best;
	int rand_order; double delta_tabu;
	while (1){
		min_delta=Max;
		min_tabu_delta=Max;
		num_best=0;
		num_tabu_best=0;
		for (int i=0;i<=v_num-1;i++){
			pointer=s->sol[i][0];
			if (s->sol_r[i][pointer]==0 && s->sol[i][pointer]==0)
				continue;
			while(1){
				for (int j=0;j<=v_num-1;j++){
					if (j==i)continue;
					pointer_2=0;
					while(1){
						/////////////////////////////////////////////////////////////
						if (I_data->edge[pointer][pointer_2]!=1){
							pointer_2=s->sol[j][pointer_2];
							if (pointer_2==0)break;
							else continue;
						}
						//////////////////////////////////////////////////////////////
						delta=calculate_fit_insert(i,pointer,j,pointer_2);
						if(tabu_table[i][pointer]<iteration){
							min_delta=delta;
							can_node[0][0]=i;
							can_node[0][1]=pointer;
							can_node[0][2]=j;
							can_node[0][3]=pointer_2;
							num_best=1;
						}
						else if (min_delta+1.0e-7>delta && min_delta-1.0e-7<delta && num_best<100){
							can_node[num_best][0]=i;
							can_node[num_best][1]=pointer;
							can_node[num_best][2]=j;
							can_node[num_best][3]=pointer_2;
							num_best++;
						}
						else {
							if (min_tabu_delta<delta){
								min_tabu_delta=delta;
								can_tabu_node[0][0]=i;
								can_tabu_node[0][1]=pointer;
								can_tabu_node[0][2]=j;
								can_tabu_node[0][3]=pointer_2;
								num_tabu_best=1;
							}
							else if (min_tabu_delta+1.0e-7 >delta && min_tabu_delta-1.0e-7<delta && num_tabu_best<100){
								can_tabu_node[num_tabu_best][0]=i;
								can_tabu_node[num_tabu_best][1]=pointer;
								can_tabu_node[num_tabu_best][2]=j;
								can_tabu_node[num_tabu_best][3]=pointer_2;
								num_tabu_best++;
							}
						}
						pointer_2=s->sol[j][pointer_2];
						if (pointer_2==0)break;
					}
				}
				pointer=s->sol[i][pointer];
				if (pointer==0)break;
			}
		}
		if ((num_tabu_best>0 && min_tabu_delta+1.0e-7<min_delta && (s->fitness+min_tabu_delta+1.0e-7 <b_s->fitness))|| num_best==0){
			rand_order=rand()%num_tabu_best;
			delta_tabu=min_tabu_delta;
			row_out=can_tabu_node[rand_order][0];
			city_out=can_tabu_node[rand_order][1];
			row_in=can_tabu_node[rand_order][2];
			city_in=can_tabu_node[rand_order][3];
		}
		else{
			rand_order=rand()%num_best;
			delta_tabu=min_delta;
			row_out=can_node[rand_order][0];
			city_out=can_node[rand_order][1];
			row_in=can_node[rand_order][2];
			city_in=can_node[rand_order][3];
		}
		tabu_table[row_out][city_out]=iteration + tabu_l+rand()%tabu_l;
		replace_fun_insert(min_delta,row_out,city_out,row_in,city_in);
		record_table[row_out]=1;
		record_table[row_in]=1;
		if (s->fitness+1.0e-7<b_s->fitness){
			update_best_solution();
			improve=0;
			supply_edge();
//			break;
		}
		else
			improve++;
		if (improve>threshold)
			break;
		iteration++;
		if (ceil((clock()-I_data->start)/static_cast<double>(CLOCKS_PER_SEC))>=time_length)
			break;
	}
}

void LS::weak_perturb(){
	reverse_fun();// get value for sol_r;
	for (int i=0;i<=v_num-1;i++)
		for (int j=0;j<=num_v;j++)
			tabu_table[i][j]=0;
	iteration=1;
	double local_optima=s->fitness;
	int no_improve=0;
	while(1){
		if (ceil((clock()-I_data->start)/static_cast<double>(CLOCKS_PER_SEC))>=time_length)
			break;
		insert_tabu();
		iteration+=tabu_l*2;
		cross_exchange_2();
		iteration+=tabu_l*2;
		intra_route_optimization();
		if (s->fitness+1.0e-7<b_s->fitness)
			update_best_solution();
		if (local_optima+1.0e-7>b_s->fitness && local_optima-1.0e-7<b_s->fitness)
			no_improve++;
		else{
			local_optima=b_s->fitness;no_improve=0;
		}
		if (no_improve>50)break;
		cout<<b_s->fitness<<"  "<<s->fitness<<"   "<<no_improve<<endl;
	}
}

The file perturb.cpp contains:
/*
 * perturb.cpp
 *
 *  Created on: 10 Jul 2020
 *      Author: Peng
 */

#include "perturb.h"
#include "read_data.h"
#include "Individual.h"
#include "basic.h"
perturb::perturb() {
}

perturb::~perturb() {
	delete [] s_t;
}
void perturb::define(){
	s_t=new int [I_data->num_v+1];
}
double perturb::determine_delta(int row,int city,int pointer){
	double delta=0;
	delta=I_data->Distance[pointer][city]+I_data->Distance[city][s->sol[row][pointer]];
	delta=delta-I_data->Distance[pointer][s->sol[row][pointer]];
	return delta;
}
void perturb::insert_fun(int city,int row,int loc,double delta_min){
	int n_p=s->sol[row][loc];
	s->sol[row][loc]=city;
	s->sol[row][city]=n_p;
	s->fitness+=delta_min;
}

void perturb::perturb_fun1(){
	int pointer;int n_p,p_p;
	vector<int >node;
	for (int i=0;i<=I_data->v_num-1;i++){
		pointer=s->sol[i][0];
		while (1){
			if (pointer==0)break;
			if (rand()%1000<prob){// a route should include at least a city
				node.push_back(pointer);
				n_p=s->sol[i][pointer];
				p_p=s->sol_r[i][pointer];
				s->sol[i][p_p]=n_p;
				s->sol[i][pointer]=-1;
				s->sol_r[i][n_p]=p_p;
				s->sol_r[i][pointer]=-1;
				pointer=n_p;
			}
			else
				pointer=s->sol[i][pointer];
		}
	}
	random_shuffle(node.begin(), node.end());
	int node_size=node.size();
	double delta,delta_min;int row,loc;
	for (int i =0;i<=node_size-1;i++){
		delta_min=Max;
		for (int j=0;j<=I_data->v_num-1;j++){
			pointer=0;
			if (s->sol[j][pointer]==0 && pointer==0){
				delta=determine_delta(j,node[i],pointer);
				row=j;
				loc=pointer;
				delta_min=delta;
				break;
			}
			else{
				pointer=0;
				while(1){
					delta=determine_delta(j,node[i],pointer);
					if (delta_min>delta){
						delta_min=delta;
						row=j;
						loc=pointer;
					}
					pointer=s->sol[j][pointer];
					if (pointer==0)
						break;
				}
			}
		}
		insert_fun(node[i],row,loc,delta_min);
	}
	// check;
	int count=0;
	for (int i=0;i<=I_data->v_num-1;i++){
		pointer=0;
		while(1){
			pointer=s->sol[i][pointer];
			if (pointer>0)count++;
			else break;
		}
	}
	if (!(count==I_data->num_v)){
		cout<<"initial solution is wrong"<<endl;
		exit(0);
	}
}
void perturb::perturb_fun2(){
	int pointer;
	for (int i=0;i<=I_data->v_num-1;i++){
		pointer=0;
		while (1){
			pointer=s->sol[i][pointer];
			if (pointer==0)break;
			s_t[pointer]=i;
		}
	}
	int n_p,p_p;
	vector<int >node;
	for (int i=0;i<=I_data->v_num-1;i++){
		pointer=s->sol[i][0];
		while (1){
			if (pointer==0)break;
			if (rand()%1000<prob){// a route should include at least a city
				node.push_back(pointer);
				n_p=s->sol[i][pointer];
				p_p=s->sol_r[i][pointer];
				s->sol[i][p_p]=n_p;
				s->sol[i][pointer]=-1;
				s->sol_r[i][n_p]=p_p;
				s->sol_r[i][pointer]=-1;
				pointer=n_p;
			}
			else
				pointer=s->sol[i][pointer];
		}
	}
	random_shuffle(node.begin(), node.end());
	int node_size=node.size();
	double delta,delta_min;int row,loc;
	for (int i =0;i<=node_size-1;i++){
		delta_min=Max;
		for (int j=0;j<=I_data->v_num-1;j++){
			if (s_t[node[i]==j])continue;
			pointer=0;
			if (s->sol[j][pointer]==0 && pointer==0){
				delta=determine_delta(j,node[i],pointer);
				row=j;
				loc=pointer;
				delta_min=delta;
				break;
			}
			else{
				pointer=0;
				while(1){
					delta=determine_delta(j,node[i],pointer);
					if (delta_min>delta){
						delta_min=delta;
						row=j;
						loc=pointer;
					}
					pointer=s->sol[j][pointer];
					if (pointer==0)
						break;
				}
			}
		}
		insert_fun(node[i],row,loc,delta_min);
	}
	// check;
	int count=0;
	for (int i=0;i<=I_data->v_num-1;i++){
		pointer=0;
		while(1){
			pointer=s->sol[i][pointer];
			if (pointer>0)count++;
			else break;
		}
	}
	if (!(count==I_data->num_v)){
		cout<<"initial solution is wrong"<<endl;
		exit(0);
	}
}

void perturb:: perturbation(){

//	cout<<prob<<"   ";

//	prob=Probability;
	if (perturbation_method==1)
		perturb_fun1();
	if (perturbation_method==2)
		perturb_fun2();
}

The file perturb.h contains:
/*
 * perturb.h
 *
 *  Created on: 10 Jul 2020
 *      Author: Peng
 */

#ifndef PERTURB_H_
#define PERTURB_H_
#include "read_data.h"
#include "Individual.h"
class perturb {
public:
	perturb();
	virtual ~perturb();
	void define();

	Individual * s;
	read_data * I_data;
	void perturbation();
	int no_improve;
private:
	void perturb_fun1();
	double determine_delta(int row,int city,int pointer);
	void insert_fun(int city,int row,int loc,double delta_min);
	void perturb_fun2();
	// variables
	int *s_t;
	double prob;
};

#endif /* PERTURB_H_ */

The file randomize.cpp contains:
/*
 * randomize.cpp
 *   created on: April 24, 2013
 * last updated: June 13, 2013
 *       author: liushujia
 */

#ifndef __RAND__
#include "randomize.h"
#endif

TRandom* tRand = NULL;

void InitURandom(){
	int seed;
	unsigned short seed16v[3];
	seed = 1111;
	seed16v[0] = 100;
	seed16v[1] = 200;
	seed16v[2] = seed;
	tRand = new TRandom();
	srand( seed );
}

void InitURandom( int dd ){
	int seed;
	unsigned short seed16v[3];
	seed = dd;
	seed16v[0] = 100;
	seed16v[1] = 200;
	seed16v[2] = seed;
	tRand = new TRandom();
	srand( seed );
}

TRandom::TRandom(){}
TRandom::~TRandom(){}

int TRandom::Integer( int minNumber, int maxNumber ){
	return minNumber + (rand() % (maxNumber - minNumber + 1));
}

double TRandom::Double( double minNumber, double maxNumber ){
	return minNumber + rand() % (int)(maxNumber - minNumber);
}

void TRandom::permutation( int *array, int numOfElement, int numOfSample ){
	if( numOfElement <= 0 ) return;
	int i, j, k, r;
	int *b = new int[numOfElement];
	for(j=0;j<numOfElement;j++) b[j]=0;
	for(i=0;i<numOfSample;i++){
		r=rand()%(numOfElement-i);
		k=0;
		for(j=0;j<=r;j++){
			while(b[k]==1) ++k;
			k++;
		}
		array[i]=k-1;
		b[k-1]=1;
	}
	delete [] b;
}

double TRandom::normalDistribution( double mu, double sigma ){
	double U1,U2,X;
	double PI = 3.1415926;
	while( 1 ){
		U1 = this->Double( 0.0, 1.0 );
		if( U1 != 0.0 ) break;
	}
	U2 = this->Double( 0.0, 1.0 );
	X = sqrt(-2.0*log(U1)) * cos(2*PI*U2);
	return( mu + sigma*X );
}

void TRandom::shuffle( int *array, int numOfElement ){
	int *a = new int[numOfElement];
	int *b = new int[numOfElement];
	this->permutation( b, numOfElement, numOfElement );
	for( int i = 0; i < numOfElement; ++i ) a[ i ] = array[ i ];
	for( int i = 0; i < numOfElement; ++i ) array[ i ] = a[ b[ i ] ];
	delete [] a;
	delete [] b;
}

The file randomize.h contains:
/*
 * randomize.h
 *   created on: April 24, 2013
 * last updated: June 13, 2013
 *       author: liushujia
 */

#ifndef __RAND__
#define __RAND__

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <time.h>

extern void InitURandom( int );
extern void InitURandom( void );

class TRandom {
public:
	TRandom();
	~TRandom();
	int Integer( int minNumber, int maxNumber );
	double Double( double minNumber, double maxNumber );
	double normalDistribution( double mu, double sigma );
	void permutation( int *array, int numOfelement, int numOfSample );	// éš�æœºäº§ç”Ÿç§�ç¾¤çš„ä¸€ä¸ªæŽ’åˆ—
	void shuffle( int *array, int numOfElement );						// æ ¹æ�®äº§ç”Ÿçš„æŽ’åˆ—è°ƒæ•´ç§�ç¾¤ä¸­çš„ä¸ªä½“ä½�ç½®
};

extern TRandom* tRand;


#endif



The file read_data.cpp contains:
/*
 * readdata.cpp
 *
 *  Created on: 17 Apr 2020
 *      Author: Peng
 */

#include "read_data.h"
#include "basic.h"
#include "Individual.h"
#include <sstream>
read_data::read_data() {

}
read_data::~read_data() {
	for (i=0;i<=num_v;i++){
		delete [] Distance[i];
		delete [] edge[i];
		delete [] record[i];
		delete [] beta[i];
	}
	delete [] Distance;
	delete [] edge;
	delete [] beta;
	delete [] record;
	for (i=0;i<=num_v;i++)
		delete [] near_ns[i];
	delete [] near_ns;
	for ( i=0;i<=num_v;i++)
		delete [] near[i];
	delete [] near;
	for (i=0;i<=length_s-1;i++)
		delete [] use_frequency[i];
	delete [] use_frequency;
	delete [] x;
	delete [] y;
	for (int i=0;i<=num_v;i++)
		delete [] city[i].son;
	delete [] city;
	delete [] low_cost;
	delete [] check_city;
}
void read_data::define(){
	Distance=new double *[num_v+1];
	edge=new int *[num_v+1];
	record=new int *[num_v+1];
	beta=new double *[num_v+1];
	for ( i=0;i<=num_v;i++){
		Distance[i]=new double [num_v+1];
		edge[i]=new int [num_v+1];
		record[i]=new int [num_v+1];
		beta[i]=new double [num_v+1];
	}
	x=new double [num_v+1];
	y=new double [num_v+1];
	near_ns=new int *[num_v+1];
	near= new int *[num_v+1];
	for ( i=0;i<=num_v;i++)
		near[i]=new int	[num_near_nodes];
	for ( i=0;i<=num_v;i++)
		near_ns[i]=new int [num_v+1];
	use_frequency=new int *[length_s];
	for (i=0;i<=length_s-1;i++)
		use_frequency[i]=new int [length_s];
	for (i=0;i<=length_s-1;i++)
		for (j=0;j<=length_s-1;j++)
			use_frequency[i][j]=0;
	/////
	city=new node[num_v+1];
	for (int i=0;i<=num_v;i++)
		city[i].son=new int [num_v+1];
	low_cost=new double [num_v+1];
	check_city=new int [num_v+1];
}
void read_data::read_fun(char* file_name,int number_node){
//	instance_n=file_name;
	ifstream open_file(file_name);
	num_v=number_node;
//	char aa[100];
	char bb[1000];
	open_file>>instance_n;open_file>>bb;
	open_file>>v_num;
	define();
	int c;  //
	for ( i=0;i<=num_v;i++) {
		open_file>>c;open_file>>x[i];open_file>>y[i];//
	}
	open_file.close();
	if ( strcmp( bb, "EUC_2D" ) == 0  ){
		graph_type=1;
		for ( i=0;i<=num_v;i++)
			for ( j=0;j<=num_v;j++)
					Distance[i][j]=sqrt((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j]));
	}
	if ( strcmp( bb, "ATT" ) == 0  ){
		graph_type=2;
		for( int i = 0; i <=num_v; ++i ){
			for( int j = 0; j <=num_v; ++j ) {
				double r = (sqrt(((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j]))/10.0));
				int t = (int)r;
				if( (double)t < r ) {
					Distance[ i ][ j ] = t+1;
				}
				else {
					Distance[ i ][ j ] = t;
				}
			}
		}
	}
	if ( strcmp( bb, "CEIL_2D" ) == 0  ){
		graph_type=3;
		for ( i=0;i<=num_v;i++)
			for ( j=0;j<=num_v;j++)
					Distance[i][j]=ceil(sqrt((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j])));
	}
	// determine nearest nodes
	double min_dis;int check_in[num_v+1];int cityNum;
	for ( i=1;i<=num_v;i++){
		for ( j=0;j<=num_v;j++)
			check_in[j]=0;
		check_in[i]=1;
		near[i][0]=i;// the nearest city is itself.
		for (j=1;j<=num_near_nodes-1;j++){
			min_dis=Max;
			for (k=0;k<=num_v;k++){
				if (Distance[i][k]<=min_dis && check_in[k]==0){
					cityNum=k;
					min_dis=Distance[i][k];
				}
			}
			near[i][j]=cityNum;
			check_in[cityNum]=1;
		}
	}
	for ( i=0;i<=num_v;i++)
		for ( j=0;j<=num_v;j++)
			near_ns[i][j]=0;
	for ( i=1;i<=num_v;i++){
		for ( j=1;j<=num_near_nodes-1;j++)
			near_ns[i][near[i][j]]=1;
	}
	// construct sparse graph
	spanning_tree();
	alpha_sparse_graph();
}

void read_data::spanning_tree(){
	//miniming spanning tree
	for (int i=0;i<=num_v;i++){
		city[i].order=i;
		city[i].father=-1;
		city[i].num_son=0;
		for (int j=0;j<=num_v;j++)
			city[i].son[i]=-1;
		check_city[i]=0;
	}
	// generate minimum spanning tree;
//	double low_cost[num_v];
	int v;int pre_v;
	check_city[1]=1;
	pre_v=1;
	for (int i=2;i<=num_v;i++)
		low_cost[i]=Distance[1][i];
	double min_dis;
	for (int i=2;i<=num_v;i++){
		min_dis=Max;
		v=-1;
		for (int j=1;j<=num_v;j++){
			if (check_city[j]==0 && min_dis>low_cost[j]){
				v=j;
				min_dis=low_cost[j];
			}
		}
		if (v!=-1){
			for (int k=1;k<=num_v;k++)
				if (min_dis+1.0e-7>Distance[k][v] && min_dis-1.0e-7<Distance[k][v] && check_city[k]==1)
					pre_v=k;
			check_city[v]=1;
			city[v].father=pre_v;
			city[pre_v].son[city[pre_v].num_son]=v;
			city[pre_v].num_son++;
			//
			for (int k=1;k<=num_v;k++){
				if (check_city[k]==0 && Distance[k][v]<low_cost[k])
					low_cost[k]=Distance[k][v];
			}
		}
	}
	// visit the spanning tree;
	for (int i=0;i<=num_v;i++)
		for (int j=0;j<=num_v;j++)
			edge[i][j]=0;
	visit_tree(1);
}
void read_data::visit_tree(int root){
	if (city[root].num_son!=0){
		for (int i=0;i<=city[root].num_son-1;i++){
			edge[city[root].order][city[root].son[i]]=1;
			edge[city[root].son[i]][city[root].order]=1;
		//	cout<<"edge "<<city[root].order<<","<<city[root].son[i]<<endl;
			visit_tree(city[root].son[i]);
		}
	}
}
void read_data::post_travel_tree(int root){
	if (city[root].num_son!=0){
		for (int i=0;i<=city[root].num_son-1;i++){
			key=city[root].son[i];
			visit_tree_beta(1);
			post_travel_tree(city[root].son[i]);
		}
	}
}
void read_data::visit_tree_beta(int root){
	if (city[root].num_son!=0){
		for (int i=0;i<=city[root].num_son-1;i++){
			if (key!=city[root].son[i] && edge[key][city[root].son[i]]!=1 && beta[key][city[root].son[i]]<0){
				beta[key][city[root].son[i]]=get_max(beta[key][city[root].order],Distance[city[root].son[i]][city[root].order]);
				beta[city[root].son[i]][key]=beta[key][city[root].son[i]];
			}
			if (edge[key][city[root].son[i]]==1 && key!=city[root].son[i] ){
				beta[key][city[root].son[i]]=Distance[city[root].son[i]][key];
				beta[city[root].son[i]][key]=beta[key][city[root].son[i]];
			}
			visit_tree_beta(city[root].son[i]);
		}
	}
}
double read_data:: get_max(double a,double b){
	if (a>b)return a;
	else return b;
}
void read_data::alpha_sparse_graph(){
	int city_1=1;
	int city_2=2;
	double min_edge=Distance[0][city_1];
	double sub_min_edge=Distance[0][city_2];
	for (int i=3;i<=num_v;i++){
		if (Distance[0][i]<min_edge){
			min_edge=Distance[0][i];
			city_1=i;
		}
		if (Distance[0][i]>min_edge && Distance[0][i]<sub_min_edge){
			sub_min_edge=Distance[0][i];
			city_2=i;
		}
	}
	city[0].son[0]=city_1;
	city[0].son[1]=city_2;
	edge[0][city_1]=1;
	edge[0][city_2]=1;
	edge[city_1][0]=1;
	edge[city_2][0]=1;
	///////////////////////////////////////////////////////////////////////////////////////
	//compute alpha for each node and insert it into graph edge
	for (int i=0;i<=num_v;i++)
		for (int j=0;j<=num_v;j++)
			beta[i][j]=-Max;
	// min_edge,sub_min_edge;
	for (int i=1;i<=num_v;i++){
		if (i==city[0].son[0] || i== city[0].son[1])
			continue;
		beta[0][i]=Distance[0][i]-Distance[0][city[0].son[1]];
		beta[i][0]=beta[0][i];
	}
	// compute for root
	key=1;
	visit_tree_beta(1);
	for (int i=0;i<=num_v;i++)
		for (int j=0;j<=num_v;j++)
			if (edge[i][j]==1)
				beta[i][j]=Distance[i][j];
	// compute for leaf
	post_travel_tree(1);
	// generate sparse graph
	for (int i=1;i<=num_v;i++)
		for (int j=1;j<=num_v;j++)
			beta[i][j]=Distance[i][j]-beta[i][j];
	// in this place, beta is matrix alpha
	// sort all value in beta and construct sparse graph
	for (int i=0;i<=num_v;i++)
		for (int j=0;j<=num_v;j++)
			record[i][j]=j;
	for (int i=0;i<=num_v;i++){
		Qsort(i,0,num_v);
	}
	for (int i=0;i<=num_v;i++)
		for (int j=1;j<=alpha;j++){
			edge[i][record[i][j]]=1;
			edge[record[i][j]][i]=1;
		}
}
void read_data::Qsort(int i,int low, int high){
	if (high<=low)return;
	int m=low;
	int j=high+1;
	int k=beta[i][low];
	while (true){
		while(beta[i][++m]<k)
			if (m==high)
				break;
		while (beta[i][--j]>k)
			if (j==low)
				break;
		if (m>=j)
			break;
		double temp=beta[i][m];
		int tem=record[i][m];
		beta[i][m]=beta[i][j];
		beta[i][j]=temp;
		record[i][m]=record[i][j];
		record[i][j]=tem;
	}
	double temp=beta[i][low];
	int tem=record[i][low];
	beta[i][low]=beta[i][j];
	record[i][low]=record[i][j];
	beta[i][j]=temp;
	record[i][j]=tem;
	Qsort(i,low,j-1);
	Qsort(i,j+1,high);
}
/////////////////////////////////////////////////////////////////////////////////////////////////



































void read_data::output_fun(Individual *g_best_p ,int seed){// this function is used to
	int pointer;
	char name_instance[100]={0};
	strcpy(name_instance, instance_n.c_str());
	int size=strlen (name_instance);
	name_instance[size]='_';
	size=strlen( name_instance);
	char num_vehcile[10];
	sprintf(num_vehcile, "%d", v_num);
	int size_1=strlen(num_vehcile);
	for (int i=0;i<=size_1-1;i++)	{
		name_instance[size]=num_vehcile[i];size++;
	}
	name_instance[size]='_';size++;
	char seed_name[10];
	sprintf(seed_name, "%d", seed);
	size_1=strlen( seed_name);
	for (int i=0;i<=size_1-1;i++)	{
		name_instance[size]=seed_name[i];size++;
	}
	char tx[4]={'.','t','x','t'};
	for (int i=0;i<=3;i++){
		name_instance[size]=tx[i];size++;
	}
	cout<<name_instance<<endl;
	ofstream out (name_instance);

	out<<"the best solution's fitness is "<<endl<<g_best_p->fitness<<endl;

	out<<"the time when getting the optimal solution is "<<endl<<optimal_time<<endl;

	//out<< "the time get the best solution is "<<endl<<optimal_time<<endl;
	out<<"the sequence of best solution is following"<<endl;
	for (int i=0;i<=v_num-1;i++){
		pointer=0;
		while (1){
			out<<pointer<<" ";
			pointer=g_best_p->sol[i][pointer];
			if (pointer==0)
				break;
		}
		out<<endl;
	}
	out<<endl;
		double cost=0;int p;double cost_tem;
		for (int i=0;i<=v_num-1;i++){
			p=0;cost_tem=0;
			while (1){
				cost_tem+=Distance[p][g_best_p->sol[i][p]];
				if (g_best_p->sol[i][p]==0)
					break;
				p=g_best_p->sol[i][p];
			}
			if (cost<cost_tem)
				cost=cost_tem;
		}
		out<<"the actuall costs is "<<cost<<endl;
	if (intra_opt==3){
		out<<"the using frequency of each operators in EAX is following"<<endl;
		double sum=0;
		for (i=0;i<=length_s-1;i++)
			for (j=0;j<=length_s-1;j++)
				sum+=use_frequency[i][j];
		double sum_line1=0;
		for (i=0;i<=length_s-1;i++)
			sum_line1+=use_frequency[0][i];
		out<<"the percentage of or-insert is "<< sum_line1/sum<<endl;
		out<<"the percentage of or-swap is "<< 1-sum_line1/sum<<endl;
		out<<"all percentage of each operator is following "<<endl;
		for (i=0;i<=length_s-1;i++){
			for (j=0;j<=length_s-1;j++)
				out<< double(use_frequency[i][j])/sum <<"  ";
			out<<endl;
		}
	}
	out<<endl<<endl;
}

The file read_data.h contains:
/*
 * readdata.h
 *
 *  Created on: 17 Apr 2020
 *      Author: Peng
 */

#ifndef READ_DATA_H_
#define READ_DATA_H_
#include "Individual.h"
#include <time.h>
#include "basic.h"
class read_data {
public:
	read_data();
	virtual ~read_data();
	void define();
	void read_fun(char* file_name,int number_node);
	void output_fun(Individual *g_best_p ,int seed);// this function is employed to output the optimal results.
	int num_v;
	int v_num;
	int determing_longest;
	double ** Distance;// distance between all cities
	int ** near_ns;// the nearest nodes of each node.
	double *x;
	double *y;
	int ** use_frequency;// this variable is used to record the using frequency of each operators in cross_exchange;
	clock_t start;// start computing time
	int graph_type;
	int optimal_time;// this variable is used to record the time when getting the best solution.
	// for spanning tree
	int **edge;
	int alpha=alpha_num;
	// parameters
private:
	int i;
	int j;
	int k;
	string instance_n;
	int ** near;
	/////////////////////////////////////////////////////////////////////////
	// define node structure
	int *check_city;
	struct node{
		int father;
		int *son;
		int order;
		int num_son;
	};
	node * city;
	double *low_cost;
	double **beta;
	int **record;
	void spanning_tree();
	void visit_tree(int root);
	void alpha_sparse_graph();
	void visit_tree_beta(int root);
	void post_travel_tree(int root);
	double get_max(double a,double b);
	void Qsort(int i,int low, int high);
	int key;
};

#endif /* READ_DATA_H_ */

The file solution.cpp contains:
/*
 * solution.cpp
 *
 *  Created on: 17 Apr 2020
 *      Author: Peng
 */
#include "basic.h"
#include "solution.h"
#include "initialsol.h"
#include "LS.h"
#include "EAX.h"
#include "environment.h"
#include "perturb.h"
solution::solution() {
	sol_data=new read_data();// initilization all starting date
}
solution::~solution(){
	delete sol_data;
	delete Init_sol;
	delete curr;
	delete best_s;
	delete global_s;
	delete ls;
	delete gEnv;
	delete per;
	
}
void solution::define(char* file_name,int num_v,int time_l){
	sol_data->read_fun(file_name,num_v);
	Init_sol=new initial_sol ();// initial initial solution object;
	Init_sol->I_data=sol_data;// probe is assigned to direct to previous data
	curr=new Individual();
	curr->define(sol_data->num_v,sol_data->v_num);
	best_s=new Individual();
	best_s->define(sol_data->num_v,sol_data->v_num);
	global_s=new Individual();
	global_s->define(sol_data->num_v,sol_data->v_num);
//	Pop=new Individual[num_pop+lambda];
//	for (int i=0;i<=num_pop+lambda-1;i++)Pop[i].define(sol_data->num_v,sol_data->v_num);
	//Init_sol->s=off;// the probe direct the new off.
	ls=new LS(sol_data);// local search phase
	gEnv = new TEnvironment();
	per = new perturb();
	per->I_data=sol_data;
	per->define();
//	ls->s=off;
	ls->b_s=best_s;
	ls->I_data=sol_data;
	ls->gEnv=gEnv;
	ls->time_length=time_l;
	time_length=time_l;
}
void solution::initial_pop(){// construct the initial population
	for (int i=0;i<=num_initial-1;i++){
		if(ceil((clock() - sol_data->start)/static_cast<double>(CLOCKS_PER_SEC))>=time_length)
			break;
		curr->fitness=Max;
		Init_sol->s=curr;
		Init_sol->greedy_fun();
		ls->s=curr;
		ls->local_search();
		cout<<i<<"  "<<ls->s->fitness<<endl;
		if (curr->fitness<global_s->fitness){
			sol_data->optimal_time=ceil((clock() - sol_data->start)/static_cast<double>(CLOCKS_PER_SEC));
			update_best_solution();
		}
	}
	for (int i=0;i<=sol_data->v_num-1;i++)
		for (int j=0;j<=sol_data->num_v;j++)
			curr->sol[i][j]=global_s->sol[i][j];
	curr->fitness=global_s->fitness;
}
void solution::update_best_solution(){
	for (int i=0;i<=sol_data->v_num-1;i++)
		for (int j=0;j<=sol_data->num_v;j++)
			global_s->sol[i][j]=curr->sol[i][j];
	global_s->fitness=curr->fitness;
}
void solution::main_loop(int seed){
	gEnv->Npop=100;						// number of items
	gEnv->Nch=30;						// number of offsprings
	gEnv->define(sol_data->num_v+1,sol_data->graph_type);//
	best_s->fitness=Max;
	global_s->fitness=Max;
	sol_data->start = clock();// start running time
	initial_pop();// define the initial solution
	best_s->fitness=curr->fitness;
	step=0;int no_improve=0;
	while (1){
		if(ceil((clock() - sol_data->start)/static_cast<double>(CLOCKS_PER_SEC))>=time_length)
			break;
		ls->s=curr;
		//
//		ls->local_search();
		ls->b_s=best_s;
		ls->weak_perturb();
		if (best_s->fitness<global_s->fitness){
			sol_data->optimal_time=ceil((clock() - sol_data->start)/static_cast<double>(CLOCKS_PER_SEC));
			for (int i=0;i<=sol_data->v_num-1;i++){
				for (int j=0;j<=sol_data->num_v;j++)
					global_s->sol[i][j]=best_s->sol[i][j];
			}
			global_s->fitness=best_s->fitness;
			no_improve=0;
		}
		else no_improve++;

		double cost=0;
		int pointer;
		for (int i=0;i<=sol_data->v_num-1;i++){
			pointer=0;
			while(1){
				cost+=sol_data->Distance[curr->sol[i][pointer]][pointer];
				pointer=curr->sol[i][pointer];
				if (pointer==0)break;
			}
		}
		cout<<step<<"      "<<cost<<"    "<<curr->fitness<<"     "<<best_s->fitness<<"    "<<global_s->fitness<<"      "<<no_improve<<endl;
		// enter disturbation phase

//		if (no_improve>perturbation_num){
//			per->s=curr;
//			per->no_improve=no_improve;
//			per->perturbation();
//			no_improve=0;
//		}
		step++;
	}
	sol_data->output_fun(global_s,seed);
}

The file solution.h contains:
/*
 * solution.h
 *
 *  Created on: 17 Apr 2020
 *      Author: Peng
 */

#ifndef SOLUTION_H_
#define SOLUTION_H_
#include"initialsol.h"
#include "read_data.h"
#include "Individual.h"
#include "LS.h"
#include "environment.h"
#include "perturb.h"
class solution {
public:
	solution();
	virtual ~solution();
	void define(char * file_name,int num_v,int time_length);
	void main_loop(int seed);
	read_data * sol_data;
	initial_sol * Init_sol;
	Individual * curr;
	Individual * best_s;
	Individual * global_s;
//	Individual * Pop;
	LS * ls;
	TEnvironment * gEnv;
	perturb * per;

private:
	void update_best_solution();
	void initial_pop();
	int num_ind;// is used to record the number of individuals in iterative process
	int step;
	int time_length;
};

#endif /* SOLUTION_H_ */




/* void solution::pop_diversity(int replace){// this function is used to calculate the
	if (replace==0){
		div_degree[step]=div_degree[step-1];
		return;
	}
	int pointer;int tem;
	double total_distance=0;double edge=0;
	for (int i=0;i<=num_pop-2;i++)
		for (int j=i+1;j<=num_pop-1;j++){
			for (int i=0;i<=sol_data->v_num-1;i++){
				pointer=Pop[j].sol[i][0];
				while (pointer!=0){
					s_t[pointer]=i;
					pointer=Pop[j].sol[i][pointer];
				}
			}
			for (int k=0;k<=sol_data->v_num-1;k++){
				pointer=0;
				while (1){// the edge with two endpoints: pointer, Pop[i].sol[k][pointer].
					tem=Pop[i].sol[k][pointer];
					if (tem>0){
						if (Pop[j].sol[s_t[tem]][tem]==pointer || Pop[j].sol_r[s_t[tem]][tem]==pointer)
							total_distance++;
						else
							edge++;
						pointer=Pop[i].sol[k][pointer];
					}
					if (tem==0){
						if (Pop[j].sol[s_t[pointer]][pointer]==tem || Pop[j].sol_r[s_t[pointer]][pointer]==tem)
							total_distance++;
						else
							edge++;
						break;
					}
				}
			}
		}
	total_distance=(total_distance*2)/(num_pop*(num_pop-1));
	edge=(edge*2)/(num_pop*(num_pop-1));
	div_degree[step]=edge;
} */

The file sort.cpp contains:
/*
 * sort.cpp
 *   created on: April 24, 2013
 * last updated: June 13, 2013
 *       author: liushujia
 */

#ifndef __Sort__
#include "sort.h"
#endif

TSort* tSort = NULL;

void InitSort(){
	tSort = new TSort();
}

void swap(int &x, int &y){
	int s=x;
	x=y;
	y=s;
}

void selectionSort(int* Arg, int l, int r){
	int id;
	for(int i=l;i<r;++i){
		id=i;
		for(int j=i+1;j<=r;++j)
			if(Arg[j]<Arg[id]) id=j;
		swap(Arg[i], Arg[id]);
	}
}

int partition(int* Arg, int l, int r){
	int id=l+rand()%(r-l+1);
	swap(Arg[l], Arg[id]);
	id=l;
	for(int i=l+1;i<=r;++i)
		if(Arg[i]<Arg[l]) swap(Arg[++id], Arg[i]);
	swap(Arg[l], Arg[id]);
	return id;
}

void quickSort(int* Arg, int l, int r){
	if(l<r){
		if(r-l<20){	// Ã¥Â°ï¿½Ã¨Â§â€žÃ¦Â¨Â¡Ã¦â€¢Â°Ã¦ï¿½Â®Ã§â€�Â¨Ã©â‚¬â€°Ã¦â€¹Â©Ã¦Å½â€™Ã¥Âºï¿½Ã©â‚¬Å¸Ã¥ÂºÂ¦Ã¦â€ºÂ´Ã¥Â¿Â«
			selectionSort(Arg, l, r);
			return ;
		}
		int mid=partition(Arg, l, r);
		quickSort(Arg, l, mid-1);
		quickSort(Arg, mid+1, r);
	}
}

TSort::TSort(){}
TSort::~TSort(){}

void TSort::index( double* Arg, int numOfArg, int* indexOrderd, int numOfOrd ){
	int indexBest = 0;
	double valueBest;
	int *checked = new int [ numOfArg ];
	for( int i = 0 ; i < numOfArg ; ++i ) checked[ i ] = 0;
	for( int i = 0; i < numOfOrd; ++i ){
		valueBest = 99999999999.9;
		for( int j = 0; j < numOfArg; ++j ){
			if( ( Arg[j] < valueBest ) && checked[j]==0){
				valueBest = Arg[j];
				indexBest = j;
			}
		}
		indexOrderd[ i ]=indexBest;
		checked[ indexBest ]=1;
	}
	delete [] checked;
}

void TSort::indexB( double* Arg, int numOfArg, int* indexOrderd, int numOfOrd ){
	int indexBest = 0;
	double valueBest;
	int *checked = new int [ numOfArg ];
	for( int i = 0 ; i < numOfArg ; ++i ) checked[ i ] = 0;
	for( int i = 0; i < numOfOrd; ++i ){
		valueBest = -99999999999.9;
		for( int j = 0; j < numOfArg; ++j ){
			if( ( Arg[j] > valueBest ) && checked[j]==0){
				valueBest = Arg[j];
				indexBest = j;
			}
		}
		indexOrderd[ i ]=indexBest;
		checked[ indexBest ]=1;
	}
	delete [] checked;
}

void TSort::index( int* Arg, int numOfArg, int* indexOrderd, int numOfOrd ){
	int indexBest = 0;
	int valueBest;
	int *checked = new int [ numOfArg ];
	for( int i = 0 ; i < numOfArg ; ++i ) checked[ i ] = 0;
	for( int i = 0; i < numOfOrd; ++i ){
		valueBest = 99999999;
		for( int j = 0; j < numOfArg; ++j ){
			if( ( Arg[j] < valueBest ) && checked[j]==0){
				valueBest = Arg[j];
				indexBest = j;
			}
		}
		indexOrderd[ i ]=indexBest;
		checked[ indexBest ]=1;
	}
	delete [] checked;
}

void TSort::indexB( int* Arg, int numOfArg, int* indexOrderd, int numOfOrd ){
	int indexBest = 0;
	int valueBest;
	int *checked = new int [ numOfArg ];
	for( int i = 0 ; i < numOfArg ; ++i ) checked[ i ] = 0;
	for( int i = 0; i < numOfOrd; ++i ){
		valueBest = -999999999;
		for( int j = 0; j < numOfArg; ++j ){
			if( ( Arg[j] > valueBest ) && checked[j]==0){
				valueBest = Arg[j];
				indexBest = j;
			}
		}
		indexOrderd[ i ]=indexBest;
		checked[ indexBest ]=1;
	}
	delete [] checked;
}

void TSort::sort( int* Arg, int numOfArg ){
	//selectionSort(Arg, 0, numOfArg-1);
	quickSort(Arg, 0, numOfArg-1);
}


The file sort.h contains:
/*
 * sort.h
 *   created on: April 24, 2013
 * last updated: June 13, 2013
 *       author: liushujia
 */

#ifndef __SORT__
#define __SORT__

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <assert.h>
#include <algorithm>
using namespace std;

void InitSort();
void swap(int &x, int &y);						// äº¤æ�¢ä¸¤ä¸ªæ•°
void selectionSort(int* Arg, int l, int r);		// é€‰æ‹©æŽ’åº�
int partition(int* Arg, int l, int r);			// å¿«é€ŸæŽ’åº�åˆ†è§£å­�ç¨‹åº�
void quickSort(int* Arg, int l, int r);			// å¿«é€ŸæŽ’åº�

class TSort{
public:
	TSort();
	~TSort();
	void index( double* Arg, int numOfArg, int* indexOrderd, int numOfOrd );
	void index( int* Arg, int numOfArg, int* indexOrderd, int numOfOrd );
	void indexB( double* Arg, int numOfArg, int* indexOrderd, int numOfOrd );
	void indexB( int* Arg, int numOfArg, int* indexOrderd, int numOfOrd );
	void sort( int* Arg, int numOfArg );
};

extern TSort* tSort;

#endif

The file Tstwoopt.cpp contains:
/*
 * Tstwoopt.cpp
 *
 *  Created on: 19 Apr 2020
 *      Author: Peng
 */

#include "Tstwoopt.h"
#include "basic.h"
#include "read_data.h"
using namespace std;
Tstwoopt::Tstwoopt(read_data * data) {
	tabu=new int *[data->num_v+1];
	for (int i=0;i<=data->num_v;i++)
		tabu[i]=new int [data->num_v+1];
	num_v=data->num_v;
}
Tstwoopt::~Tstwoopt() {
	for (int i=0;i<=num_v;i++)
		delete [] tabu[i];
	delete [] tabu;
}
double Tstwoopt::calculat_delta(int u1,int v1,int u2,int v2){
	return(I_data->Distance[u1][u2]+I_data->Distance[v1][v2]-I_data->Distance[u1][v1]-I_data->Distance[u2][v2]);
}

void Tstwoopt::reverse(int * s, int reverse_1,int reverse_2,int n_v){
	int temp;
	while (reverse_2 - reverse_1>0){
		temp=s[reverse_1%n_v];
		s[reverse_1%n_v]=s[reverse_2%n_v];
		s[reverse_2%n_v]=temp;
		reverse_1++;
		reverse_2--;
	}
}
void Tstwoopt::twoopt(int *s, int n_v){// the n is the number of cities in route s.
	int best_s[n_v];
	for (int i=0;i<=n_v-1;i++)
		best_s[i]=s[i];
	int reverse_1,reverse_2;
	double delta_1;
	int v1,v2,u1,u2;
	double min_delta;
	while (1){
		min_delta=Max;min_delta--;
		for (int i=0;i<=n_v-1;i++){
			u1=i;
			v1=(i+1)%n_v;
			for (int j=i+2;(j+1)%n_v!=i;j++){
				u2=j%n_v;
				v2=(j+1)%n_v;
				delta_1=calculat_delta(s[u1],s[v1],s[u2],s[v2]);
				if (min_delta>delta_1){
					min_delta=delta_1;
					reverse_1=i+1;
					reverse_2=j;
				}
			}
		}
		if (min_delta<-1.0e-7)
			reverse(s, reverse_1,reverse_2,n_v);
		else
			break;
	}
	int k;
	for (int i=0;i<=n_v-1;i++)
		best_s[i]=s[i];
	for (int i=0;i<=n_v-1;i++)
		if (best_s[i]==0){
			k=i;break;
			}
	s[0]=0;int c=1;
	for (int j=k+1;best_s[j%n_v]!=0;j++){
		s[c]=best_s[j%n_v];c++;
	}
}
double Tstwoopt::calculate_length_tour(int *s, int n_v){
	double path_length=0;
	for (int i=0;i<=n_v-2;i++)
		path_length+=I_data->Distance[s[i]][s[i+1]];
	path_length+=I_data->Distance[s[n_v-1]][s[0]];
	return path_length;
}
void Tstwoopt::tabu_search(int * s, int n_v)// this code employs 2-opt and tabu search to optimize a traditional TSP
{
	a=0;
	for (int i=0;i<=n_v-1;i++)
		if (s[i]>a)
			a=s[i];
	a++;
	for (int i=0;i<=a-1;i++)
		for (int j=0;j<=a-1;j++)
			tabu[i][j]=0;
//	double delta[num_v][num_v];// it should be noticed becasue the delta value is caltulated by exchanging edges, not nodes
	// in the first step a simple 2-opt algorithm should be employed.
	int best_s[n_v];
	for (int i=0;i<=n_v-1;i++)
		best_s[i]=s[i];
	double path_length=0;
	path_length=calculate_length_tour(s,n_v);
	double best_path=path_length;
	int reverse_1,reverse_2;
	double min_delta,min_tabu_delta;
	int num_best,num_tabu_best;
	double delta_1;
	int step=0;int v1,v2,u1,u2;
	int no_improve=0;
	int tabu_length=ceil (n_v*0.1);
	while (1){
		step++;
		min_delta=Max;min_tabu_delta=Max;num_best=0;num_tabu_best=0;min_delta--;min_tabu_delta--;
		for (int i=0;i<=n_v-1;i++)	{
			u1=i;
			v1=(i+1)%n_v;
			for (int j=i+2;(j+1)%n_v!=i;j++){
				u2=j%n_v;
				v2=(j+1)%n_v;
				delta_1=calculat_delta(s[u1],s[v1],s[u2],s[v2]);
				if (tabu[s[u1]][s[v1]]<=step && tabu[s[u2]][s[v2]]<=step)	{
					if (delta_1<min_delta){
						min_delta=delta_1;
						can_node_1[0]=i+1;
						can_node_2[0]=j;
						num_best=1;
					}
					else if (min_delta==delta_1 && num_best<100){
						can_node_1[num_best]=i+1;
						can_node_2[num_best]=j;
						num_best++;
					}
				}
				else if (tabu[s[u1]][s[v1]]>step || tabu[s[u2]][s[v2]]>step)	{
					if (min_tabu_delta>delta_1)	{
						min_tabu_delta=delta_1;
						can_tabu_node_1[0]=i+1;
						can_tabu_node_2[0]=j;
						num_tabu_best=1;
					}
					else if (min_tabu_delta==delta_1 && num_tabu_best<100)	{
						can_tabu_node_1[num_tabu_best]=i+1;
						can_tabu_node_2[num_tabu_best]=j;
						num_tabu_best++;
					}
				}
			}
		}
		int rand_order;
		if ((num_tabu_best>0 && min_tabu_delta+1.0e-7<min_delta && (path_length + min_tabu_delta+1.0e-7< best_path)) || num_best==0){
			path_length+=min_tabu_delta;
			rand_order=rand()% num_tabu_best;
			reverse_1=can_tabu_node_1[rand_order];
			reverse_2=can_tabu_node_2[rand_order];
			tabu[s[(reverse_1-1)%n_v]][s[reverse_2%n_v]]=step+tabu_length+rand()%tabu_length;
			tabu[s[(reverse_2+1)%n_v]][s[reverse_1%n_v]]=step+tabu_length+rand()%tabu_length;
			reverse(s, reverse_1,reverse_2,n_v);
		}
		else{
			path_length+=min_delta;
			rand_order=rand()%num_best;
			reverse_1=can_node_1[rand_order];
			reverse_2=can_node_2[rand_order];
			tabu[s[(reverse_1-1)%n_v]][s[reverse_2%n_v]]=step+tabu_length+rand()%tabu_length;
			tabu[s[(reverse_2+1)%n_v]][s[reverse_1%n_v]]=step+tabu_length+rand()%tabu_length;
			reverse(s,reverse_1,reverse_2,n_v);
		}
		if (best_path>path_length)	{
			best_path=path_length;
			for (int i=0;i<=n_v-1;i++)
				best_s[i]=s[i];
			no_improve=0;
		}
		else
			no_improve++;
		if (n_v<10){
			if (no_improve>=5)//10
				break;
			if (step>50)
				break;
		}
		else{
			if (no_improve>(n_v))//10   an important parameters
			break;
			if (step>n_v*5*10)
				break;
		}
	}
	int k;
	for (int i=0;i<=n_v-1;i++)
		if (best_s[i]==0)
		{	k=i;break;}
	s[0]=0;int c=1;
	for (int j=k+1;best_s[j%n_v]!=0;j++){
		s[c]=best_s[j%n_v];c++;
	}
}

The file Tstwoopt.h contains:
/*
 * Tstwoopt.h
 *
 *  Created on: 19 Apr 2020
 *      Author: Peng
 */

#ifndef TSTWOOPT_H_
#define TSTWOOPT_H_
#include "read_data.h"
class Tstwoopt {
public:
	Tstwoopt(read_data * data);
	virtual ~Tstwoopt();
	void twoopt(int *s, int n);
	void tabu_search(int *s, int n_v);
	read_data * I_data;

private:
	double calculate_length_tour(int* s,int n_v);
	double calculat_delta(int u1,int v1,int u2,int v2);
	void reverse(int * s, int reverse_1,int reverse_2,int n_v);
	int can_node_1[100];
	int can_node_2[100];
	int can_tabu_node_1[100];
	int can_tabu_node_2[100];
	int ** tabu;
	int num_v;
	int a;
};

#endif /* TSTWOOPT_H_ */

